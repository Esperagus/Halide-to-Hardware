g++ -std=c++11 -I ../../../../distrib/include/ -I ../../../../distrib/tools/ -I /nobackup/joeyliu/aha/coreir/include -L/nobackup/joeyliu/aha/coreir/lib -Wl,-rpath,/nobackup/joeyliu/aha/coreir/lib -I/nobackup/joeyliu/BufferMapping/cfunc/include -g -fno-rtti conv_3_3_generator.cpp ../../../../distrib/lib/libHalide.a ../../../../distrib/tools/GenGen.cpp -o bin/conv_3_3.generator  -ldl -lpthread -lz -lcurses -L/nobackup/joeyliu/aha/coreir/lib -Wl,-rpath,/nobackup/joeyliu/aha/coreir/lib -lcoreir-commonlib -lcoreir -lcoreirsim -lcoreir-float -L/nobackup/joeyliu/BufferMapping/cfunc/bin -lfuncubuf 
bin/conv_3_3.generator -g conv_3_3 -o ./bin -f conv_3_3 target=host
doing sliding window lowering pass
Doing sliding window analysis on realization of hw_input_global_wrapper
visiting pc sliding window for hw_input_global_wrapper
for dim=0  var=hw_input_global_wrapper.s0.x  max=(output.s0.x + 2)  min=output.s0.x
for dim=1  var=hw_input_global_wrapper.s0.y  max=(output.s0.y + 2)  min=output.s0.y
func hw_input_global_wrapper provides={[hw_input_global_wrapper.s0.x.min, hw_input_global_wrapper.s0.x.max], [hw_input_global_wrapper.s0.y.min, hw_input_global_wrapper.s0.y.max]} requires={}
output stencil: 3 for dim 0
input stencil: 1
Sliding hw_input_global_wrapper over dimension x along loop variable output.s0.x
 where min=output.s0.x  max=(output.s0.x + 2) max_prev_plus_one=(((output.s0.x - 1) + 2) + 1)

Sliding hw_input_global_wrapper, x
  Pushing min up from output.s0.x to (((output.s0.x - 1) + 2) + 1)
  Shrinking max from (output.s0.x + 2) to (output.s0.x + 2)
visiting pc sliding window for hw_input_global_wrapper
for dim=0  var=hw_input_global_wrapper.s0.x  max=(output.s0.x + 2)  min=(output.s0.x + 2)
for dim=1  var=hw_input_global_wrapper.s0.y  max=(output.s0.y + 2)  min=output.s0.y
func hw_input_global_wrapper provides={[hw_input_global_wrapper.s0.x.min, hw_input_global_wrapper.s0.x.max], [hw_input_global_wrapper.s0.y.min, hw_input_global_wrapper.s0.y.max]} requires={}
output stencil: 3 for dim 1
input stencil: 1
Sliding hw_input_global_wrapper over dimension y along loop variable output.s0.y
 where min=output.s0.y  max=(output.s0.y + 2) max_prev_plus_one=(((output.s0.y - 1) + 2) + 1)

Sliding hw_input_global_wrapper, y
  Pushing min up from output.s0.y to (((output.s0.y - 1) + 2) + 1)
  Shrinking max from (output.s0.y + 2) to (output.s0.y + 2)
extracting hw buffers
  did not fold kernel
  did not fold conv
output.s0.y is being looked at

Considering folding hw_input_global_wrapper over for loop over output.s0.y dimension 1
Min: output.s0.y
Max: (output.s0.y + 2)
Extent: 3
explicit_factor: (undefined)
   Proceeding with factor 4
  folding hw_input_global_wrapper with bounds 
  0 : 64
  0 : 64
folding dim 1 to 4
Flattening hw_input_global_wrapper because it is not a stream nor a stencil.
Flattening conv because it is not a stream nor a stencil.
Flattening kernel because it is not a stream nor a stencil.
Module.compile(): c_header_name ./bin/conv_3_3.h called conv_3_3
creating file from name: conv_3_3
g++ -std=c++11 -I ../../../../distrib/include/ -I ../../../../distrib/tools/ -I /nobackup/joeyliu/aha/coreir/include -L/nobackup/joeyliu/aha/coreir/lib -Wl,-rpath,/nobackup/joeyliu/aha/coreir/lib -I/nobackup/joeyliu/BufferMapping/cfunc/include -I./bin -I../../hw_support -I../../hw_support/xilinx_hls_lib_2015_4 -Wall -DC_TEST -Wno-unknown-pragmas -Wno-unused-label -Wno-uninitialized -Wno-literal-suffix  -O3 process.cpp bin/conv_3_3.a ../../hw_support/./bin/hardware_process_helper.o ../../hw_support/./bin/coreir_interpret.o ../../hw_support/coreir_sim_plugins.o -o bin/process  -ldl -lpthread -lz -lcurses -L/nobackup/joeyliu/aha/coreir/lib -Wl,-rpath,/nobackup/joeyliu/aha/coreir/lib -lcoreir-commonlib -lcoreir -lcoreirsim -lcoreir-float -L/nobackup/joeyliu/BufferMapping/cfunc/bin -lfuncubuf  -lpng16  -ljpeg -I/usr/include/libpng16 -I/usr/include/libpng16/..
make[1]: Entering directory '/nobackup/joeyliu/aha/Halide-to-Hardware/apps/hardware_benchmarks/tests/conv_3_3'
bin/conv_3_3.generator -g conv_3_3 -o ./bin -f conv_3_3 target=host-coreir-coreir_valid -e coreir
accelerate function hw_output at xi xo
compute level is: defined=1 varname=xi
store level is: defined=1 varname=xo
conv is a kernel now
hw_output is a kernel now
kernel is a kernel now
doing sliding window lowering pass
Doing sliding window analysis on realization of conv
visiting pc sliding window for conv
for dim=0  var=conv.s1.x  max=(hw_output.s0.x.xi + hw_output.s0.x.xi.base)  min=(hw_output.s0.x.xi + hw_output.s0.x.xi.base)
for dim=1  var=conv.s1.y  max=(hw_output.s0.y.yi + hw_output.s0.y.yi.base)  min=(hw_output.s0.y.yi + hw_output.s0.y.yi.base)
func conv provides={[min(conv.s0.x.min, conv.s1.x.min), max(conv.s0.x.max, conv.s1.x.max)], [min(conv.s0.y.min, conv.s1.y.min), max(conv.s0.y.max, conv.s1.y.max)]} requires={[conv.s1.x.min, conv.s1.x.max], [conv.s1.y.min, conv.s1.y.max]}
output stencil: 1 for dim 0
input stencil: 1
Sliding conv over dimension x along loop variable hw_output.s0.x.xi
 where min=(hw_output.s0.x.xi + hw_output.s0.x.xi.base)  max=(hw_output.s0.x.xi + hw_output.s0.x.xi.base) max_prev_plus_one=(((hw_output.s0.x.xi - 1) + hw_output.s0.x.xi.base) + 1)

visiting pc sliding window for conv
for dim=0  var=conv.s1.x  max=(hw_output.s0.x.xi + hw_output.s0.x.xi.base)  min=(hw_output.s0.x.xi + hw_output.s0.x.xi.base)
for dim=1  var=conv.s1.y  max=(hw_output.s0.y.yi + hw_output.s0.y.yi.base)  min=(hw_output.s0.y.yi + hw_output.s0.y.yi.base)
func conv provides={[min(conv.s0.x.min, conv.s1.x.min), max(conv.s0.x.max, conv.s1.x.max)], [min(conv.s0.y.min, conv.s1.y.min), max(conv.s0.y.max, conv.s1.y.max)]} requires={[conv.s1.x.min, conv.s1.x.max], [conv.s1.y.min, conv.s1.y.max]}
output stencil: 1 for dim 1
input stencil: 1
Sliding conv over dimension y along loop variable hw_output.s0.y.yi
 where min=(hw_output.s0.y.yi + hw_output.s0.y.yi.base)  max=(hw_output.s0.y.yi + hw_output.s0.y.yi.base) max_prev_plus_one=(((hw_output.s0.y.yi - 1) + hw_output.s0.y.yi.base) + 1)

finished sliding window lowering pass
let output.s0.y.max = ((output.min.1 + output.extent.1) - 1)
let output.s0.y.min = output.min.1
let output.s0.x.max = ((output.min.0 + output.extent.0) - 1)
let output.s0.x.min = output.min.0
let output.s0.y.max_unbounded = output.s0.y.max
let output.s0.y.min_unbounded = output.s0.y.min
let output.s0.y.max = ((0 + 62) - 1)
let output.s0.y.min = 0
let output.s0.x.max_unbounded = output.s0.x.max
let output.s0.x.min_unbounded = output.s0.x.min
let output.s0.x.max = ((0 + 62) - 1)
let output.s0.x.min = 0
let hw_output.s0.y.max = output.s0.y.max
let hw_output.s0.y.min = output.s0.y.min
let hw_output.s0.x.max = output.s0.x.max
let hw_output.s0.x.min = output.s0.x.min
let conv.s1.r$y.max = ((3 + 0) - 1)
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = ((3 + 0) - 1)
let conv.s1.r$x.min = 0
let conv.s1.y.max = hw_output.s0.y.max
let conv.s1.y.min = hw_output.s0.y.min
let conv.s1.x.max = hw_output.s0.x.max
let conv.s1.x.min = hw_output.s0.x.min
let conv.s0.y.max = conv.s1.y.max
let conv.s0.y.min = conv.s1.y.min
let conv.s0.x.max = conv.s1.x.max
let conv.s0.x.min = conv.s1.x.min
let kernel.s9.y.max = conv.s1.r$y.max
let kernel.s9.y.min = conv.s1.r$y.min
let kernel.s9.x.max = conv.s1.r$x.max
let kernel.s9.x.min = conv.s1.r$x.min
let kernel.s8.y.max = conv.s1.r$y.max
let kernel.s8.y.min = conv.s1.r$y.min
let kernel.s8.x.max = conv.s1.r$x.max
let kernel.s8.x.min = conv.s1.r$x.min
let kernel.s7.y.max = conv.s1.r$y.max
let kernel.s7.y.min = conv.s1.r$y.min
let kernel.s7.x.max = conv.s1.r$x.max
let kernel.s7.x.min = conv.s1.r$x.min
let kernel.s6.y.max = conv.s1.r$y.max
let kernel.s6.y.min = conv.s1.r$y.min
let kernel.s6.x.max = conv.s1.r$x.max
let kernel.s6.x.min = conv.s1.r$x.min
let kernel.s5.y.max = conv.s1.r$y.max
let kernel.s5.y.min = conv.s1.r$y.min
let kernel.s5.x.max = conv.s1.r$x.max
let kernel.s5.x.min = conv.s1.r$x.min
let kernel.s4.y.max = conv.s1.r$y.max
let kernel.s4.y.min = conv.s1.r$y.min
let kernel.s4.x.max = conv.s1.r$x.max
let kernel.s4.x.min = conv.s1.r$x.min
let kernel.s3.y.max = conv.s1.r$y.max
let kernel.s3.y.min = conv.s1.r$y.min
let kernel.s3.x.max = conv.s1.r$x.max
let kernel.s3.x.min = conv.s1.r$x.min
let kernel.s2.y.max = conv.s1.r$y.max
let kernel.s2.y.min = conv.s1.r$y.min
let kernel.s2.x.max = conv.s1.r$x.max
let kernel.s2.x.min = conv.s1.r$x.min
let kernel.s1.y.max = conv.s1.r$y.max
let kernel.s1.y.min = conv.s1.r$y.min
let kernel.s1.x.max = conv.s1.r$x.max
let kernel.s1.x.min = conv.s1.r$x.min
let kernel.s0.y.max = conv.s1.r$y.max
let kernel.s0.y.min = conv.s1.r$y.min
let kernel.s0.x.max = conv.s1.r$x.max
let kernel.s0.x.min = conv.s1.r$x.min
let hw_input.s0.y.max = (conv.s1.y.max + conv.s1.r$y.max)
let hw_input.s0.y.min = (conv.s1.y.min + conv.s1.r$y.min)
let hw_input.s0.x.max = (conv.s1.x.max + conv.s1.r$x.max)
let hw_input.s0.x.min = (conv.s1.x.min + conv.s1.r$x.min)
let input.extent.0.required = ((hw_input.s0.x.max + 1) - hw_input.s0.x.min)
let input.min.0.required = hw_input.s0.x.min
let input.stride.0.required = 1
let input.extent.1.required = ((hw_input.s0.y.max + 1) - hw_input.s0.y.min)
let input.min.1.required = hw_input.s0.y.min
let input.stride.1.required = (input.stride.0.required*input.extent.0.required)
let output.extent.0.required = ((output.s0.x.max + 1) - output.s0.x.min)
let output.min.0.required = output.s0.x.min
let output.stride.0.required = 1
let output.extent.1.required = ((output.s0.y.max + 1) - output.s0.y.min)
let output.min.1.required = output.s0.y.min
let output.stride.1.required = (output.stride.0.required*output.extent.0.required)
let input.stride.0.constrained = 1
let output.stride.0.constrained = 1
let input.stride.0.proposed = 1
let input.min.0.proposed = input.min.0.required
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = input.stride.1.required
let input.min.1.proposed = input.min.1.required
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = output.min.0.required
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = output.stride.1.required
let output.min.1.proposed = output.min.1.required
let output.extent.1.proposed = output.extent.1.required
assert((!_halide_buffer_is_bounds_query(input.buffer) || ((input.min.0.proposed <= input.min.0.required) && (((input.min.0.proposed + input.extent.0.proposed) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, input.min.0.proposed, ((input.min.0.proposed + input.extent.0.proposed) - 1), input.min.0.required, ((input.min.0.required + input.extent.0.required) - 1)))
assert((!_halide_buffer_is_bounds_query(input.buffer) || ((input.min.1.proposed <= input.min.1.required) && (((input.min.1.proposed + input.extent.1.proposed) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, input.min.1.proposed, ((input.min.1.proposed + input.extent.1.proposed) - 1), input.min.1.required, ((input.min.1.required + input.extent.1.required) - 1)))
assert((!_halide_buffer_is_bounds_query(output.buffer) || ((output.min.0.proposed <= output.min.0.required) && (((output.min.0.proposed + output.extent.0.proposed) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer output", 0, output.min.0.proposed, ((output.min.0.proposed + output.extent.0.proposed) - 1), output.min.0.required, ((output.min.0.required + output.extent.0.required) - 1)))
assert((!_halide_buffer_is_bounds_query(output.buffer) || ((output.min.1.proposed <= output.min.1.required) && (((output.min.1.proposed + output.extent.1.proposed) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer output", 1, output.min.1.proposed, ((output.min.1.proposed + output.extent.1.proposed) - 1), output.min.1.required, ((output.min.1.required + output.extent.1.required) - 1)))
if (_halide_buffer_is_bounds_query(input.buffer)) {
  _halide_buffer_init(input.buffer, _halide_buffer_get_shape(input.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 2, make_struct((halide_dimension_t *), input.min.0.proposed, input.extent.0.proposed, input.stride.0.proposed, 0, input.min.1.proposed, input.extent.1.proposed, input.stride.1.proposed, 0), (uint64)0)
}
if (_halide_buffer_is_bounds_query(output.buffer)) {
  _halide_buffer_init(output.buffer, _halide_buffer_get_shape(output.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 2, make_struct((halide_dimension_t *), output.min.0.proposed, output.extent.0.proposed, output.stride.0.proposed, 0, output.min.1.proposed, output.extent.1.proposed, output.stride.1.proposed, 0), (uint64)0)
}
if (!(((uint1)0 || _halide_buffer_is_bounds_query(input.buffer)) || _halide_buffer_is_bounds_query(output.buffer))) {
  assert((((input.type.code == (uint8)1) && (input.type.bits == (uint8)8)) && (input.type.lanes == (uint16)1)), halide_error_bad_type("Input buffer input", input.type.code, (uint8)1, input.type.bits, (uint8)8, input.type.lanes, (uint16)1))
  assert((input.dimensions == 2), halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
  assert((((output.type.code == (uint8)1) && (output.type.bits == (uint8)8)) && (output.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer output", output.type.code, (uint8)1, output.type.bits, (uint8)8, output.type.lanes, (uint16)1))
  assert((output.dimensions == 2), halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
  assert(((input.min.0 <= input.min.0.required) && (((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1))), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, ((input.min.0.required + input.extent.0.required) - 1), input.min.0, ((input.min.0 + input.extent.0) - 1)))
  assert((input.extent.0 >= 0), halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
  assert(((input.min.1 <= input.min.1.required) && (((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1))), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, ((input.min.1.required + input.extent.1.required) - 1), input.min.1, ((input.min.1 + input.extent.1) - 1)))
  assert((input.extent.1 >= 0), halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
  assert(((output.min.0 <= output.min.0.required) && (((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1))), halide_error_access_out_of_bounds("Output buffer output", 0, output.min.0.required, ((output.min.0.required + output.extent.0.required) - 1), output.min.0, ((output.min.0 + output.extent.0) - 1)))
  assert((output.extent.0 >= 0), halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
  assert(((output.min.1 <= output.min.1.required) && (((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1))), halide_error_access_out_of_bounds("Output buffer output", 1, output.min.1.required, ((output.min.1.required + output.extent.1.required) - 1), output.min.1, ((output.min.1 + output.extent.1) - 1)))
  assert((output.extent.1 >= 0), halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
  assert((input.stride.0 == input.stride.0.constrained), halide_error_constraint_violated("input.stride.0", input.stride.0, "1", input.stride.0.constrained))
  assert((output.stride.0 == output.stride.0.constrained), halide_error_constraint_violated("output.stride.0", output.stride.0, "1", output.stride.0.constrained))
  let input.total_extent.0 = int64(input.extent.0)
  let input.total_extent.1 = (int64(input.extent.1)*input.total_extent.0)
  let output.total_extent.0 = int64(output.extent.0)
  let output.total_extent.1 = (int64(output.extent.1)*output.total_extent.0)
  assert((abs((int64(input.extent.0)*int64(input.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("input", abs((int64(input.extent.0)*int64(input.stride.0.constrained))), (uint64)2147483647))
  assert((abs((int64(input.extent.1)*int64(input.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("input", abs((int64(input.extent.1)*int64(input.stride.1))), (uint64)2147483647))
  assert((input.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
  assert((abs((int64(output.extent.0)*int64(output.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("output", abs((int64(output.extent.0)*int64(output.stride.0.constrained))), (uint64)2147483647))
  assert((abs((int64(output.extent.1)*int64(output.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("output", abs((int64(output.extent.1)*int64(output.stride.1))), (uint64)2147483647))
  assert((output.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
  assert((input != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Input buffer input"))
  assert((output != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer output"))
  let hw_input.y.max_realized = max((min((((((hw_output.s0.y.max - hw_output.s0.y.min)/62)*62) + hw_output.s0.y.min) + 61), hw_output.s0.y.max) + 2), hw_input.s0.y.max)
  let hw_input.y.min_realized = min(min((hw_output.s0.y.max + -61), hw_output.s0.y.min), hw_input.s0.y.min)
  let hw_input.y.extent_realized = ((max((min((((((hw_output.s0.y.max - hw_output.s0.y.min)/62)*62) + hw_output.s0.y.min) + 61), hw_output.s0.y.max) + 2), hw_input.s0.y.max) - min(min((hw_output.s0.y.max + -61), hw_output.s0.y.min), hw_input.s0.y.min)) + 1)
  let hw_input.x.max_realized = max((min((((((hw_output.s0.x.max - hw_output.s0.x.min)/62)*62) + hw_output.s0.x.min) + 61), hw_output.s0.x.max) + 2), hw_input.s0.x.max)
  let hw_input.x.min_realized = min(min((hw_output.s0.x.max + -61), hw_output.s0.x.min), hw_input.s0.x.min)
  let hw_input.x.extent_realized = ((max((min((((((hw_output.s0.x.max - hw_output.s0.x.min)/62)*62) + hw_output.s0.x.min) + 61), hw_output.s0.x.max) + 2), hw_input.s0.x.max) - min(min((hw_output.s0.x.max + -61), hw_output.s0.x.min), hw_input.s0.x.min)) + 1)
  realize hw_input([hw_input.x.min_realized, hw_input.x.extent_realized], [hw_input.y.min_realized, hw_input.y.extent_realized]) {
    produce hw_input {
      let hw_input.s0.y.loop_max = hw_input.s0.y.max
      let hw_input.s0.y.loop_min = hw_input.s0.y.min
      let hw_input.s0.y.loop_extent = ((hw_input.s0.y.max + 1) - hw_input.s0.y.min)
      let hw_input.s0.x.loop_max = hw_input.s0.x.max
      let hw_input.s0.x.loop_min = hw_input.s0.x.min
      let hw_input.s0.x.loop_extent = ((hw_input.s0.x.max + 1) - hw_input.s0.x.min)
      for (hw_input.s0.y, hw_input.s0.y.loop_min, hw_input.s0.y.loop_extent) {
        for (hw_input.s0.x, hw_input.s0.x.loop_min, hw_input.s0.x.loop_extent) {
          hw_input(hw_input.s0.x, hw_input.s0.y) = uint16(input(hw_input.s0.x, hw_input.s0.y))
        }
      }
    }
    consume hw_input {
      let hw_output.y.max_realized = max(min((((((hw_output.s0.y.max - hw_output.s0.y.min)/62)*62) + hw_output.s0.y.min) + 61), hw_output.s0.y.max), output.s0.y.max)
      let hw_output.y.min_realized = min(min((hw_output.s0.y.max + -61), hw_output.s0.y.min), output.s0.y.min)
      let hw_output.y.extent_realized = ((max(min((((((hw_output.s0.y.max - hw_output.s0.y.min)/62)*62) + hw_output.s0.y.min) + 61), hw_output.s0.y.max), output.s0.y.max) - min(min((hw_output.s0.y.max + -61), hw_output.s0.y.min), output.s0.y.min)) + 1)
      let hw_output.x.max_realized = max(min((((((hw_output.s0.x.max - hw_output.s0.x.min)/62)*62) + hw_output.s0.x.min) + 61), hw_output.s0.x.max), output.s0.x.max)
      let hw_output.x.min_realized = min(min((hw_output.s0.x.max + -61), hw_output.s0.x.min), output.s0.x.min)
      let hw_output.x.extent_realized = ((max(min((((((hw_output.s0.x.max - hw_output.s0.x.min)/62)*62) + hw_output.s0.x.min) + 61), hw_output.s0.x.max), output.s0.x.max) - min(min((hw_output.s0.x.max + -61), hw_output.s0.x.min), output.s0.x.min)) + 1)
      realize hw_output([hw_output.x.min_realized, hw_output.x.extent_realized], [hw_output.y.min_realized, hw_output.y.extent_realized]) {
        produce hw_output {
          let hw_output.s0.y.loop_max = hw_output.s0.y.max
          let hw_output.s0.y.loop_min = hw_output.s0.y.min
          let hw_output.s0.y.loop_extent = ((hw_output.s0.y.max + 1) - hw_output.s0.y.min)
          let hw_output.s0.x.loop_max = hw_output.s0.x.max
          let hw_output.s0.x.loop_min = hw_output.s0.x.min
          let hw_output.s0.x.loop_extent = ((hw_output.s0.x.max + 1) - hw_output.s0.x.min)
          let hw_output.s0.x.xo.loop_extent = (((hw_output.s0.x.loop_max - hw_output.s0.x.loop_min) + 62)/62)
          let hw_output.s0.x.xo.loop_max = ((((hw_output.s0.x.loop_max - hw_output.s0.x.loop_min) + 62)/62) - 1)
          let hw_output.s0.x.xo.loop_min = 0
          let hw_output.s0.x.xi.loop_extent = 62
          let hw_output.s0.x.xi.loop_max = (62 - 1)
          let hw_output.s0.x.xi.loop_min = 0
          let hw_output.s0.y.yo.loop_extent = (((hw_output.s0.y.loop_max - hw_output.s0.y.loop_min) + 62)/62)
          let hw_output.s0.y.yo.loop_max = ((((hw_output.s0.y.loop_max - hw_output.s0.y.loop_min) + 62)/62) - 1)
          let hw_output.s0.y.yo.loop_min = 0
          let hw_output.s0.y.yi.loop_extent = 62
          let hw_output.s0.y.yi.loop_max = (62 - 1)
          let hw_output.s0.y.yi.loop_min = 0
          for (hw_output.s0.y.yo, hw_output.s0.y.yo.loop_min, hw_output.s0.y.yo.loop_extent) {
            let hw_output.s0.y.yi.base = min(likely_if_innermost(((hw_output.s0.y.yo*62) + hw_output.s0.y.loop_min)), (hw_output.s0.y.loop_max + (1 - 62)))
            for (hw_output.s0.x.xo, hw_output.s0.x.xo.loop_min, hw_output.s0.x.xo.loop_extent) {
              let hw_output.s0.x.xi.base = min(likely_if_innermost(((hw_output.s0.x.xo*62) + hw_output.s0.x.loop_min)), (hw_output.s0.x.loop_max + (1 - 62)))
              let hw_output.s0.y.min = (hw_output.s0.y.yi.base + hw_output.s0.y.yi.loop_min)
              let hw_output.s0.y.max = (hw_output.s0.y.yi.base + ((hw_output.s0.y.yi.loop_extent + hw_output.s0.y.yi.loop_min) - 1))
              let hw_output.s0.x.min = (hw_output.s0.x.xi.base + hw_output.s0.x.xi.loop_min)
              let hw_output.s0.x.max = (hw_output.s0.x.xi.base + ((hw_output.s0.x.xi.loop_extent + hw_output.s0.x.xi.loop_min) - 1))
              let conv.s1.r$y.max = ((3 + 0) - 1)
              let conv.s1.r$y.min = 0
              let conv.s1.r$x.max = ((3 + 0) - 1)
              let conv.s1.r$x.min = 0
              let conv.s1.y.max = hw_output.s0.y.max
              let conv.s1.y.min = hw_output.s0.y.min
              let conv.s1.x.max = hw_output.s0.x.max
              let conv.s1.x.min = hw_output.s0.x.min
              let conv.s0.y.max = conv.s1.y.max
              let conv.s0.y.min = conv.s1.y.min
              let conv.s0.x.max = conv.s1.x.max
              let conv.s0.x.min = conv.s1.x.min
              let kernel.s9.y.max = conv.s1.r$y.max
              let kernel.s9.y.min = conv.s1.r$y.min
              let kernel.s9.x.max = conv.s1.r$x.max
              let kernel.s9.x.min = conv.s1.r$x.min
              let kernel.s8.y.max = conv.s1.r$y.max
              let kernel.s8.y.min = conv.s1.r$y.min
              let kernel.s8.x.max = conv.s1.r$x.max
              let kernel.s8.x.min = conv.s1.r$x.min
              let kernel.s7.y.max = conv.s1.r$y.max
              let kernel.s7.y.min = conv.s1.r$y.min
              let kernel.s7.x.max = conv.s1.r$x.max
              let kernel.s7.x.min = conv.s1.r$x.min
              let kernel.s6.y.max = conv.s1.r$y.max
              let kernel.s6.y.min = conv.s1.r$y.min
              let kernel.s6.x.max = conv.s1.r$x.max
              let kernel.s6.x.min = conv.s1.r$x.min
              let kernel.s5.y.max = conv.s1.r$y.max
              let kernel.s5.y.min = conv.s1.r$y.min
              let kernel.s5.x.max = conv.s1.r$x.max
              let kernel.s5.x.min = conv.s1.r$x.min
              let kernel.s4.y.max = conv.s1.r$y.max
              let kernel.s4.y.min = conv.s1.r$y.min
              let kernel.s4.x.max = conv.s1.r$x.max
              let kernel.s4.x.min = conv.s1.r$x.min
              let kernel.s3.y.max = conv.s1.r$y.max
              let kernel.s3.y.min = conv.s1.r$y.min
              let kernel.s3.x.max = conv.s1.r$x.max
              let kernel.s3.x.min = conv.s1.r$x.min
              let kernel.s2.y.max = conv.s1.r$y.max
              let kernel.s2.y.min = conv.s1.r$y.min
              let kernel.s2.x.max = conv.s1.r$x.max
              let kernel.s2.x.min = conv.s1.r$x.min
              let kernel.s1.y.max = conv.s1.r$y.max
              let kernel.s1.y.min = conv.s1.r$y.min
              let kernel.s1.x.max = conv.s1.r$x.max
              let kernel.s1.x.min = conv.s1.r$x.min
              let kernel.s0.y.max = conv.s1.r$y.max
              let kernel.s0.y.min = conv.s1.r$y.min
              let kernel.s0.x.max = conv.s1.r$x.max
              let kernel.s0.x.min = conv.s1.r$x.min
              let kernel.y.max_realized = max(kernel.s0.y.max, 2)
              let kernel.y.min_realized = min(kernel.s0.y.min, 0)
              let kernel.y.extent_realized = ((max(kernel.s0.y.max, 2) - min(kernel.s0.y.min, 0)) + 1)
              let kernel.x.max_realized = max(kernel.s0.x.max, 2)
              let kernel.x.min_realized = min(kernel.s0.x.min, 0)
              let kernel.x.extent_realized = ((max(kernel.s0.x.max, 2) - min(kernel.s0.x.min, 0)) + 1)
              realize kernel([kernel.x.min_realized, kernel.x.extent_realized], [kernel.y.min_realized, kernel.y.extent_realized]) {
                produce kernel {
                  let kernel.s0.y.loop_max = kernel.s0.y.max
                  let kernel.s0.y.loop_min = kernel.s0.y.min
                  let kernel.s0.y.loop_extent = ((kernel.s0.y.max + 1) - kernel.s0.y.min)
                  let kernel.s0.x.loop_max = kernel.s0.x.max
                  let kernel.s0.x.loop_min = kernel.s0.x.min
                  let kernel.s0.x.loop_extent = ((kernel.s0.x.max + 1) - kernel.s0.x.min)
                  let kernel.s1.y.loop_max = kernel.s1.y.max
                  let kernel.s1.y.loop_min = kernel.s1.y.min
                  let kernel.s1.y.loop_extent = ((kernel.s1.y.max + 1) - kernel.s1.y.min)
                  let kernel.s1.x.loop_max = kernel.s1.x.max
                  let kernel.s1.x.loop_min = kernel.s1.x.min
                  let kernel.s1.x.loop_extent = ((kernel.s1.x.max + 1) - kernel.s1.x.min)
                  let kernel.s2.y.loop_max = kernel.s2.y.max
                  let kernel.s2.y.loop_min = kernel.s2.y.min
                  let kernel.s2.y.loop_extent = ((kernel.s2.y.max + 1) - kernel.s2.y.min)
                  let kernel.s2.x.loop_max = kernel.s2.x.max
                  let kernel.s2.x.loop_min = kernel.s2.x.min
                  let kernel.s2.x.loop_extent = ((kernel.s2.x.max + 1) - kernel.s2.x.min)
                  let kernel.s3.y.loop_max = kernel.s3.y.max
                  let kernel.s3.y.loop_min = kernel.s3.y.min
                  let kernel.s3.y.loop_extent = ((kernel.s3.y.max + 1) - kernel.s3.y.min)
                  let kernel.s3.x.loop_max = kernel.s3.x.max
                  let kernel.s3.x.loop_min = kernel.s3.x.min
                  let kernel.s3.x.loop_extent = ((kernel.s3.x.max + 1) - kernel.s3.x.min)
                  let kernel.s4.y.loop_max = kernel.s4.y.max
                  let kernel.s4.y.loop_min = kernel.s4.y.min
                  let kernel.s4.y.loop_extent = ((kernel.s4.y.max + 1) - kernel.s4.y.min)
                  let kernel.s4.x.loop_max = kernel.s4.x.max
                  let kernel.s4.x.loop_min = kernel.s4.x.min
                  let kernel.s4.x.loop_extent = ((kernel.s4.x.max + 1) - kernel.s4.x.min)
                  let kernel.s5.y.loop_max = kernel.s5.y.max
                  let kernel.s5.y.loop_min = kernel.s5.y.min
                  let kernel.s5.y.loop_extent = ((kernel.s5.y.max + 1) - kernel.s5.y.min)
                  let kernel.s5.x.loop_max = kernel.s5.x.max
                  let kernel.s5.x.loop_min = kernel.s5.x.min
                  let kernel.s5.x.loop_extent = ((kernel.s5.x.max + 1) - kernel.s5.x.min)
                  let kernel.s6.y.loop_max = kernel.s6.y.max
                  let kernel.s6.y.loop_min = kernel.s6.y.min
                  let kernel.s6.y.loop_extent = ((kernel.s6.y.max + 1) - kernel.s6.y.min)
                  let kernel.s6.x.loop_max = kernel.s6.x.max
                  let kernel.s6.x.loop_min = kernel.s6.x.min
                  let kernel.s6.x.loop_extent = ((kernel.s6.x.max + 1) - kernel.s6.x.min)
                  let kernel.s7.y.loop_max = kernel.s7.y.max
                  let kernel.s7.y.loop_min = kernel.s7.y.min
                  let kernel.s7.y.loop_extent = ((kernel.s7.y.max + 1) - kernel.s7.y.min)
                  let kernel.s7.x.loop_max = kernel.s7.x.max
                  let kernel.s7.x.loop_min = kernel.s7.x.min
                  let kernel.s7.x.loop_extent = ((kernel.s7.x.max + 1) - kernel.s7.x.min)
                  let kernel.s8.y.loop_max = kernel.s8.y.max
                  let kernel.s8.y.loop_min = kernel.s8.y.min
                  let kernel.s8.y.loop_extent = ((kernel.s8.y.max + 1) - kernel.s8.y.min)
                  let kernel.s8.x.loop_max = kernel.s8.x.max
                  let kernel.s8.x.loop_min = kernel.s8.x.min
                  let kernel.s8.x.loop_extent = ((kernel.s8.x.max + 1) - kernel.s8.x.min)
                  let kernel.s9.y.loop_max = kernel.s9.y.max
                  let kernel.s9.y.loop_min = kernel.s9.y.min
                  let kernel.s9.y.loop_extent = ((kernel.s9.y.max + 1) - kernel.s9.y.min)
                  let kernel.s9.x.loop_max = kernel.s9.x.max
                  let kernel.s9.x.loop_min = kernel.s9.x.min
                  let kernel.s9.x.loop_extent = ((kernel.s9.x.max + 1) - kernel.s9.x.min)
                  for (kernel.s0.y, kernel.s0.y.loop_min, kernel.s0.y.loop_extent) {
                    for (kernel.s0.x, kernel.s0.x.loop_min, kernel.s0.x.loop_extent) {
                      kernel(kernel.s0.x, kernel.s0.y) = 0
                    }
                  }
                  kernel(0, 0) = 1
                  kernel(0, 1) = 0
                  kernel(0, 2) = 0
                  kernel(1, 0) = 0
                  kernel(1, 1) = 0
                  kernel(1, 2) = 0
                  kernel(2, 0) = 0
                  kernel(2, 1) = 0
                  kernel(2, 2) = 0
                }
                consume kernel {
                  let conv.y.max_realized = (((hw_output.s0.y.yi.loop_extent + hw_output.s0.y.yi.loop_min) + hw_output.s0.y.yi.base) + -1)
                  let conv.y.min_realized = (hw_output.s0.y.yi.base + hw_output.s0.y.yi.loop_min)
                  let conv.y.extent_realized = hw_output.s0.y.yi.loop_extent
                  let conv.x.max_realized = (((hw_output.s0.x.xi.loop_extent + hw_output.s0.x.xi.loop_min) + hw_output.s0.x.xi.base) + -1)
                  let conv.x.min_realized = (hw_output.s0.x.xi.base + hw_output.s0.x.xi.loop_min)
                  let conv.x.extent_realized = hw_output.s0.x.xi.loop_extent
                  realize conv([conv.x.min_realized, conv.x.extent_realized], [conv.y.min_realized, conv.y.extent_realized]) {
                    for (hw_output.s0.y.yi, hw_output.s0.y.yi.loop_min, hw_output.s0.y.yi.loop_extent) {
                      let hw_output.s0.y = (hw_output.s0.y.yi.base + hw_output.s0.y.yi)
                      for (hw_output.s0.x.xi, hw_output.s0.x.xi.loop_min, hw_output.s0.x.xi.loop_extent) {
                        let hw_output.s0.x = (hw_output.s0.x.xi.base + hw_output.s0.x.xi)
                        let hw_output.s0.y.min = (hw_output.s0.y.yi.base + hw_output.s0.y.yi)
                        let hw_output.s0.y.max = hw_output.s0.y.min
                        let hw_output.s0.x.min = (hw_output.s0.x.xi.base + hw_output.s0.x.xi)
                        let hw_output.s0.x.max = hw_output.s0.x.min
                        let conv.s1.r$y.max = ((3 + 0) - 1)
                        let conv.s1.r$y.min = 0
                        let conv.s1.r$x.max = ((3 + 0) - 1)
                        let conv.s1.r$x.min = 0
                        let conv.s1.y.max = hw_output.s0.y.max
                        let conv.s1.y.min = hw_output.s0.y.min
                        let conv.s1.x.max = hw_output.s0.x.max
                        let conv.s1.x.min = hw_output.s0.x.min
                        let conv.s0.y.max = conv.s1.y.max
                        let conv.s0.y.min = conv.s1.y.min
                        let conv.s0.x.max = conv.s1.x.max
                        let conv.s0.x.min = conv.s1.x.min
                        produce conv {
                          let conv.s0.y.loop_max = conv.s0.y.max
                          let conv.s0.y.loop_min = conv.s0.y.min
                          let conv.s0.y.loop_extent = ((conv.s0.y.max + 1) - conv.s0.y.min)
                          let conv.s0.x.loop_max = conv.s0.x.max
                          let conv.s0.x.loop_min = conv.s0.x.min
                          let conv.s0.x.loop_extent = ((conv.s0.x.max + 1) - conv.s0.x.min)
                          let conv.s1.r$y.loop_extent = ((conv.s1.r$y.max - conv.s1.r$y.min) + 1)
                          let conv.s1.r$y.loop_max = conv.s1.r$y.max
                          let conv.s1.r$y.loop_min = conv.s1.r$y.min
                          let conv.s1.r$x.loop_extent = ((conv.s1.r$x.max - conv.s1.r$x.min) + 1)
                          let conv.s1.r$x.loop_max = conv.s1.r$x.max
                          let conv.s1.r$x.loop_min = conv.s1.r$x.min
                          let conv.s1.y.loop_max = conv.s1.y.max
                          let conv.s1.y.loop_min = conv.s1.y.min
                          let conv.s1.y.loop_extent = ((conv.s1.y.max + 1) - conv.s1.y.min)
                          let conv.s1.x.loop_max = conv.s1.x.max
                          let conv.s1.x.loop_min = conv.s1.x.min
                          let conv.s1.x.loop_extent = ((conv.s1.x.max + 1) - conv.s1.x.min)
                          let conv.s1.r$x.r$x.loop_extent = (((conv.s1.r$x.loop_max - conv.s1.r$x.loop_min) + 3)/3)
                          let conv.s1.r$x.r$x.loop_max = ((((conv.s1.r$x.loop_max - conv.s1.r$x.loop_min) + 3)/3) - 1)
                          let conv.s1.r$x.r$x.loop_min = 0
                          let conv.s1.r$x.r8.loop_extent = 3
                          let conv.s1.r$x.r8.loop_max = (3 - 1)
                          let conv.s1.r$x.r8.loop_min = 0
                          let conv.s1.r$y.r$y.loop_extent = (((conv.s1.r$y.loop_max - conv.s1.r$y.loop_min) + 3)/3)
                          let conv.s1.r$y.r$y.loop_max = ((((conv.s1.r$y.loop_max - conv.s1.r$y.loop_min) + 3)/3) - 1)
                          let conv.s1.r$y.r$y.loop_min = 0
                          let conv.s1.r$y.r9.loop_extent = 3
                          let conv.s1.r$y.r9.loop_max = (3 - 1)
                          let conv.s1.r$y.r9.loop_min = 0
                          for (conv.s0.y, conv.s0.y.loop_min, conv.s0.y.loop_extent) {
                            for (conv.s0.x, conv.s0.x.loop_min, conv.s0.x.loop_extent) {
                              conv(conv.s0.x, conv.s0.y) = 0
                            }
                          }
                          for (conv.s1.y, conv.s1.y.loop_min, conv.s1.y.loop_extent) {
                            for (conv.s1.x, conv.s1.x.loop_min, conv.s1.x.loop_extent) {
                              for (conv.s1.r$y.r$y, conv.s1.r$y.r$y.loop_min, conv.s1.r$y.r$y.loop_extent) {
                                let conv.s1.r$y.r9.base = ((conv.s1.r$y.r$y*3) + conv.s1.r$y.loop_min)
                                unrolled (conv.s1.r$y.r9, conv.s1.r$y.r9.loop_min, conv.s1.r$y.r9.loop_extent) {
                                  let conv.s1.r$y = (conv.s1.r$y.r9.base + conv.s1.r$y.r9)
                                  for (conv.s1.r$x.r$x, conv.s1.r$x.r$x.loop_min, conv.s1.r$x.r$x.loop_extent) {
                                    let conv.s1.r$x.r8.base = ((conv.s1.r$x.r$x*3) + conv.s1.r$x.loop_min)
                                    unrolled (conv.s1.r$x.r8, conv.s1.r$x.r8.loop_min, conv.s1.r$x.r8.loop_extent) {
                                      let conv.s1.r$x = (conv.s1.r$x.r8.base + conv.s1.r$x.r8)
                                      let conv.s1.r$y.max = conv.s1.r$y
                                      let conv.s1.r$y.min = conv.s1.r$y
                                      let conv.s1.r$x.max = conv.s1.r$x
                                      let conv.s1.r$x.min = conv.s1.r$x
                                      conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        consume conv {
                          hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        consume hw_output {
          assert(((0 <= output.s0.y.min_unbounded) && (((62 + 0) - 1) >= output.s0.y.max_unbounded)), halide_error_explicit_bounds_too_small("y", "output", 0, ((62 + 0) - 1), output.s0.y.min_unbounded, output.s0.y.max_unbounded))
          assert(((0 <= output.s0.x.min_unbounded) && (((62 + 0) - 1) >= output.s0.x.max_unbounded)), halide_error_explicit_bounds_too_small("x", "output", 0, ((62 + 0) - 1), output.s0.x.min_unbounded, output.s0.x.max_unbounded))
          produce output {
            let output.s0.y.loop_max = output.s0.y.max
            let output.s0.y.loop_min = output.s0.y.min
            let output.s0.y.loop_extent = ((output.s0.y.max + 1) - output.s0.y.min)
            let output.s0.x.loop_max = output.s0.x.max
            let output.s0.x.loop_min = output.s0.x.min
            let output.s0.x.loop_extent = ((output.s0.x.max + 1) - output.s0.x.min)
            for (output.s0.y, output.s0.y.loop_min, output.s0.y.loop_extent) {
              for (output.s0.x, output.s0.x.loop_min, output.s0.x.loop_extent) {
                output(output.s0.x, output.s0.y) = hw_output(output.s0.x, output.s0.y)
              }
            }
          }
        }
      }
    }
  }
}
extracting hw buffers
Found accelerate function hw_output
Found accelerate function hw_output
added loop to scan loop named hw_output.s0.y.yi with extent=62
added loop to scan loop named hw_output.s0.x.xi with extent=62
hw_output has the streaming loops: hw_output.s0.y.yi hw_output.s0.x.xi 
checking hwbuffers in realize hw_input
creating buffer for realize hw_input
xcel compute level is hw_output.s0.x.xi
func hw_input has store=.__root  compute=.__root
hw_input has compute=store level
 Doing sliding window analysis over loop: hw_input.s0.y
 Doing sliding window analysis over loop: hw_input.s0.x
searching for sliding window for hw_input using loop hw_input.s0.x
searching for sliding window for hw_input using loop hw_input.s0.y
 Doing sliding window analysis over loop: hw_output.s0.y.yo
 Doing sliding window analysis over loop: hw_output.s0.x.xo
 Doing sliding window analysis over loop: kernel.s0.y
 Doing sliding window analysis over loop: kernel.s0.x
searching for sliding window for hw_input using loop kernel.s0.x
searching for sliding window for hw_input using loop kernel.s0.y
 Doing sliding window analysis over loop: hw_output.s0.y.yi
 Doing sliding window analysis over loop: hw_output.s0.x.xi
 Doing sliding window analysis over loop: conv.s0.y
 Doing sliding window analysis over loop: conv.s0.x
searching for sliding window for hw_input using loop conv.s0.x
searching for sliding window for hw_input using loop conv.s0.y
 Doing sliding window analysis over loop: conv.s1.y
 Doing sliding window analysis over loop: conv.s1.x
 Doing sliding window analysis over loop: conv.s1.r$y.r$y
 Doing sliding window analysis over loop: conv.s1.r$y.r9
 Doing sliding window analysis over loop: conv.s1.r$x.r$x
 Doing sliding window analysis over loop: conv.s1.r$x.r8
searching for sliding window for hw_input using loop conv.s1.r$x.r8
searching for sliding window for hw_input using loop conv.s1.r$x.r$x
searching for sliding window for hw_input using loop conv.s1.r$y.r9
searching for sliding window for hw_input using loop conv.s1.r$y.r$y
searching for sliding window for hw_input using loop conv.s1.x
searching for sliding window for hw_input using loop conv.s1.y
searching for sliding window for hw_input using loop hw_output.s0.x.xi
searching for sliding window for hw_input using loop hw_output.s0.y.yi
searching for sliding window for hw_input using loop hw_output.s0.x.xo
searching for sliding window for hw_input using loop hw_output.s0.y.yo
 Doing sliding window analysis over loop: output.s0.y
 Doing sliding window analysis over loop: output.s0.x
searching for sliding window for hw_input using loop output.s0.x
searching for sliding window for hw_input using loop output.s0.y
checking hwbuffers in realize hw_output
creating buffer for realize hw_output
xcel compute level is hw_output.s0.x.xi
func hw_output has store=.__root  compute=.__root
hw_output has compute=store level
 Doing sliding window analysis over loop: hw_output.s0.y.yo
 Doing sliding window analysis over loop: hw_output.s0.x.xo
 Doing sliding window analysis over loop: kernel.s0.y
 Doing sliding window analysis over loop: kernel.s0.x
searching for sliding window for hw_output using loop kernel.s0.x
searching for sliding window for hw_output using loop kernel.s0.y
 Doing sliding window analysis over loop: hw_output.s0.y.yi
 Doing sliding window analysis over loop: hw_output.s0.x.xi
 Doing sliding window analysis over loop: conv.s0.y
 Doing sliding window analysis over loop: conv.s0.x
searching for sliding window for hw_output using loop conv.s0.x
searching for sliding window for hw_output using loop conv.s0.y
 Doing sliding window analysis over loop: conv.s1.y
 Doing sliding window analysis over loop: conv.s1.x
 Doing sliding window analysis over loop: conv.s1.r$y.r$y
 Doing sliding window analysis over loop: conv.s1.r$y.r9
 Doing sliding window analysis over loop: conv.s1.r$x.r$x
 Doing sliding window analysis over loop: conv.s1.r$x.r8
searching for sliding window for hw_output using loop conv.s1.r$x.r8
searching for sliding window for hw_output using loop conv.s1.r$x.r$x
searching for sliding window for hw_output using loop conv.s1.r$y.r9
searching for sliding window for hw_output using loop conv.s1.r$y.r$y
searching for sliding window for hw_output using loop conv.s1.x
searching for sliding window for hw_output using loop conv.s1.y
searching for sliding window for hw_output using loop hw_output.s0.x.xi
searching for sliding window for hw_output using loop hw_output.s0.y.yi
searching for sliding window for hw_output using loop hw_output.s0.x.xo
searching for sliding window for hw_output using loop hw_output.s0.y.yo
 Doing sliding window analysis over loop: output.s0.y
 Doing sliding window analysis over loop: output.s0.x
searching for sliding window for hw_output using loop output.s0.x
searching for sliding window for hw_output using loop output.s0.y
checking hwbuffers in realize kernel
creating buffer for realize kernel
xcel compute level is hw_output.s0.x.xi
func kernel has store=hw_output.xo  compute=hw_output.xo
kernel has compute=store level
 Doing sliding window analysis over loop: kernel.s0.y
 Doing sliding window analysis over loop: kernel.s0.x
searching for sliding window for kernel using loop kernel.s0.x
searching for sliding window for kernel using loop kernel.s0.y
 Doing sliding window analysis over loop: hw_output.s0.y.yi
 Doing sliding window analysis over loop: hw_output.s0.x.xi
 Doing sliding window analysis over loop: conv.s0.y
 Doing sliding window analysis over loop: conv.s0.x
searching for sliding window for kernel using loop conv.s0.x
searching for sliding window for kernel using loop conv.s0.y
 Doing sliding window analysis over loop: conv.s1.y
 Doing sliding window analysis over loop: conv.s1.x
 Doing sliding window analysis over loop: conv.s1.r$y.r$y
 Doing sliding window analysis over loop: conv.s1.r$y.r9
 Doing sliding window analysis over loop: conv.s1.r$x.r$x
 Doing sliding window analysis over loop: conv.s1.r$x.r8
searching for sliding window for kernel using loop conv.s1.r$x.r8
searching for sliding window for kernel using loop conv.s1.r$x.r$x
searching for sliding window for kernel using loop conv.s1.r$y.r9
searching for sliding window for kernel using loop conv.s1.r$y.r$y
searching for sliding window for kernel using loop conv.s1.x
searching for sliding window for kernel using loop conv.s1.y
searching for sliding window for kernel using loop hw_output.s0.x.xi
searching for sliding window for kernel using loop hw_output.s0.y.yi
checking hwbuffers in realize conv
creating buffer for realize conv
xcel compute level is hw_output.s0.x.xi
func conv has store=hw_output.xo  compute=hw_output.xi
Doing sliding window analysis on realization of conv
 Doing sliding window analysis over loop: hw_output.s0.y.yi
 Doing sliding window analysis over loop: hw_output.s0.x.xi
 Doing sliding window analysis over loop: conv.s0.y
 Doing sliding window analysis over loop: conv.s0.x
searching for sliding window for conv using loop conv.s0.x
searching for sliding window for conv using loop conv.s0.y
 Doing sliding window analysis over loop: conv.s1.y
 Doing sliding window analysis over loop: conv.s1.x
 Doing sliding window analysis over loop: conv.s1.r$y.r$y
 Doing sliding window analysis over loop: conv.s1.r$y.r9
 Doing sliding window analysis over loop: conv.s1.r$x.r$x
 Doing sliding window analysis over loop: conv.s1.r$x.r8
searching for sliding window for conv using loop conv.s1.r$x.r8
searching for sliding window for conv using loop conv.s1.r$x.r$x
searching for sliding window for conv using loop conv.s1.r$y.r9
searching for sliding window for conv using loop conv.s1.r$y.r$y
searching for sliding window for conv using loop conv.s1.x
searching for sliding window for conv using loop conv.s1.y
searching for sliding window for conv using loop hw_output.s0.x.xi
visiting pc sliding window for conv
for dim=0  var=conv.s1.x  max=0  min=0
for dim=1  var=conv.s1.y  max=0  min=0
func conv provides={[0, 0], [0, 0]} requires={[0, 0], [0, 0]}
output stencil: 1 for dim 1
input stencil: 1
Sliding conv over dimension y along loop variable hw_output.s0.x.xi
 where min=0  max=0 max_prev_plus_one=(0 + 1)

Sliding conv, y
  Pushing min up from 0 to (0 + 1)
  Shrinking max from 0 to 0
added sliding stencil called hw_output.s0.x.xi with 1more loops resulting in num_total_loops=1
searching for sliding window for conv using loop hw_output.s0.y.yi
visiting pc sliding window for conv
for dim=0  var=conv.s1.x  max=0  min=0
for dim=1  var=conv.s1.y  max=0  min=0
func conv provides={[0, 0], [0, 0]} requires={[0, 0], [0, 0]}
output stencil: 1 for dim 1
input stencil: 1
Sliding conv over dimension y along loop variable hw_output.s0.y.yi
 where min=0  max=0 max_prev_plus_one=(0 + 1)

Sliding conv, y
  Pushing min up from 0 to (0 + 1)
  Shrinking max from 0 to 0
added sliding stencil called hw_output.s0.y.yi with 1more loops resulting in num_total_loops=2
conv sliding output=[1,1] input=[1,1]
looking to find conv output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yi has stride=1 in call for conv stride_map[y]=1
hw_output.s0.x.xi has stride=1 in call for conv stride_map[x]=1
conv found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: conv output stencil size - box extent=[((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0),min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))   using ((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1)
((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0),min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))   using ((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1)
]
conv.s0.y has stride=0 in call for conv stride_map[y]=1
conv.s0.x has stride=0 in call for conv stride_map[x]=1
conv.s1.y has stride=1 in call for conv stride_map[y]=1
conv.s1.x has stride=1 in call for conv stride_map[x]=1
conv.s1.r$y.r$y has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$y.r9 has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$x.r$x has stride=0 in call for conv stride_map[r$x]=0
conv.s1.r$x.r8 has stride=0 in call for conv stride_map[r$x]=0
min pos in dim 0:assert("conv_dim0", min(hw_output.s0.x.xi.base, 0))
min pos in dim 1:assert("conv_dim1", min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))
added for loop: hw_output.s0.x.xi
added for loop: conv.s0.y
added for loop: conv.s0.x
writers inside loop conv.s0.x
Box writer found for conv with box {[conv.s0.x, conv.s0.x], [conv.s0.y, conv.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
writers inside loop conv.s0.y
Box writer found for conv with box {[0, ((1 + 0) - 1)], [conv.s0.y, conv.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
added for loop: conv.s1.y
added for loop: conv.s1.x
added for loop: conv.s1.r$y.r$y
added for loop: conv.s1.r$y.r9
added for loop: conv.s1.r$x.r$x
added for loop: conv.s1.r$x.r8
writers inside loop conv.s1.r$x.r$x
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.r$x.r$x
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    unrolled (conv.s1.r$y.r9, 0, 3) {
      assert("conv_dim0", 0)
      assert("conv_dim1", 0)
    }
  }
}

writers inside loop conv.s1.r$y.r$y
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.r$y.r$y
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

writers inside loop conv.s1.x
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.x
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

writers inside loop conv.s1.y
Box writer found for conv with box {[0, ((1 + 0) - 1)], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.y
Box reader found for conv with box {[0, ((1 + 0) - 1)], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

readers inside pc conv
Box reader found for conv with box {[(hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.x.xi.base + hw_output.s0.x.xi)], [(hw_output.s0.y.yi.base + hw_output.s0.y.yi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
writers inside loop hw_output.s0.x.xi
Box writer found for conv with box {[0, 0], [0, 0]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop hw_output.s0.x.xi
Box reader found for conv with box {[min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0), max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)], [min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0), max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)]}
HWBuffer Parameter: reader ports - box extent=[((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1):1-(undefined) ((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1):1-(undefined) ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))
    assert("conv_dim1", min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))
  }
}

HWBuffer Parameter: conv has Total box of size [62 ]
conv stride_x=1
HWBuffer has 2 dims, while 2 num box_dims
 loops are: [hw_output.s0.y.yi,hw_output.s0.x.xi]
hwbuffer conv in begin 0 here
hwbuffer conv before sliding 0 here
hwbuffer conv in dim 0 here
hwbuffer conv after input block in dim 0 here
hwbuffer conv finished dim 0 has min_pos=0
hwbuffer conv in begin 1 here
hwbuffer conv before sliding 1 here
hwbuffer conv in dim 1 here
hwbuffer conv after input block in dim 1 here
hwbuffer conv finished dim 1 has min_pos=0
Here is the hwbuffer: [0]
HWBuffer: conv
Logical Buffer: [62,62]
Input Chunk: [1,1]
Input Block: [1,1]
Output Stencil: [(undefined),(undefined)]
Output Block: [1,1]
Output Access Pattern:
 for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))
    assert("conv_dim1", min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))
  }
}

Output Min Pos:
 [0,0]
is_inline=0
is_output=0

sliding stencil map is conv.s0.x, conv.s0.y, conv.s1.r$x.r$x, conv.s1.r$x.r8, conv.s1.r$y.r$y, conv.s1.r$y.r9, conv.s1.x, conv.s1.y, hw_output.s0.x.xi, hw_output.s0.y.yi, 
kernel sliding output=[] input=[]
Box writer found for conv with box {[0, 0], [0, 0]}
Box writer found for hw_output with box {[(hw_output.s0.x.xi.base + 0), (hw_output.s0.x.xi.base + ((62 + 0) - 1))], [(hw_output.s0.y.yi.base + 0), (hw_output.s0.y.yi.base + ((62 + 0) - 1))]}
Box writer found for kernel with box {[0, 2], [0, 2]}
Box reader found for conv with box {[min(hw_output.s0.x.xi.base, 0), (max(hw_output.s0.x.xi.base, -61) + 61)], [min(hw_output.s0.y.yi.base, 0), (max(hw_output.s0.y.yi.base, -61) + 61)]}
Box reader found for hw_input with box {[(0 + (0 + 0)), (0 + (0 + 2))], [(0 + (0 + 0)), (0 + (0 + 2))]}
Box reader found for kernel with box {[(0 + 0), (0 + 2)], [(0 + 0), (0 + 2)]}
HWBuffer Parameter: Total buffer box is of size [3 3]
HWBuffer Parameter: Input Chunk box is of size [3 3]
HWBuffer Parameter: Output Stencil box is of size [3 3]
looking to find kernel output stencil where compute_level=hw_output.s0.x.xi
kernel.s0.y has stride=0 in call for kernel stride_map[y]=0
kernel.s0.x has stride=0 in call for kernel stride_map[x]=0
hw_output.s0.y.yi has stride=0 in call for kernel stride_map[y]=0
hw_output.s0.x.xi has stride=0 in call for kernel stride_map[x]=0
kernel found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: kernel output stencil size - box extent=[3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
]
conv.s0.y has stride=0 in call for kernel stride_map[y]=0
conv.s0.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.y has stride=0 in call for kernel stride_map[y]=0
conv.s1.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.r$y.r$y has stride=0 in call for kernel stride_map[r$y]=0
conv.s1.r$y.r9 has stride=1 in call for kernel stride_map[r$y]=1
conv.s1.r$x.r$x has stride=0 in call for kernel stride_map[r$x]=0
conv.s1.r$x.r8 has stride=1 in call for kernel stride_map[r$x]=1
added for loop: kernel.s0.x
writers inside loop kernel.s0.x
Box writer found for kernel with box {[kernel.s0.x, kernel.s0.x], [kernel.s0.y, kernel.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
min pos in dim 0:assert("kernel_dim0", 0)
min pos in dim 1:assert("kernel_dim1", 0)
added for loop: hw_output.s0.x.xi
added for loop: conv.s0.y
added for loop: conv.s0.x
added for loop: conv.s1.y
added for loop: conv.s1.x
added for loop: conv.s1.r$y.r$y
added for loop: conv.s1.r$y.r9
added for loop: conv.s1.r$x.r$x
added for loop: conv.s1.r$x.r8
readers inside loop conv.s1.r$x.r$x
Box reader found for kernel with box {[((conv.s1.r$x.r$x*3) + 0), ((conv.s1.r$x.r$x*3) + ((3 + 0) - 1))], [(conv.s1.r$y.r9.base + conv.s1.r$y.r9), (conv.s1.r$y.r9.base + conv.s1.r$y.r9)]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    unrolled (conv.s1.r$y.r9, 0, 3) {
      assert("kernel_dim0", 0)
      assert("kernel_dim1", conv.s1.r$y.r9)
    }
  }
}

readers inside loop conv.s1.r$y.r$y
Box reader found for kernel with box {[(0 + 0), (0 + ((3 + 0) - 1))], [((conv.s1.r$y.r$y*3) + 0), ((conv.s1.r$y.r$y*3) + ((3 + 0) - 1))]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 3:3-3 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("kernel_dim0", 0)
    assert("kernel_dim1", 0)
  }
}

readers inside loop conv.s1.x
Box reader found for kernel with box {[(0 + 0), (0 + ((3 + 0) - 1))], [(0 + 0), (0 + ((3 + 0) - 1))]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 3:3-3 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("kernel_dim0", 0)
    assert("kernel_dim1", 0)
  }
}

readers inside loop conv.s1.y
Box reader found for kernel with box {[(0 + 0), (0 + ((3 + 0) - 1))], [(0 + 0), (0 + ((3 + 0) - 1))]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 3:3-3 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("kernel_dim0", 0)
    assert("kernel_dim1", 0)
  }
}

readers inside loop hw_output.s0.x.xi
Box reader found for kernel with box {[(0 + 0), (0 + 2)], [(0 + 0), (0 + 2)]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 3:3-3 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("kernel_dim0", 0)
    assert("kernel_dim1", 0)
  }
}

output block: [3,3]
input block: [1,1]
transferring parameters
kernel stride_x=0
box dim 0 works
input dim 0 works
output dim 0 works
hwbuffer kernel in dim 0 has min_pos=(0 + 0)
box dim 1 works
input dim 1 works
output dim 1 works
hwbuffer kernel in dim 1 has min_pos=(0 + 0)
created hwbuffer
Here is the hwbuffer (store=compute): [0]
HWBuffer: kernel
Logical Buffer: [3,3]
Input Chunk: [1,1]
Input Block: [1,1]
Output Stencil: [3,3]
Output Block: [3,3]
Output Access Pattern:
 for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("kernel_dim0", 0)
    assert("kernel_dim1", 0)
  }
}

Output Min Pos:
 [(0 + 0),(0 + 0)]
is_inline=0
is_output=0

checking hwbuffers in realize conv
creating buffer for realize conv
xcel compute level is hw_output.s0.x.xi
func conv has store=hw_output.xo  compute=hw_output.xi
Doing sliding window analysis on realization of conv
 Doing sliding window analysis over loop: hw_output.s0.y.yi
 Doing sliding window analysis over loop: hw_output.s0.x.xi
 Doing sliding window analysis over loop: conv.s0.y
 Doing sliding window analysis over loop: conv.s0.x
searching for sliding window for conv using loop conv.s0.x
searching for sliding window for conv using loop conv.s0.y
 Doing sliding window analysis over loop: conv.s1.y
 Doing sliding window analysis over loop: conv.s1.x
 Doing sliding window analysis over loop: conv.s1.r$y.r$y
 Doing sliding window analysis over loop: conv.s1.r$y.r9
 Doing sliding window analysis over loop: conv.s1.r$x.r$x
 Doing sliding window analysis over loop: conv.s1.r$x.r8
searching for sliding window for conv using loop conv.s1.r$x.r8
searching for sliding window for conv using loop conv.s1.r$x.r$x
searching for sliding window for conv using loop conv.s1.r$y.r9
searching for sliding window for conv using loop conv.s1.r$y.r$y
searching for sliding window for conv using loop conv.s1.x
searching for sliding window for conv using loop conv.s1.y
searching for sliding window for conv using loop hw_output.s0.x.xi
visiting pc sliding window for conv
for dim=0  var=conv.s1.x  max=0  min=0
for dim=1  var=conv.s1.y  max=0  min=0
func conv provides={[0, 0], [0, 0]} requires={[0, 0], [0, 0]}
output stencil: 1 for dim 1
input stencil: 1
Sliding conv over dimension y along loop variable hw_output.s0.x.xi
 where min=0  max=0 max_prev_plus_one=(0 + 1)

Sliding conv, y
  Pushing min up from 0 to (0 + 1)
  Shrinking max from 0 to 0
added sliding stencil called hw_output.s0.x.xi with 1more loops resulting in num_total_loops=1
searching for sliding window for conv using loop hw_output.s0.y.yi
visiting pc sliding window for conv
for dim=0  var=conv.s1.x  max=0  min=0
for dim=1  var=conv.s1.y  max=0  min=0
func conv provides={[0, 0], [0, 0]} requires={[0, 0], [0, 0]}
output stencil: 1 for dim 1
input stencil: 1
Sliding conv over dimension y along loop variable hw_output.s0.y.yi
 where min=0  max=0 max_prev_plus_one=(0 + 1)

Sliding conv, y
  Pushing min up from 0 to (0 + 1)
  Shrinking max from 0 to 0
added sliding stencil called hw_output.s0.y.yi with 1more loops resulting in num_total_loops=2
conv sliding output=[1,1] input=[1,1]
looking to find conv output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yi has stride=1 in call for conv stride_map[y]=1
hw_output.s0.x.xi has stride=1 in call for conv stride_map[x]=1
conv found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: conv output stencil size - box extent=[((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0),min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))   using ((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1)
((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0),min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))   using ((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1)
]
conv.s0.y has stride=0 in call for conv stride_map[y]=1
conv.s0.x has stride=0 in call for conv stride_map[x]=1
conv.s1.y has stride=1 in call for conv stride_map[y]=1
conv.s1.x has stride=1 in call for conv stride_map[x]=1
conv.s1.r$y.r$y has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$y.r9 has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$x.r$x has stride=0 in call for conv stride_map[r$x]=0
conv.s1.r$x.r8 has stride=0 in call for conv stride_map[r$x]=0
min pos in dim 0:assert("conv_dim0", min(hw_output.s0.x.xi.base, 0))
min pos in dim 1:assert("conv_dim1", min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))
added for loop: hw_output.s0.x.xi
added for loop: conv.s0.y
added for loop: conv.s0.x
writers inside loop conv.s0.x
Box writer found for conv with box {[conv.s0.x, conv.s0.x], [conv.s0.y, conv.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
writers inside loop conv.s0.y
Box writer found for conv with box {[0, ((1 + 0) - 1)], [conv.s0.y, conv.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
added for loop: conv.s1.y
added for loop: conv.s1.x
added for loop: conv.s1.r$y.r$y
added for loop: conv.s1.r$y.r9
added for loop: conv.s1.r$x.r$x
added for loop: conv.s1.r$x.r8
writers inside loop conv.s1.r$x.r$x
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.r$x.r$x
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    unrolled (conv.s1.r$y.r9, 0, 3) {
      assert("conv_dim0", 0)
      assert("conv_dim1", 0)
    }
  }
}

writers inside loop conv.s1.r$y.r$y
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.r$y.r$y
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

writers inside loop conv.s1.x
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.x
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

writers inside loop conv.s1.y
Box writer found for conv with box {[0, ((1 + 0) - 1)], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.y
Box reader found for conv with box {[0, ((1 + 0) - 1)], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

readers inside pc conv
Box reader found for conv with box {[(hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.x.xi.base + hw_output.s0.x.xi)], [(hw_output.s0.y.yi.base + hw_output.s0.y.yi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
writers inside loop hw_output.s0.x.xi
Box writer found for conv with box {[0, 0], [0, 0]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop hw_output.s0.x.xi
Box reader found for conv with box {[min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0), max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)], [min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0), max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)]}
HWBuffer Parameter: reader ports - box extent=[((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1):1-(undefined) ((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1):1-(undefined) ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))
    assert("conv_dim1", min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))
  }
}

HWBuffer Parameter: conv has Total box of size [62 ]
conv stride_x=1
HWBuffer has 2 dims, while 2 num box_dims
 loops are: [hw_output.s0.y.yi,hw_output.s0.x.xi]
hwbuffer conv in begin 0 here
hwbuffer conv before sliding 0 here
hwbuffer conv in dim 0 here
hwbuffer conv after input block in dim 0 here
hwbuffer conv finished dim 0 has min_pos=0
hwbuffer conv in begin 1 here
hwbuffer conv before sliding 1 here
hwbuffer conv in dim 1 here
hwbuffer conv after input block in dim 1 here
hwbuffer conv finished dim 1 has min_pos=0
sliding stencil map is conv.s0.x, conv.s0.y, conv.s1.r$x.r$x, conv.s1.r$x.r8, conv.s1.r$y.r$y, conv.s1.r$y.r9, conv.s1.x, conv.s1.y, hw_output.s0.x.xi, hw_output.s0.y.yi, 
hw_output sliding output=[] input=[]
Box writer found for conv with box {[0, 0], [0, 0]}
Box writer found for hw_output with box {[(0 + 0), (0 + 61)], [(0 + 0), (0 + 61)]}
Box writer found for kernel with box {[0, 2], [0, 2]}
Box writer found for output with box {[0, 61], [0, 61]}
Box reader found for conv with box {[0, 61], [0, 61]}
Box reader found for hw_input with box {[(0 + (0 + 0)), (0 + (0 + 2))], [(0 + (0 + 0)), (0 + (0 + 2))]}
Box reader found for hw_output with box {[0, 61], [0, 61]}
Box reader found for kernel with box {[(0 + 0), (0 + 2)], [(0 + 0), (0 + 2)]}
HWBuffer Parameter: Total buffer box is of size [62 62]
HWBuffer Parameter: Input Chunk box is of size [62 62]
HWBuffer Parameter: Output Stencil box is of size [62 62]
looking to find hw_output output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yo has stride=0 in call for hw_output stride_map[y]=0
hw_output.s0.x.xo has stride=0 in call for hw_output stride_map[x]=0
kernel.s0.y has stride=0 in call for hw_output stride_map[y]=0
kernel.s0.x has stride=0 in call for hw_output stride_map[x]=0
hw_output.s0.y.yi has stride=0 in call for hw_output stride_map[y]=0
hw_output.s0.x.xi has stride=0 in call for hw_output stride_map[x]=0
hw_output found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: hw_output output stencil size - box extent=[]
conv.s0.y has stride=0 in call for hw_output stride_map[y]=0
conv.s0.x has stride=0 in call for hw_output stride_map[x]=0
conv.s1.y has stride=0 in call for hw_output stride_map[y]=0
conv.s1.x has stride=0 in call for hw_output stride_map[x]=0
conv.s1.r$y.r$y has stride=0 in call for hw_output stride_map[r$y]=0
conv.s1.r$y.r9 has stride=0 in call for hw_output stride_map[r$y]=0
conv.s1.r$x.r$x has stride=0 in call for hw_output stride_map[r$x]=0
conv.s1.r$x.r8 has stride=0 in call for hw_output stride_map[r$x]=0
output.s0.y has stride=1 in call for hw_output stride_map[y]=1
output.s0.x has stride=1 in call for hw_output stride_map[x]=1
added for loop: hw_output.s0.x.xo
added for loop: kernel.s0.y
added for loop: kernel.s0.x
added for loop: hw_output.s0.y.yi
added for loop: hw_output.s0.x.xi
added for loop: conv.s0.y
added for loop: conv.s0.x
added for loop: conv.s1.y
added for loop: conv.s1.x
added for loop: conv.s1.r$y.r$y
added for loop: conv.s1.r$y.r9
added for loop: conv.s1.r$x.r$x
added for loop: conv.s1.r$x.r8
writers inside pc conv
Box writer found for hw_output with box {[(hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.x.xi.base + hw_output.s0.x.xi)], [(hw_output.s0.y.yi.base + hw_output.s0.y.yi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
writers inside loop hw_output.s0.x.xi
Box writer found for hw_output with box {[(hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.x.xi.base + hw_output.s0.x.xi)], [(hw_output.s0.y.yi.base + hw_output.s0.y.yi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
min pos in dim 0:assert("hw_output_dim0", 0)
min pos in dim 1:assert("hw_output_dim1", output.s0.y)
added for loop: output.s0.x
readers inside loop output.s0.x
Box reader found for hw_output with box {[output.s0.x, output.s0.x], [output.s0.y, output.s0.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (output.s0.y, 0, 62) {
  for (output.s0.x, 0, 62) {
    assert("hw_output_dim0", output.s0.x)
    assert("hw_output_dim1", output.s0.y)
  }
}

output block: [1,1]
input block: [1,1]
transferring parameters
hw_output stride_x=1
box dim 0 works
input dim 0 works
output dim 0 works
hwbuffer hw_output in dim 0 has min_pos=0
box dim 1 works
input dim 1 works
output dim 1 works
hwbuffer hw_output in dim 1 has min_pos=0
created hwbuffer
Here is the hwbuffer (store=compute): [0]
HWBuffer: hw_output
Logical Buffer: [62,62]
Input Chunk: [1,1]
Input Block: [1,1]
Output Stencil: [1,1]
Output Block: [1,1]
Output Access Pattern:
 for (output.s0.y, 0, 62) {
  for (output.s0.x, 0, 62) {
    assert("hw_output_dim0", output.s0.x)
    assert("hw_output_dim1", output.s0.y)
  }
}

Output Min Pos:
 [0,0]
is_inline=0
is_output=0

checking hwbuffers in realize kernel
creating buffer for realize kernel
xcel compute level is hw_output.s0.x.xi
func kernel has store=hw_output.xo  compute=hw_output.xo
kernel has compute=store level
 Doing sliding window analysis over loop: kernel.s0.y
 Doing sliding window analysis over loop: kernel.s0.x
searching for sliding window for kernel using loop kernel.s0.x
searching for sliding window for kernel using loop kernel.s0.y
 Doing sliding window analysis over loop: hw_output.s0.y.yi
 Doing sliding window analysis over loop: hw_output.s0.x.xi
 Doing sliding window analysis over loop: conv.s0.y
 Doing sliding window analysis over loop: conv.s0.x
searching for sliding window for kernel using loop conv.s0.x
searching for sliding window for kernel using loop conv.s0.y
 Doing sliding window analysis over loop: conv.s1.y
 Doing sliding window analysis over loop: conv.s1.x
 Doing sliding window analysis over loop: conv.s1.r$y.r$y
 Doing sliding window analysis over loop: conv.s1.r$y.r9
 Doing sliding window analysis over loop: conv.s1.r$x.r$x
 Doing sliding window analysis over loop: conv.s1.r$x.r8
searching for sliding window for kernel using loop conv.s1.r$x.r8
searching for sliding window for kernel using loop conv.s1.r$x.r$x
searching for sliding window for kernel using loop conv.s1.r$y.r9
searching for sliding window for kernel using loop conv.s1.r$y.r$y
searching for sliding window for kernel using loop conv.s1.x
searching for sliding window for kernel using loop conv.s1.y
searching for sliding window for kernel using loop hw_output.s0.x.xi
searching for sliding window for kernel using loop hw_output.s0.y.yi
checking hwbuffers in realize conv
creating buffer for realize conv
xcel compute level is hw_output.s0.x.xi
func conv has store=hw_output.xo  compute=hw_output.xi
Doing sliding window analysis on realization of conv
 Doing sliding window analysis over loop: hw_output.s0.y.yi
 Doing sliding window analysis over loop: hw_output.s0.x.xi
 Doing sliding window analysis over loop: conv.s0.y
 Doing sliding window analysis over loop: conv.s0.x
searching for sliding window for conv using loop conv.s0.x
searching for sliding window for conv using loop conv.s0.y
 Doing sliding window analysis over loop: conv.s1.y
 Doing sliding window analysis over loop: conv.s1.x
 Doing sliding window analysis over loop: conv.s1.r$y.r$y
 Doing sliding window analysis over loop: conv.s1.r$y.r9
 Doing sliding window analysis over loop: conv.s1.r$x.r$x
 Doing sliding window analysis over loop: conv.s1.r$x.r8
searching for sliding window for conv using loop conv.s1.r$x.r8
searching for sliding window for conv using loop conv.s1.r$x.r$x
searching for sliding window for conv using loop conv.s1.r$y.r9
searching for sliding window for conv using loop conv.s1.r$y.r$y
searching for sliding window for conv using loop conv.s1.x
searching for sliding window for conv using loop conv.s1.y
searching for sliding window for conv using loop hw_output.s0.x.xi
visiting pc sliding window for conv
for dim=0  var=conv.s1.x  max=0  min=0
for dim=1  var=conv.s1.y  max=0  min=0
func conv provides={[0, 0], [0, 0]} requires={[0, 0], [0, 0]}
output stencil: 1 for dim 1
input stencil: 1
Sliding conv over dimension y along loop variable hw_output.s0.x.xi
 where min=0  max=0 max_prev_plus_one=(0 + 1)

Sliding conv, y
  Pushing min up from 0 to (0 + 1)
  Shrinking max from 0 to 0
added sliding stencil called hw_output.s0.x.xi with 1more loops resulting in num_total_loops=1
searching for sliding window for conv using loop hw_output.s0.y.yi
visiting pc sliding window for conv
for dim=0  var=conv.s1.x  max=0  min=0
for dim=1  var=conv.s1.y  max=0  min=0
func conv provides={[0, 0], [0, 0]} requires={[0, 0], [0, 0]}
output stencil: 1 for dim 1
input stencil: 1
Sliding conv over dimension y along loop variable hw_output.s0.y.yi
 where min=0  max=0 max_prev_plus_one=(0 + 1)

Sliding conv, y
  Pushing min up from 0 to (0 + 1)
  Shrinking max from 0 to 0
added sliding stencil called hw_output.s0.y.yi with 1more loops resulting in num_total_loops=2
conv sliding output=[1,1] input=[1,1]
looking to find conv output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yi has stride=1 in call for conv stride_map[y]=1
hw_output.s0.x.xi has stride=1 in call for conv stride_map[x]=1
conv found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: conv output stencil size - box extent=[((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0),min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))   using ((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1)
((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0),min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))   using ((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1)
]
conv.s0.y has stride=0 in call for conv stride_map[y]=1
conv.s0.x has stride=0 in call for conv stride_map[x]=1
conv.s1.y has stride=1 in call for conv stride_map[y]=1
conv.s1.x has stride=1 in call for conv stride_map[x]=1
conv.s1.r$y.r$y has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$y.r9 has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$x.r$x has stride=0 in call for conv stride_map[r$x]=0
conv.s1.r$x.r8 has stride=0 in call for conv stride_map[r$x]=0
min pos in dim 0:assert("conv_dim0", min(hw_output.s0.x.xi.base, 0))
min pos in dim 1:assert("conv_dim1", min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))
added for loop: hw_output.s0.x.xi
added for loop: conv.s0.y
added for loop: conv.s0.x
writers inside loop conv.s0.x
Box writer found for conv with box {[conv.s0.x, conv.s0.x], [conv.s0.y, conv.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
writers inside loop conv.s0.y
Box writer found for conv with box {[0, ((1 + 0) - 1)], [conv.s0.y, conv.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
added for loop: conv.s1.y
added for loop: conv.s1.x
added for loop: conv.s1.r$y.r$y
added for loop: conv.s1.r$y.r9
added for loop: conv.s1.r$x.r$x
added for loop: conv.s1.r$x.r8
writers inside loop conv.s1.r$x.r$x
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.r$x.r$x
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    unrolled (conv.s1.r$y.r9, 0, 3) {
      assert("conv_dim0", 0)
      assert("conv_dim1", 0)
    }
  }
}

writers inside loop conv.s1.r$y.r$y
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.r$y.r$y
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

writers inside loop conv.s1.x
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.x
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

writers inside loop conv.s1.y
Box writer found for conv with box {[0, ((1 + 0) - 1)], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.y
Box reader found for conv with box {[0, ((1 + 0) - 1)], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

readers inside pc conv
Box reader found for conv with box {[(hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.x.xi.base + hw_output.s0.x.xi)], [(hw_output.s0.y.yi.base + hw_output.s0.y.yi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
writers inside loop hw_output.s0.x.xi
Box writer found for conv with box {[0, 0], [0, 0]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop hw_output.s0.x.xi
Box reader found for conv with box {[min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0), max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)], [min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0), max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)]}
HWBuffer Parameter: reader ports - box extent=[((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1):1-(undefined) ((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1):1-(undefined) ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))
    assert("conv_dim1", min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))
  }
}

HWBuffer Parameter: conv has Total box of size [62 ]
conv stride_x=1
HWBuffer has 2 dims, while 2 num box_dims
 loops are: [hw_output.s0.y.yi,hw_output.s0.x.xi]
hwbuffer conv in begin 0 here
hwbuffer conv before sliding 0 here
hwbuffer conv in dim 0 here
hwbuffer conv after input block in dim 0 here
hwbuffer conv finished dim 0 has min_pos=0
hwbuffer conv in begin 1 here
hwbuffer conv before sliding 1 here
hwbuffer conv in dim 1 here
hwbuffer conv after input block in dim 1 here
hwbuffer conv finished dim 1 has min_pos=0
sliding stencil map is conv.s0.x, conv.s0.y, conv.s1.r$x.r$x, conv.s1.r$x.r8, conv.s1.r$y.r$y, conv.s1.r$y.r9, conv.s1.x, conv.s1.y, hw_output.s0.x.xi, hw_output.s0.y.yi, 
kernel sliding output=[] input=[]
Box writer found for conv with box {[0, 0], [0, 0]}
Box writer found for hw_output with box {[(hw_output.s0.x.xi.base + 0), (hw_output.s0.x.xi.base + ((62 + 0) - 1))], [(hw_output.s0.y.yi.base + 0), (hw_output.s0.y.yi.base + ((62 + 0) - 1))]}
Box writer found for kernel with box {[0, 2], [0, 2]}
Box reader found for conv with box {[min(hw_output.s0.x.xi.base, 0), (max(hw_output.s0.x.xi.base, -61) + 61)], [min(hw_output.s0.y.yi.base, 0), (max(hw_output.s0.y.yi.base, -61) + 61)]}
Box reader found for hw_input with box {[(0 + (0 + 0)), (0 + (0 + 2))], [(0 + (0 + 0)), (0 + (0 + 2))]}
Box reader found for kernel with box {[(0 + 0), (0 + 2)], [(0 + 0), (0 + 2)]}
HWBuffer Parameter: Total buffer box is of size [3 3]
HWBuffer Parameter: Input Chunk box is of size [3 3]
HWBuffer Parameter: Output Stencil box is of size [3 3]
looking to find kernel output stencil where compute_level=hw_output.s0.x.xi
kernel.s0.y has stride=0 in call for kernel stride_map[y]=0
kernel.s0.x has stride=0 in call for kernel stride_map[x]=0
hw_output.s0.y.yi has stride=0 in call for kernel stride_map[y]=0
hw_output.s0.x.xi has stride=0 in call for kernel stride_map[x]=0
kernel found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: kernel output stencil size - box extent=[3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
]
conv.s0.y has stride=0 in call for kernel stride_map[y]=0
conv.s0.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.y has stride=0 in call for kernel stride_map[y]=0
conv.s1.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.r$y.r$y has stride=0 in call for kernel stride_map[r$y]=0
conv.s1.r$y.r9 has stride=1 in call for kernel stride_map[r$y]=1
conv.s1.r$x.r$x has stride=0 in call for kernel stride_map[r$x]=0
conv.s1.r$x.r8 has stride=1 in call for kernel stride_map[r$x]=1
added for loop: kernel.s0.x
writers inside loop kernel.s0.x
Box writer found for kernel with box {[kernel.s0.x, kernel.s0.x], [kernel.s0.y, kernel.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
min pos in dim 0:assert("kernel_dim0", 0)
min pos in dim 1:assert("kernel_dim1", 0)
added for loop: hw_output.s0.x.xi
added for loop: conv.s0.y
added for loop: conv.s0.x
added for loop: conv.s1.y
added for loop: conv.s1.x
added for loop: conv.s1.r$y.r$y
added for loop: conv.s1.r$y.r9
added for loop: conv.s1.r$x.r$x
added for loop: conv.s1.r$x.r8
readers inside loop conv.s1.r$x.r$x
Box reader found for kernel with box {[((conv.s1.r$x.r$x*3) + 0), ((conv.s1.r$x.r$x*3) + ((3 + 0) - 1))], [(conv.s1.r$y.r9.base + conv.s1.r$y.r9), (conv.s1.r$y.r9.base + conv.s1.r$y.r9)]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    unrolled (conv.s1.r$y.r9, 0, 3) {
      assert("kernel_dim0", 0)
      assert("kernel_dim1", conv.s1.r$y.r9)
    }
  }
}

readers inside loop conv.s1.r$y.r$y
Box reader found for kernel with box {[(0 + 0), (0 + ((3 + 0) - 1))], [((conv.s1.r$y.r$y*3) + 0), ((conv.s1.r$y.r$y*3) + ((3 + 0) - 1))]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 3:3-3 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("kernel_dim0", 0)
    assert("kernel_dim1", 0)
  }
}

readers inside loop conv.s1.x
Box reader found for kernel with box {[(0 + 0), (0 + ((3 + 0) - 1))], [(0 + 0), (0 + ((3 + 0) - 1))]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 3:3-3 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("kernel_dim0", 0)
    assert("kernel_dim1", 0)
  }
}

readers inside loop conv.s1.y
Box reader found for kernel with box {[(0 + 0), (0 + ((3 + 0) - 1))], [(0 + 0), (0 + ((3 + 0) - 1))]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 3:3-3 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("kernel_dim0", 0)
    assert("kernel_dim1", 0)
  }
}

readers inside loop hw_output.s0.x.xi
Box reader found for kernel with box {[(0 + 0), (0 + 2)], [(0 + 0), (0 + 2)]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 3:3-3 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("kernel_dim0", 0)
    assert("kernel_dim1", 0)
  }
}

output block: [3,3]
input block: [1,1]
transferring parameters
kernel stride_x=0
box dim 0 works
input dim 0 works
output dim 0 works
hwbuffer kernel in dim 0 has min_pos=(0 + 0)
box dim 1 works
input dim 1 works
output dim 1 works
hwbuffer kernel in dim 1 has min_pos=(0 + 0)
created hwbuffer
checking hwbuffers in realize conv
creating buffer for realize conv
xcel compute level is hw_output.s0.x.xi
func conv has store=hw_output.xo  compute=hw_output.xi
Doing sliding window analysis on realization of conv
 Doing sliding window analysis over loop: hw_output.s0.y.yi
 Doing sliding window analysis over loop: hw_output.s0.x.xi
 Doing sliding window analysis over loop: conv.s0.y
 Doing sliding window analysis over loop: conv.s0.x
searching for sliding window for conv using loop conv.s0.x
searching for sliding window for conv using loop conv.s0.y
 Doing sliding window analysis over loop: conv.s1.y
 Doing sliding window analysis over loop: conv.s1.x
 Doing sliding window analysis over loop: conv.s1.r$y.r$y
 Doing sliding window analysis over loop: conv.s1.r$y.r9
 Doing sliding window analysis over loop: conv.s1.r$x.r$x
 Doing sliding window analysis over loop: conv.s1.r$x.r8
searching for sliding window for conv using loop conv.s1.r$x.r8
searching for sliding window for conv using loop conv.s1.r$x.r$x
searching for sliding window for conv using loop conv.s1.r$y.r9
searching for sliding window for conv using loop conv.s1.r$y.r$y
searching for sliding window for conv using loop conv.s1.x
searching for sliding window for conv using loop conv.s1.y
searching for sliding window for conv using loop hw_output.s0.x.xi
visiting pc sliding window for conv
for dim=0  var=conv.s1.x  max=0  min=0
for dim=1  var=conv.s1.y  max=0  min=0
func conv provides={[0, 0], [0, 0]} requires={[0, 0], [0, 0]}
output stencil: 1 for dim 1
input stencil: 1
Sliding conv over dimension y along loop variable hw_output.s0.x.xi
 where min=0  max=0 max_prev_plus_one=(0 + 1)

Sliding conv, y
  Pushing min up from 0 to (0 + 1)
  Shrinking max from 0 to 0
added sliding stencil called hw_output.s0.x.xi with 1more loops resulting in num_total_loops=1
searching for sliding window for conv using loop hw_output.s0.y.yi
visiting pc sliding window for conv
for dim=0  var=conv.s1.x  max=0  min=0
for dim=1  var=conv.s1.y  max=0  min=0
func conv provides={[0, 0], [0, 0]} requires={[0, 0], [0, 0]}
output stencil: 1 for dim 1
input stencil: 1
Sliding conv over dimension y along loop variable hw_output.s0.y.yi
 where min=0  max=0 max_prev_plus_one=(0 + 1)

Sliding conv, y
  Pushing min up from 0 to (0 + 1)
  Shrinking max from 0 to 0
added sliding stencil called hw_output.s0.y.yi with 1more loops resulting in num_total_loops=2
conv sliding output=[1,1] input=[1,1]
looking to find conv output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yi has stride=1 in call for conv stride_map[y]=1
hw_output.s0.x.xi has stride=1 in call for conv stride_map[x]=1
conv found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: conv output stencil size - box extent=[((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0),min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))   using ((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1)
((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0),min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))   using ((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1)
]
conv.s0.y has stride=0 in call for conv stride_map[y]=1
conv.s0.x has stride=0 in call for conv stride_map[x]=1
conv.s1.y has stride=1 in call for conv stride_map[y]=1
conv.s1.x has stride=1 in call for conv stride_map[x]=1
conv.s1.r$y.r$y has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$y.r9 has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$x.r$x has stride=0 in call for conv stride_map[r$x]=0
conv.s1.r$x.r8 has stride=0 in call for conv stride_map[r$x]=0
min pos in dim 0:assert("conv_dim0", min(hw_output.s0.x.xi.base, 0))
min pos in dim 1:assert("conv_dim1", min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))
added for loop: hw_output.s0.x.xi
added for loop: conv.s0.y
added for loop: conv.s0.x
writers inside loop conv.s0.x
Box writer found for conv with box {[conv.s0.x, conv.s0.x], [conv.s0.y, conv.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
writers inside loop conv.s0.y
Box writer found for conv with box {[0, ((1 + 0) - 1)], [conv.s0.y, conv.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
added for loop: conv.s1.y
added for loop: conv.s1.x
added for loop: conv.s1.r$y.r$y
added for loop: conv.s1.r$y.r9
added for loop: conv.s1.r$x.r$x
added for loop: conv.s1.r$x.r8
writers inside loop conv.s1.r$x.r$x
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.r$x.r$x
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    unrolled (conv.s1.r$y.r9, 0, 3) {
      assert("conv_dim0", 0)
      assert("conv_dim1", 0)
    }
  }
}

writers inside loop conv.s1.r$y.r$y
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.r$y.r$y
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

writers inside loop conv.s1.x
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.x
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

writers inside loop conv.s1.y
Box writer found for conv with box {[0, ((1 + 0) - 1)], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.y
Box reader found for conv with box {[0, ((1 + 0) - 1)], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

readers inside pc conv
Box reader found for conv with box {[(hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.x.xi.base + hw_output.s0.x.xi)], [(hw_output.s0.y.yi.base + hw_output.s0.y.yi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
writers inside loop hw_output.s0.x.xi
Box writer found for conv with box {[0, 0], [0, 0]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop hw_output.s0.x.xi
Box reader found for conv with box {[min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0), max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)], [min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0), max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)]}
HWBuffer Parameter: reader ports - box extent=[((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1):1-(undefined) ((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1):1-(undefined) ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))
    assert("conv_dim1", min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))
  }
}

HWBuffer Parameter: conv has Total box of size [62 ]
conv stride_x=1
HWBuffer has 2 dims, while 2 num box_dims
 loops are: [hw_output.s0.y.yi,hw_output.s0.x.xi]
hwbuffer conv in begin 0 here
hwbuffer conv before sliding 0 here
hwbuffer conv in dim 0 here
hwbuffer conv after input block in dim 0 here
hwbuffer conv finished dim 0 has min_pos=0
hwbuffer conv in begin 1 here
hwbuffer conv before sliding 1 here
hwbuffer conv in dim 1 here
hwbuffer conv after input block in dim 1 here
hwbuffer conv finished dim 1 has min_pos=0
sliding stencil map is conv.s0.x, conv.s0.y, conv.s1.r$x.r$x, conv.s1.r$x.r8, conv.s1.r$y.r$y, conv.s1.r$y.r9, conv.s1.x, conv.s1.y, hw_output.s0.x.xi, hw_output.s0.y.yi, 
hw_input sliding output=[] input=[]
Box writer found for conv with box {[0, 0], [0, 0]}
Box writer found for hw_input with box {[0, 63], [0, 63]}
Box writer found for hw_output with box {[(0 + 0), (0 + 61)], [(0 + 0), (0 + 61)]}
Box writer found for kernel with box {[0, 2], [0, 2]}
Box writer found for output with box {[0, 61], [0, 61]}
Box reader found for conv with box {[0, 61], [0, 61]}
Box reader found for hw_input with box {[(0 + (0 + 0)), (0 + (0 + 2))], [(0 + (0 + 0)), (0 + (0 + 2))]}
Box reader found for hw_output with box {[0, 61], [0, 61]}
Box reader found for input with box {[0, 63], [0, 63]}
Box reader found for kernel with box {[(0 + 0), (0 + 2)], [(0 + 0), (0 + 2)]}
HWBuffer Parameter: Total buffer box is of size [64 64]
HWBuffer Parameter: Input Chunk box is of size [64 64]
HWBuffer Parameter: Output Stencil box is of size [64 64]
looking to find hw_input output stencil where compute_level=hw_output.s0.x.xi
hw_input.s0.y has stride=0 in call for hw_input stride_map[y]=0
hw_input.s0.x has stride=0 in call for hw_input stride_map[x]=0
hw_output.s0.y.yo has stride=0 in call for hw_input stride_map[y]=0
hw_output.s0.x.xo has stride=0 in call for hw_input stride_map[x]=0
kernel.s0.y has stride=0 in call for hw_input stride_map[y]=0
kernel.s0.x has stride=0 in call for hw_input stride_map[x]=0
hw_output.s0.y.yi has stride=0 in call for hw_input stride_map[y]=0
hw_output.s0.x.xi has stride=0 in call for hw_input stride_map[x]=0
hw_input found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: hw_input output stencil size - box extent=[3?1:3-3 ((0 + (0 + 0)),(0 + (0 + 0)))   using (((0 + (0 + 2)) - (0 + (0 + 0))) + 1)
3?1:3-3 ((0 + (0 + 0)),(0 + (0 + 0)))   using (((0 + (0 + 2)) - (0 + (0 + 0))) + 1)
]
conv.s0.y has stride=0 in call for hw_input stride_map[y]=0
conv.s0.x has stride=0 in call for hw_input stride_map[x]=0
conv.s1.y has stride=1 in call for hw_input stride_map[y]=1
conv.s1.x has stride=1 in call for hw_input stride_map[x]=1
conv.s1.r$y.r$y has stride=0 in call for hw_input stride_map[r$y]=0
conv.s1.r$y.r9 has stride=1 in call for hw_input stride_map[r$y]=1
conv.s1.r$x.r$x has stride=0 in call for hw_input stride_map[r$x]=0
conv.s1.r$x.r8 has stride=1 in call for hw_input stride_map[r$x]=1
output.s0.y has stride=0 in call for hw_input stride_map[y]=1
output.s0.x has stride=0 in call for hw_input stride_map[x]=1
added for loop: hw_input.s0.x
writers inside loop hw_input.s0.x
Box writer found for hw_input with box {[hw_input.s0.x, hw_input.s0.x], [hw_input.s0.y, hw_input.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
min pos in dim 0:assert("hw_input_dim0", 0)
min pos in dim 1:assert("hw_input_dim1", 0)
added for loop: hw_output.s0.x.xo
added for loop: kernel.s0.y
added for loop: kernel.s0.x
added for loop: hw_output.s0.y.yi
added for loop: hw_output.s0.x.xi
added for loop: conv.s0.y
added for loop: conv.s0.x
added for loop: conv.s1.y
added for loop: conv.s1.x
added for loop: conv.s1.r$y.r$y
added for loop: conv.s1.r$y.r9
added for loop: conv.s1.r$x.r$x
added for loop: conv.s1.r$x.r8
readers inside loop conv.s1.r$x.r$x
Box reader found for hw_input with box {[(conv.s1.x + ((conv.s1.r$x.r$x*3) + 0)), (conv.s1.x + ((conv.s1.r$x.r$x*3) + ((3 + 0) - 1)))], [(conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    unrolled (conv.s1.r$y.r9, 0, 3) {
      assert("hw_input_dim0", 0)
      assert("hw_input_dim1", conv.s1.r$y.r9)
    }
  }
}

readers inside loop conv.s1.r$y.r$y
Box reader found for hw_input with box {[(conv.s1.x + (0 + 0)), (conv.s1.x + (0 + ((3 + 0) - 1)))], [(conv.s1.y + ((conv.s1.r$y.r$y*3) + 0)), (conv.s1.y + ((conv.s1.r$y.r$y*3) + ((3 + 0) - 1)))]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 3:3-3 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("hw_input_dim0", 0)
    assert("hw_input_dim1", 0)
  }
}

readers inside loop conv.s1.x
Box reader found for hw_input with box {[(conv.s1.x + (0 + 0)), (conv.s1.x + (0 + ((3 + 0) - 1)))], [(conv.s1.y + (0 + 0)), (conv.s1.y + (0 + ((3 + 0) - 1)))]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 3:3-3 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("hw_input_dim0", 0)
    assert("hw_input_dim1", 0)
  }
}

readers inside loop conv.s1.y
Box reader found for hw_input with box {[(0 + (0 + 0)), (((1 + 0) - 1) + (0 + ((3 + 0) - 1)))], [(conv.s1.y + (0 + 0)), (conv.s1.y + (0 + ((3 + 0) - 1)))]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 3:3-3 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("hw_input_dim0", 0)
    assert("hw_input_dim1", 0)
  }
}

readers inside loop hw_output.s0.x.xi
Box reader found for hw_input with box {[(0 + (0 + 0)), (0 + (0 + 2))], [(0 + (0 + 0)), (0 + (0 + 2))]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 3:3-3 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("hw_input_dim0", 0)
    assert("hw_input_dim1", 0)
  }
}

added for loop: output.s0.x
output block: [3,3]
input block: [1,1]
transferring parameters
hw_input stride_x=1
box dim 0 works
input dim 0 works
output dim 0 works
hwbuffer hw_input in dim 0 has min_pos=(0 + (0 + 0))
box dim 1 works
input dim 1 works
output dim 1 works
hwbuffer hw_input in dim 1 has min_pos=(0 + (0 + 0))
created hwbuffer
Here is the hwbuffer (store=compute): [0]
HWBuffer: hw_input
Logical Buffer: [64,64]
Input Chunk: [1,1]
Input Block: [1,1]
Output Stencil: [3,3]
Output Block: [3,3]
Output Access Pattern:
 for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("hw_input_dim0", 0)
    assert("hw_input_dim1", 0)
  }
}

Output Min Pos:
 [(0 + (0 + 0)),(0 + (0 + 0))]
is_inline=0
is_output=0

checking hwbuffers in realize hw_output
creating buffer for realize hw_output
xcel compute level is hw_output.s0.x.xi
func hw_output has store=.__root  compute=.__root
hw_output has compute=store level
 Doing sliding window analysis over loop: hw_output.s0.y.yo
 Doing sliding window analysis over loop: hw_output.s0.x.xo
 Doing sliding window analysis over loop: kernel.s0.y
 Doing sliding window analysis over loop: kernel.s0.x
searching for sliding window for hw_output using loop kernel.s0.x
searching for sliding window for hw_output using loop kernel.s0.y
 Doing sliding window analysis over loop: hw_output.s0.y.yi
 Doing sliding window analysis over loop: hw_output.s0.x.xi
 Doing sliding window analysis over loop: conv.s0.y
 Doing sliding window analysis over loop: conv.s0.x
searching for sliding window for hw_output using loop conv.s0.x
searching for sliding window for hw_output using loop conv.s0.y
 Doing sliding window analysis over loop: conv.s1.y
 Doing sliding window analysis over loop: conv.s1.x
 Doing sliding window analysis over loop: conv.s1.r$y.r$y
 Doing sliding window analysis over loop: conv.s1.r$y.r9
 Doing sliding window analysis over loop: conv.s1.r$x.r$x
 Doing sliding window analysis over loop: conv.s1.r$x.r8
searching for sliding window for hw_output using loop conv.s1.r$x.r8
searching for sliding window for hw_output using loop conv.s1.r$x.r$x
searching for sliding window for hw_output using loop conv.s1.r$y.r9
searching for sliding window for hw_output using loop conv.s1.r$y.r$y
searching for sliding window for hw_output using loop conv.s1.x
searching for sliding window for hw_output using loop conv.s1.y
searching for sliding window for hw_output using loop hw_output.s0.x.xi
searching for sliding window for hw_output using loop hw_output.s0.y.yi
searching for sliding window for hw_output using loop hw_output.s0.x.xo
searching for sliding window for hw_output using loop hw_output.s0.y.yo
 Doing sliding window analysis over loop: output.s0.y
 Doing sliding window analysis over loop: output.s0.x
searching for sliding window for hw_output using loop output.s0.x
searching for sliding window for hw_output using loop output.s0.y
checking hwbuffers in realize kernel
creating buffer for realize kernel
xcel compute level is hw_output.s0.x.xi
func kernel has store=hw_output.xo  compute=hw_output.xo
kernel has compute=store level
 Doing sliding window analysis over loop: kernel.s0.y
 Doing sliding window analysis over loop: kernel.s0.x
searching for sliding window for kernel using loop kernel.s0.x
searching for sliding window for kernel using loop kernel.s0.y
 Doing sliding window analysis over loop: hw_output.s0.y.yi
 Doing sliding window analysis over loop: hw_output.s0.x.xi
 Doing sliding window analysis over loop: conv.s0.y
 Doing sliding window analysis over loop: conv.s0.x
searching for sliding window for kernel using loop conv.s0.x
searching for sliding window for kernel using loop conv.s0.y
 Doing sliding window analysis over loop: conv.s1.y
 Doing sliding window analysis over loop: conv.s1.x
 Doing sliding window analysis over loop: conv.s1.r$y.r$y
 Doing sliding window analysis over loop: conv.s1.r$y.r9
 Doing sliding window analysis over loop: conv.s1.r$x.r$x
 Doing sliding window analysis over loop: conv.s1.r$x.r8
searching for sliding window for kernel using loop conv.s1.r$x.r8
searching for sliding window for kernel using loop conv.s1.r$x.r$x
searching for sliding window for kernel using loop conv.s1.r$y.r9
searching for sliding window for kernel using loop conv.s1.r$y.r$y
searching for sliding window for kernel using loop conv.s1.x
searching for sliding window for kernel using loop conv.s1.y
searching for sliding window for kernel using loop hw_output.s0.x.xi
searching for sliding window for kernel using loop hw_output.s0.y.yi
checking hwbuffers in realize conv
creating buffer for realize conv
xcel compute level is hw_output.s0.x.xi
func conv has store=hw_output.xo  compute=hw_output.xi
Doing sliding window analysis on realization of conv
 Doing sliding window analysis over loop: hw_output.s0.y.yi
 Doing sliding window analysis over loop: hw_output.s0.x.xi
 Doing sliding window analysis over loop: conv.s0.y
 Doing sliding window analysis over loop: conv.s0.x
searching for sliding window for conv using loop conv.s0.x
searching for sliding window for conv using loop conv.s0.y
 Doing sliding window analysis over loop: conv.s1.y
 Doing sliding window analysis over loop: conv.s1.x
 Doing sliding window analysis over loop: conv.s1.r$y.r$y
 Doing sliding window analysis over loop: conv.s1.r$y.r9
 Doing sliding window analysis over loop: conv.s1.r$x.r$x
 Doing sliding window analysis over loop: conv.s1.r$x.r8
searching for sliding window for conv using loop conv.s1.r$x.r8
searching for sliding window for conv using loop conv.s1.r$x.r$x
searching for sliding window for conv using loop conv.s1.r$y.r9
searching for sliding window for conv using loop conv.s1.r$y.r$y
searching for sliding window for conv using loop conv.s1.x
searching for sliding window for conv using loop conv.s1.y
searching for sliding window for conv using loop hw_output.s0.x.xi
visiting pc sliding window for conv
for dim=0  var=conv.s1.x  max=0  min=0
for dim=1  var=conv.s1.y  max=0  min=0
func conv provides={[0, 0], [0, 0]} requires={[0, 0], [0, 0]}
output stencil: 1 for dim 1
input stencil: 1
Sliding conv over dimension y along loop variable hw_output.s0.x.xi
 where min=0  max=0 max_prev_plus_one=(0 + 1)

Sliding conv, y
  Pushing min up from 0 to (0 + 1)
  Shrinking max from 0 to 0
added sliding stencil called hw_output.s0.x.xi with 1more loops resulting in num_total_loops=1
searching for sliding window for conv using loop hw_output.s0.y.yi
visiting pc sliding window for conv
for dim=0  var=conv.s1.x  max=0  min=0
for dim=1  var=conv.s1.y  max=0  min=0
func conv provides={[0, 0], [0, 0]} requires={[0, 0], [0, 0]}
output stencil: 1 for dim 1
input stencil: 1
Sliding conv over dimension y along loop variable hw_output.s0.y.yi
 where min=0  max=0 max_prev_plus_one=(0 + 1)

Sliding conv, y
  Pushing min up from 0 to (0 + 1)
  Shrinking max from 0 to 0
added sliding stencil called hw_output.s0.y.yi with 1more loops resulting in num_total_loops=2
conv sliding output=[1,1] input=[1,1]
looking to find conv output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yi has stride=1 in call for conv stride_map[y]=1
hw_output.s0.x.xi has stride=1 in call for conv stride_map[x]=1
conv found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: conv output stencil size - box extent=[((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0),min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))   using ((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1)
((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0),min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))   using ((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1)
]
conv.s0.y has stride=0 in call for conv stride_map[y]=1
conv.s0.x has stride=0 in call for conv stride_map[x]=1
conv.s1.y has stride=1 in call for conv stride_map[y]=1
conv.s1.x has stride=1 in call for conv stride_map[x]=1
conv.s1.r$y.r$y has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$y.r9 has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$x.r$x has stride=0 in call for conv stride_map[r$x]=0
conv.s1.r$x.r8 has stride=0 in call for conv stride_map[r$x]=0
min pos in dim 0:assert("conv_dim0", min(hw_output.s0.x.xi.base, 0))
min pos in dim 1:assert("conv_dim1", min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))
added for loop: hw_output.s0.x.xi
added for loop: conv.s0.y
added for loop: conv.s0.x
writers inside loop conv.s0.x
Box writer found for conv with box {[conv.s0.x, conv.s0.x], [conv.s0.y, conv.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
writers inside loop conv.s0.y
Box writer found for conv with box {[0, ((1 + 0) - 1)], [conv.s0.y, conv.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
added for loop: conv.s1.y
added for loop: conv.s1.x
added for loop: conv.s1.r$y.r$y
added for loop: conv.s1.r$y.r9
added for loop: conv.s1.r$x.r$x
added for loop: conv.s1.r$x.r8
writers inside loop conv.s1.r$x.r$x
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.r$x.r$x
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    unrolled (conv.s1.r$y.r9, 0, 3) {
      assert("conv_dim0", 0)
      assert("conv_dim1", 0)
    }
  }
}

writers inside loop conv.s1.r$y.r$y
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.r$y.r$y
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

writers inside loop conv.s1.x
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.x
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

writers inside loop conv.s1.y
Box writer found for conv with box {[0, ((1 + 0) - 1)], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.y
Box reader found for conv with box {[0, ((1 + 0) - 1)], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

readers inside pc conv
Box reader found for conv with box {[(hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.x.xi.base + hw_output.s0.x.xi)], [(hw_output.s0.y.yi.base + hw_output.s0.y.yi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
writers inside loop hw_output.s0.x.xi
Box writer found for conv with box {[0, 0], [0, 0]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop hw_output.s0.x.xi
Box reader found for conv with box {[min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0), max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)], [min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0), max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)]}
HWBuffer Parameter: reader ports - box extent=[((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1):1-(undefined) ((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1):1-(undefined) ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))
    assert("conv_dim1", min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))
  }
}

HWBuffer Parameter: conv has Total box of size [62 ]
conv stride_x=1
HWBuffer has 2 dims, while 2 num box_dims
 loops are: [hw_output.s0.y.yi,hw_output.s0.x.xi]
hwbuffer conv in begin 0 here
hwbuffer conv before sliding 0 here
hwbuffer conv in dim 0 here
hwbuffer conv after input block in dim 0 here
hwbuffer conv finished dim 0 has min_pos=0
hwbuffer conv in begin 1 here
hwbuffer conv before sliding 1 here
hwbuffer conv in dim 1 here
hwbuffer conv after input block in dim 1 here
hwbuffer conv finished dim 1 has min_pos=0
sliding stencil map is conv.s0.x, conv.s0.y, conv.s1.r$x.r$x, conv.s1.r$x.r8, conv.s1.r$y.r$y, conv.s1.r$y.r9, conv.s1.x, conv.s1.y, hw_output.s0.x.xi, hw_output.s0.y.yi, 
kernel sliding output=[] input=[]
Box writer found for conv with box {[0, 0], [0, 0]}
Box writer found for hw_output with box {[(hw_output.s0.x.xi.base + 0), (hw_output.s0.x.xi.base + ((62 + 0) - 1))], [(hw_output.s0.y.yi.base + 0), (hw_output.s0.y.yi.base + ((62 + 0) - 1))]}
Box writer found for kernel with box {[0, 2], [0, 2]}
Box reader found for conv with box {[min(hw_output.s0.x.xi.base, 0), (max(hw_output.s0.x.xi.base, -61) + 61)], [min(hw_output.s0.y.yi.base, 0), (max(hw_output.s0.y.yi.base, -61) + 61)]}
Box reader found for hw_input with box {[(0 + (0 + 0)), (0 + (0 + 2))], [(0 + (0 + 0)), (0 + (0 + 2))]}
Box reader found for kernel with box {[(0 + 0), (0 + 2)], [(0 + 0), (0 + 2)]}
HWBuffer Parameter: Total buffer box is of size [3 3]
HWBuffer Parameter: Input Chunk box is of size [3 3]
HWBuffer Parameter: Output Stencil box is of size [3 3]
looking to find kernel output stencil where compute_level=hw_output.s0.x.xi
kernel.s0.y has stride=0 in call for kernel stride_map[y]=0
kernel.s0.x has stride=0 in call for kernel stride_map[x]=0
hw_output.s0.y.yi has stride=0 in call for kernel stride_map[y]=0
hw_output.s0.x.xi has stride=0 in call for kernel stride_map[x]=0
kernel found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: kernel output stencil size - box extent=[3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
]
conv.s0.y has stride=0 in call for kernel stride_map[y]=0
conv.s0.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.y has stride=0 in call for kernel stride_map[y]=0
conv.s1.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.r$y.r$y has stride=0 in call for kernel stride_map[r$y]=0
conv.s1.r$y.r9 has stride=1 in call for kernel stride_map[r$y]=1
conv.s1.r$x.r$x has stride=0 in call for kernel stride_map[r$x]=0
conv.s1.r$x.r8 has stride=1 in call for kernel stride_map[r$x]=1
added for loop: kernel.s0.x
writers inside loop kernel.s0.x
Box writer found for kernel with box {[kernel.s0.x, kernel.s0.x], [kernel.s0.y, kernel.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
min pos in dim 0:assert("kernel_dim0", 0)
min pos in dim 1:assert("kernel_dim1", 0)
added for loop: hw_output.s0.x.xi
added for loop: conv.s0.y
added for loop: conv.s0.x
added for loop: conv.s1.y
added for loop: conv.s1.x
added for loop: conv.s1.r$y.r$y
added for loop: conv.s1.r$y.r9
added for loop: conv.s1.r$x.r$x
added for loop: conv.s1.r$x.r8
readers inside loop conv.s1.r$x.r$x
Box reader found for kernel with box {[((conv.s1.r$x.r$x*3) + 0), ((conv.s1.r$x.r$x*3) + ((3 + 0) - 1))], [(conv.s1.r$y.r9.base + conv.s1.r$y.r9), (conv.s1.r$y.r9.base + conv.s1.r$y.r9)]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    unrolled (conv.s1.r$y.r9, 0, 3) {
      assert("kernel_dim0", 0)
      assert("kernel_dim1", conv.s1.r$y.r9)
    }
  }
}

readers inside loop conv.s1.r$y.r$y
Box reader found for kernel with box {[(0 + 0), (0 + ((3 + 0) - 1))], [((conv.s1.r$y.r$y*3) + 0), ((conv.s1.r$y.r$y*3) + ((3 + 0) - 1))]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 3:3-3 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("kernel_dim0", 0)
    assert("kernel_dim1", 0)
  }
}

readers inside loop conv.s1.x
Box reader found for kernel with box {[(0 + 0), (0 + ((3 + 0) - 1))], [(0 + 0), (0 + ((3 + 0) - 1))]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 3:3-3 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("kernel_dim0", 0)
    assert("kernel_dim1", 0)
  }
}

readers inside loop conv.s1.y
Box reader found for kernel with box {[(0 + 0), (0 + ((3 + 0) - 1))], [(0 + 0), (0 + ((3 + 0) - 1))]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 3:3-3 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("kernel_dim0", 0)
    assert("kernel_dim1", 0)
  }
}

readers inside loop hw_output.s0.x.xi
Box reader found for kernel with box {[(0 + 0), (0 + 2)], [(0 + 0), (0 + 2)]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 3:3-3 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("kernel_dim0", 0)
    assert("kernel_dim1", 0)
  }
}

output block: [3,3]
input block: [1,1]
transferring parameters
kernel stride_x=0
box dim 0 works
input dim 0 works
output dim 0 works
hwbuffer kernel in dim 0 has min_pos=(0 + 0)
box dim 1 works
input dim 1 works
output dim 1 works
hwbuffer kernel in dim 1 has min_pos=(0 + 0)
created hwbuffer
checking hwbuffers in realize conv
creating buffer for realize conv
xcel compute level is hw_output.s0.x.xi
func conv has store=hw_output.xo  compute=hw_output.xi
Doing sliding window analysis on realization of conv
 Doing sliding window analysis over loop: hw_output.s0.y.yi
 Doing sliding window analysis over loop: hw_output.s0.x.xi
 Doing sliding window analysis over loop: conv.s0.y
 Doing sliding window analysis over loop: conv.s0.x
searching for sliding window for conv using loop conv.s0.x
searching for sliding window for conv using loop conv.s0.y
 Doing sliding window analysis over loop: conv.s1.y
 Doing sliding window analysis over loop: conv.s1.x
 Doing sliding window analysis over loop: conv.s1.r$y.r$y
 Doing sliding window analysis over loop: conv.s1.r$y.r9
 Doing sliding window analysis over loop: conv.s1.r$x.r$x
 Doing sliding window analysis over loop: conv.s1.r$x.r8
searching for sliding window for conv using loop conv.s1.r$x.r8
searching for sliding window for conv using loop conv.s1.r$x.r$x
searching for sliding window for conv using loop conv.s1.r$y.r9
searching for sliding window for conv using loop conv.s1.r$y.r$y
searching for sliding window for conv using loop conv.s1.x
searching for sliding window for conv using loop conv.s1.y
searching for sliding window for conv using loop hw_output.s0.x.xi
visiting pc sliding window for conv
for dim=0  var=conv.s1.x  max=0  min=0
for dim=1  var=conv.s1.y  max=0  min=0
func conv provides={[0, 0], [0, 0]} requires={[0, 0], [0, 0]}
output stencil: 1 for dim 1
input stencil: 1
Sliding conv over dimension y along loop variable hw_output.s0.x.xi
 where min=0  max=0 max_prev_plus_one=(0 + 1)

Sliding conv, y
  Pushing min up from 0 to (0 + 1)
  Shrinking max from 0 to 0
added sliding stencil called hw_output.s0.x.xi with 1more loops resulting in num_total_loops=1
searching for sliding window for conv using loop hw_output.s0.y.yi
visiting pc sliding window for conv
for dim=0  var=conv.s1.x  max=0  min=0
for dim=1  var=conv.s1.y  max=0  min=0
func conv provides={[0, 0], [0, 0]} requires={[0, 0], [0, 0]}
output stencil: 1 for dim 1
input stencil: 1
Sliding conv over dimension y along loop variable hw_output.s0.y.yi
 where min=0  max=0 max_prev_plus_one=(0 + 1)

Sliding conv, y
  Pushing min up from 0 to (0 + 1)
  Shrinking max from 0 to 0
added sliding stencil called hw_output.s0.y.yi with 1more loops resulting in num_total_loops=2
conv sliding output=[1,1] input=[1,1]
looking to find conv output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yi has stride=1 in call for conv stride_map[y]=1
hw_output.s0.x.xi has stride=1 in call for conv stride_map[x]=1
conv found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: conv output stencil size - box extent=[((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0),min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))   using ((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1)
((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0),min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))   using ((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1)
]
conv.s0.y has stride=0 in call for conv stride_map[y]=1
conv.s0.x has stride=0 in call for conv stride_map[x]=1
conv.s1.y has stride=1 in call for conv stride_map[y]=1
conv.s1.x has stride=1 in call for conv stride_map[x]=1
conv.s1.r$y.r$y has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$y.r9 has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$x.r$x has stride=0 in call for conv stride_map[r$x]=0
conv.s1.r$x.r8 has stride=0 in call for conv stride_map[r$x]=0
min pos in dim 0:assert("conv_dim0", min(hw_output.s0.x.xi.base, 0))
min pos in dim 1:assert("conv_dim1", min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))
added for loop: hw_output.s0.x.xi
added for loop: conv.s0.y
added for loop: conv.s0.x
writers inside loop conv.s0.x
Box writer found for conv with box {[conv.s0.x, conv.s0.x], [conv.s0.y, conv.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
writers inside loop conv.s0.y
Box writer found for conv with box {[0, ((1 + 0) - 1)], [conv.s0.y, conv.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
added for loop: conv.s1.y
added for loop: conv.s1.x
added for loop: conv.s1.r$y.r$y
added for loop: conv.s1.r$y.r9
added for loop: conv.s1.r$x.r$x
added for loop: conv.s1.r$x.r8
writers inside loop conv.s1.r$x.r$x
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.r$x.r$x
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    unrolled (conv.s1.r$y.r9, 0, 3) {
      assert("conv_dim0", 0)
      assert("conv_dim1", 0)
    }
  }
}

writers inside loop conv.s1.r$y.r$y
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.r$y.r$y
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

writers inside loop conv.s1.x
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.x
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

writers inside loop conv.s1.y
Box writer found for conv with box {[0, ((1 + 0) - 1)], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.y
Box reader found for conv with box {[0, ((1 + 0) - 1)], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

readers inside pc conv
Box reader found for conv with box {[(hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.x.xi.base + hw_output.s0.x.xi)], [(hw_output.s0.y.yi.base + hw_output.s0.y.yi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
writers inside loop hw_output.s0.x.xi
Box writer found for conv with box {[0, 0], [0, 0]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop hw_output.s0.x.xi
Box reader found for conv with box {[min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0), max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)], [min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0), max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)]}
HWBuffer Parameter: reader ports - box extent=[((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1):1-(undefined) ((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1):1-(undefined) ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))
    assert("conv_dim1", min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))
  }
}

HWBuffer Parameter: conv has Total box of size [62 ]
conv stride_x=1
HWBuffer has 2 dims, while 2 num box_dims
 loops are: [hw_output.s0.y.yi,hw_output.s0.x.xi]
hwbuffer conv in begin 0 here
hwbuffer conv before sliding 0 here
hwbuffer conv in dim 0 here
hwbuffer conv after input block in dim 0 here
hwbuffer conv finished dim 0 has min_pos=0
hwbuffer conv in begin 1 here
hwbuffer conv before sliding 1 here
hwbuffer conv in dim 1 here
hwbuffer conv after input block in dim 1 here
hwbuffer conv finished dim 1 has min_pos=0
sliding stencil map is conv.s0.x, conv.s0.y, conv.s1.r$x.r$x, conv.s1.r$x.r8, conv.s1.r$y.r$y, conv.s1.r$y.r9, conv.s1.x, conv.s1.y, hw_output.s0.x.xi, hw_output.s0.y.yi, 
hw_output sliding output=[] input=[]
Box writer found for conv with box {[0, 0], [0, 0]}
Box writer found for hw_output with box {[(0 + 0), (0 + 61)], [(0 + 0), (0 + 61)]}
Box writer found for kernel with box {[0, 2], [0, 2]}
Box writer found for output with box {[0, 61], [0, 61]}
Box reader found for conv with box {[0, 61], [0, 61]}
Box reader found for hw_input with box {[(0 + (0 + 0)), (0 + (0 + 2))], [(0 + (0 + 0)), (0 + (0 + 2))]}
Box reader found for hw_output with box {[0, 61], [0, 61]}
Box reader found for kernel with box {[(0 + 0), (0 + 2)], [(0 + 0), (0 + 2)]}
HWBuffer Parameter: Total buffer box is of size [62 62]
HWBuffer Parameter: Input Chunk box is of size [62 62]
HWBuffer Parameter: Output Stencil box is of size [62 62]
looking to find hw_output output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yo has stride=0 in call for hw_output stride_map[y]=0
hw_output.s0.x.xo has stride=0 in call for hw_output stride_map[x]=0
kernel.s0.y has stride=0 in call for hw_output stride_map[y]=0
kernel.s0.x has stride=0 in call for hw_output stride_map[x]=0
hw_output.s0.y.yi has stride=0 in call for hw_output stride_map[y]=0
hw_output.s0.x.xi has stride=0 in call for hw_output stride_map[x]=0
hw_output found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: hw_output output stencil size - box extent=[]
conv.s0.y has stride=0 in call for hw_output stride_map[y]=0
conv.s0.x has stride=0 in call for hw_output stride_map[x]=0
conv.s1.y has stride=0 in call for hw_output stride_map[y]=0
conv.s1.x has stride=0 in call for hw_output stride_map[x]=0
conv.s1.r$y.r$y has stride=0 in call for hw_output stride_map[r$y]=0
conv.s1.r$y.r9 has stride=0 in call for hw_output stride_map[r$y]=0
conv.s1.r$x.r$x has stride=0 in call for hw_output stride_map[r$x]=0
conv.s1.r$x.r8 has stride=0 in call for hw_output stride_map[r$x]=0
output.s0.y has stride=1 in call for hw_output stride_map[y]=1
output.s0.x has stride=1 in call for hw_output stride_map[x]=1
added for loop: hw_output.s0.x.xo
added for loop: kernel.s0.y
added for loop: kernel.s0.x
added for loop: hw_output.s0.y.yi
added for loop: hw_output.s0.x.xi
added for loop: conv.s0.y
added for loop: conv.s0.x
added for loop: conv.s1.y
added for loop: conv.s1.x
added for loop: conv.s1.r$y.r$y
added for loop: conv.s1.r$y.r9
added for loop: conv.s1.r$x.r$x
added for loop: conv.s1.r$x.r8
writers inside pc conv
Box writer found for hw_output with box {[(hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.x.xi.base + hw_output.s0.x.xi)], [(hw_output.s0.y.yi.base + hw_output.s0.y.yi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
writers inside loop hw_output.s0.x.xi
Box writer found for hw_output with box {[(hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.x.xi.base + hw_output.s0.x.xi)], [(hw_output.s0.y.yi.base + hw_output.s0.y.yi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
min pos in dim 0:assert("hw_output_dim0", 0)
min pos in dim 1:assert("hw_output_dim1", output.s0.y)
added for loop: output.s0.x
readers inside loop output.s0.x
Box reader found for hw_output with box {[output.s0.x, output.s0.x], [output.s0.y, output.s0.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (output.s0.y, 0, 62) {
  for (output.s0.x, 0, 62) {
    assert("hw_output_dim0", output.s0.x)
    assert("hw_output_dim1", output.s0.y)
  }
}

output block: [1,1]
input block: [1,1]
transferring parameters
hw_output stride_x=1
box dim 0 works
input dim 0 works
output dim 0 works
hwbuffer hw_output in dim 0 has min_pos=0
box dim 1 works
input dim 1 works
output dim 1 works
hwbuffer hw_output in dim 1 has min_pos=0
created hwbuffer
checking hwbuffers in realize kernel
creating buffer for realize kernel
xcel compute level is hw_output.s0.x.xi
func kernel has store=hw_output.xo  compute=hw_output.xo
kernel has compute=store level
 Doing sliding window analysis over loop: kernel.s0.y
 Doing sliding window analysis over loop: kernel.s0.x
searching for sliding window for kernel using loop kernel.s0.x
searching for sliding window for kernel using loop kernel.s0.y
 Doing sliding window analysis over loop: hw_output.s0.y.yi
 Doing sliding window analysis over loop: hw_output.s0.x.xi
 Doing sliding window analysis over loop: conv.s0.y
 Doing sliding window analysis over loop: conv.s0.x
searching for sliding window for kernel using loop conv.s0.x
searching for sliding window for kernel using loop conv.s0.y
 Doing sliding window analysis over loop: conv.s1.y
 Doing sliding window analysis over loop: conv.s1.x
 Doing sliding window analysis over loop: conv.s1.r$y.r$y
 Doing sliding window analysis over loop: conv.s1.r$y.r9
 Doing sliding window analysis over loop: conv.s1.r$x.r$x
 Doing sliding window analysis over loop: conv.s1.r$x.r8
searching for sliding window for kernel using loop conv.s1.r$x.r8
searching for sliding window for kernel using loop conv.s1.r$x.r$x
searching for sliding window for kernel using loop conv.s1.r$y.r9
searching for sliding window for kernel using loop conv.s1.r$y.r$y
searching for sliding window for kernel using loop conv.s1.x
searching for sliding window for kernel using loop conv.s1.y
searching for sliding window for kernel using loop hw_output.s0.x.xi
searching for sliding window for kernel using loop hw_output.s0.y.yi
checking hwbuffers in realize conv
creating buffer for realize conv
xcel compute level is hw_output.s0.x.xi
func conv has store=hw_output.xo  compute=hw_output.xi
Doing sliding window analysis on realization of conv
 Doing sliding window analysis over loop: hw_output.s0.y.yi
 Doing sliding window analysis over loop: hw_output.s0.x.xi
 Doing sliding window analysis over loop: conv.s0.y
 Doing sliding window analysis over loop: conv.s0.x
searching for sliding window for conv using loop conv.s0.x
searching for sliding window for conv using loop conv.s0.y
 Doing sliding window analysis over loop: conv.s1.y
 Doing sliding window analysis over loop: conv.s1.x
 Doing sliding window analysis over loop: conv.s1.r$y.r$y
 Doing sliding window analysis over loop: conv.s1.r$y.r9
 Doing sliding window analysis over loop: conv.s1.r$x.r$x
 Doing sliding window analysis over loop: conv.s1.r$x.r8
searching for sliding window for conv using loop conv.s1.r$x.r8
searching for sliding window for conv using loop conv.s1.r$x.r$x
searching for sliding window for conv using loop conv.s1.r$y.r9
searching for sliding window for conv using loop conv.s1.r$y.r$y
searching for sliding window for conv using loop conv.s1.x
searching for sliding window for conv using loop conv.s1.y
searching for sliding window for conv using loop hw_output.s0.x.xi
visiting pc sliding window for conv
for dim=0  var=conv.s1.x  max=0  min=0
for dim=1  var=conv.s1.y  max=0  min=0
func conv provides={[0, 0], [0, 0]} requires={[0, 0], [0, 0]}
output stencil: 1 for dim 1
input stencil: 1
Sliding conv over dimension y along loop variable hw_output.s0.x.xi
 where min=0  max=0 max_prev_plus_one=(0 + 1)

Sliding conv, y
  Pushing min up from 0 to (0 + 1)
  Shrinking max from 0 to 0
added sliding stencil called hw_output.s0.x.xi with 1more loops resulting in num_total_loops=1
searching for sliding window for conv using loop hw_output.s0.y.yi
visiting pc sliding window for conv
for dim=0  var=conv.s1.x  max=0  min=0
for dim=1  var=conv.s1.y  max=0  min=0
func conv provides={[0, 0], [0, 0]} requires={[0, 0], [0, 0]}
output stencil: 1 for dim 1
input stencil: 1
Sliding conv over dimension y along loop variable hw_output.s0.y.yi
 where min=0  max=0 max_prev_plus_one=(0 + 1)

Sliding conv, y
  Pushing min up from 0 to (0 + 1)
  Shrinking max from 0 to 0
added sliding stencil called hw_output.s0.y.yi with 1more loops resulting in num_total_loops=2
conv sliding output=[1,1] input=[1,1]
looking to find conv output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yi has stride=1 in call for conv stride_map[y]=1
hw_output.s0.x.xi has stride=1 in call for conv stride_map[x]=1
conv found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: conv output stencil size - box extent=[((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0),min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))   using ((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1)
((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0),min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))   using ((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1)
]
conv.s0.y has stride=0 in call for conv stride_map[y]=1
conv.s0.x has stride=0 in call for conv stride_map[x]=1
conv.s1.y has stride=1 in call for conv stride_map[y]=1
conv.s1.x has stride=1 in call for conv stride_map[x]=1
conv.s1.r$y.r$y has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$y.r9 has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$x.r$x has stride=0 in call for conv stride_map[r$x]=0
conv.s1.r$x.r8 has stride=0 in call for conv stride_map[r$x]=0
min pos in dim 0:assert("conv_dim0", min(hw_output.s0.x.xi.base, 0))
min pos in dim 1:assert("conv_dim1", min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))
added for loop: hw_output.s0.x.xi
added for loop: conv.s0.y
added for loop: conv.s0.x
writers inside loop conv.s0.x
Box writer found for conv with box {[conv.s0.x, conv.s0.x], [conv.s0.y, conv.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
writers inside loop conv.s0.y
Box writer found for conv with box {[0, ((1 + 0) - 1)], [conv.s0.y, conv.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
added for loop: conv.s1.y
added for loop: conv.s1.x
added for loop: conv.s1.r$y.r$y
added for loop: conv.s1.r$y.r9
added for loop: conv.s1.r$x.r$x
added for loop: conv.s1.r$x.r8
writers inside loop conv.s1.r$x.r$x
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.r$x.r$x
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    unrolled (conv.s1.r$y.r9, 0, 3) {
      assert("conv_dim0", 0)
      assert("conv_dim1", 0)
    }
  }
}

writers inside loop conv.s1.r$y.r$y
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.r$y.r$y
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

writers inside loop conv.s1.x
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.x
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

writers inside loop conv.s1.y
Box writer found for conv with box {[0, ((1 + 0) - 1)], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.y
Box reader found for conv with box {[0, ((1 + 0) - 1)], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

readers inside pc conv
Box reader found for conv with box {[(hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.x.xi.base + hw_output.s0.x.xi)], [(hw_output.s0.y.yi.base + hw_output.s0.y.yi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
writers inside loop hw_output.s0.x.xi
Box writer found for conv with box {[0, 0], [0, 0]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop hw_output.s0.x.xi
Box reader found for conv with box {[min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0), max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)], [min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0), max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)]}
HWBuffer Parameter: reader ports - box extent=[((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1):1-(undefined) ((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1):1-(undefined) ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))
    assert("conv_dim1", min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))
  }
}

HWBuffer Parameter: conv has Total box of size [62 ]
conv stride_x=1
HWBuffer has 2 dims, while 2 num box_dims
 loops are: [hw_output.s0.y.yi,hw_output.s0.x.xi]
hwbuffer conv in begin 0 here
hwbuffer conv before sliding 0 here
hwbuffer conv in dim 0 here
hwbuffer conv after input block in dim 0 here
hwbuffer conv finished dim 0 has min_pos=0
hwbuffer conv in begin 1 here
hwbuffer conv before sliding 1 here
hwbuffer conv in dim 1 here
hwbuffer conv after input block in dim 1 here
hwbuffer conv finished dim 1 has min_pos=0
sliding stencil map is conv.s0.x, conv.s0.y, conv.s1.r$x.r$x, conv.s1.r$x.r8, conv.s1.r$y.r$y, conv.s1.r$y.r9, conv.s1.x, conv.s1.y, hw_output.s0.x.xi, hw_output.s0.y.yi, 
kernel sliding output=[] input=[]
Box writer found for conv with box {[0, 0], [0, 0]}
Box writer found for hw_output with box {[(hw_output.s0.x.xi.base + 0), (hw_output.s0.x.xi.base + ((62 + 0) - 1))], [(hw_output.s0.y.yi.base + 0), (hw_output.s0.y.yi.base + ((62 + 0) - 1))]}
Box writer found for kernel with box {[0, 2], [0, 2]}
Box reader found for conv with box {[min(hw_output.s0.x.xi.base, 0), (max(hw_output.s0.x.xi.base, -61) + 61)], [min(hw_output.s0.y.yi.base, 0), (max(hw_output.s0.y.yi.base, -61) + 61)]}
Box reader found for hw_input with box {[(0 + (0 + 0)), (0 + (0 + 2))], [(0 + (0 + 0)), (0 + (0 + 2))]}
Box reader found for kernel with box {[(0 + 0), (0 + 2)], [(0 + 0), (0 + 2)]}
HWBuffer Parameter: Total buffer box is of size [3 3]
HWBuffer Parameter: Input Chunk box is of size [3 3]
HWBuffer Parameter: Output Stencil box is of size [3 3]
looking to find kernel output stencil where compute_level=hw_output.s0.x.xi
kernel.s0.y has stride=0 in call for kernel stride_map[y]=0
kernel.s0.x has stride=0 in call for kernel stride_map[x]=0
hw_output.s0.y.yi has stride=0 in call for kernel stride_map[y]=0
hw_output.s0.x.xi has stride=0 in call for kernel stride_map[x]=0
kernel found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: kernel output stencil size - box extent=[3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
]
conv.s0.y has stride=0 in call for kernel stride_map[y]=0
conv.s0.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.y has stride=0 in call for kernel stride_map[y]=0
conv.s1.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.r$y.r$y has stride=0 in call for kernel stride_map[r$y]=0
conv.s1.r$y.r9 has stride=1 in call for kernel stride_map[r$y]=1
conv.s1.r$x.r$x has stride=0 in call for kernel stride_map[r$x]=0
conv.s1.r$x.r8 has stride=1 in call for kernel stride_map[r$x]=1
added for loop: kernel.s0.x
writers inside loop kernel.s0.x
Box writer found for kernel with box {[kernel.s0.x, kernel.s0.x], [kernel.s0.y, kernel.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
min pos in dim 0:assert("kernel_dim0", 0)
min pos in dim 1:assert("kernel_dim1", 0)
added for loop: hw_output.s0.x.xi
added for loop: conv.s0.y
added for loop: conv.s0.x
added for loop: conv.s1.y
added for loop: conv.s1.x
added for loop: conv.s1.r$y.r$y
added for loop: conv.s1.r$y.r9
added for loop: conv.s1.r$x.r$x
added for loop: conv.s1.r$x.r8
readers inside loop conv.s1.r$x.r$x
Box reader found for kernel with box {[((conv.s1.r$x.r$x*3) + 0), ((conv.s1.r$x.r$x*3) + ((3 + 0) - 1))], [(conv.s1.r$y.r9.base + conv.s1.r$y.r9), (conv.s1.r$y.r9.base + conv.s1.r$y.r9)]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    unrolled (conv.s1.r$y.r9, 0, 3) {
      assert("kernel_dim0", 0)
      assert("kernel_dim1", conv.s1.r$y.r9)
    }
  }
}

readers inside loop conv.s1.r$y.r$y
Box reader found for kernel with box {[(0 + 0), (0 + ((3 + 0) - 1))], [((conv.s1.r$y.r$y*3) + 0), ((conv.s1.r$y.r$y*3) + ((3 + 0) - 1))]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 3:3-3 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("kernel_dim0", 0)
    assert("kernel_dim1", 0)
  }
}

readers inside loop conv.s1.x
Box reader found for kernel with box {[(0 + 0), (0 + ((3 + 0) - 1))], [(0 + 0), (0 + ((3 + 0) - 1))]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 3:3-3 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("kernel_dim0", 0)
    assert("kernel_dim1", 0)
  }
}

readers inside loop conv.s1.y
Box reader found for kernel with box {[(0 + 0), (0 + ((3 + 0) - 1))], [(0 + 0), (0 + ((3 + 0) - 1))]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 3:3-3 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("kernel_dim0", 0)
    assert("kernel_dim1", 0)
  }
}

readers inside loop hw_output.s0.x.xi
Box reader found for kernel with box {[(0 + 0), (0 + 2)], [(0 + 0), (0 + 2)]}
HWBuffer Parameter: reader ports - box extent=[3:3-3 3:3-3 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("kernel_dim0", 0)
    assert("kernel_dim1", 0)
  }
}

output block: [3,3]
input block: [1,1]
transferring parameters
kernel stride_x=0
box dim 0 works
input dim 0 works
output dim 0 works
hwbuffer kernel in dim 0 has min_pos=(0 + 0)
box dim 1 works
input dim 1 works
output dim 1 works
hwbuffer kernel in dim 1 has min_pos=(0 + 0)
created hwbuffer
checking hwbuffers in realize conv
creating buffer for realize conv
xcel compute level is hw_output.s0.x.xi
func conv has store=hw_output.xo  compute=hw_output.xi
Doing sliding window analysis on realization of conv
 Doing sliding window analysis over loop: hw_output.s0.y.yi
 Doing sliding window analysis over loop: hw_output.s0.x.xi
 Doing sliding window analysis over loop: conv.s0.y
 Doing sliding window analysis over loop: conv.s0.x
searching for sliding window for conv using loop conv.s0.x
searching for sliding window for conv using loop conv.s0.y
 Doing sliding window analysis over loop: conv.s1.y
 Doing sliding window analysis over loop: conv.s1.x
 Doing sliding window analysis over loop: conv.s1.r$y.r$y
 Doing sliding window analysis over loop: conv.s1.r$y.r9
 Doing sliding window analysis over loop: conv.s1.r$x.r$x
 Doing sliding window analysis over loop: conv.s1.r$x.r8
searching for sliding window for conv using loop conv.s1.r$x.r8
searching for sliding window for conv using loop conv.s1.r$x.r$x
searching for sliding window for conv using loop conv.s1.r$y.r9
searching for sliding window for conv using loop conv.s1.r$y.r$y
searching for sliding window for conv using loop conv.s1.x
searching for sliding window for conv using loop conv.s1.y
searching for sliding window for conv using loop hw_output.s0.x.xi
visiting pc sliding window for conv
for dim=0  var=conv.s1.x  max=0  min=0
for dim=1  var=conv.s1.y  max=0  min=0
func conv provides={[0, 0], [0, 0]} requires={[0, 0], [0, 0]}
output stencil: 1 for dim 1
input stencil: 1
Sliding conv over dimension y along loop variable hw_output.s0.x.xi
 where min=0  max=0 max_prev_plus_one=(0 + 1)

Sliding conv, y
  Pushing min up from 0 to (0 + 1)
  Shrinking max from 0 to 0
added sliding stencil called hw_output.s0.x.xi with 1more loops resulting in num_total_loops=1
searching for sliding window for conv using loop hw_output.s0.y.yi
visiting pc sliding window for conv
for dim=0  var=conv.s1.x  max=0  min=0
for dim=1  var=conv.s1.y  max=0  min=0
func conv provides={[0, 0], [0, 0]} requires={[0, 0], [0, 0]}
output stencil: 1 for dim 1
input stencil: 1
Sliding conv over dimension y along loop variable hw_output.s0.y.yi
 where min=0  max=0 max_prev_plus_one=(0 + 1)

Sliding conv, y
  Pushing min up from 0 to (0 + 1)
  Shrinking max from 0 to 0
added sliding stencil called hw_output.s0.y.yi with 1more loops resulting in num_total_loops=2
conv sliding output=[1,1] input=[1,1]
looking to find conv output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yi has stride=1 in call for conv stride_map[y]=1
hw_output.s0.x.xi has stride=1 in call for conv stride_map[x]=1
conv found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: conv output stencil size - box extent=[((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0),min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))   using ((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1)
((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0),min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))   using ((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1)
]
conv.s0.y has stride=0 in call for conv stride_map[y]=1
conv.s0.x has stride=0 in call for conv stride_map[x]=1
conv.s1.y has stride=1 in call for conv stride_map[y]=1
conv.s1.x has stride=1 in call for conv stride_map[x]=1
conv.s1.r$y.r$y has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$y.r9 has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$x.r$x has stride=0 in call for conv stride_map[r$x]=0
conv.s1.r$x.r8 has stride=0 in call for conv stride_map[r$x]=0
min pos in dim 0:assert("conv_dim0", min(hw_output.s0.x.xi.base, 0))
min pos in dim 1:assert("conv_dim1", min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))
added for loop: hw_output.s0.x.xi
added for loop: conv.s0.y
added for loop: conv.s0.x
writers inside loop conv.s0.x
Box writer found for conv with box {[conv.s0.x, conv.s0.x], [conv.s0.y, conv.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
writers inside loop conv.s0.y
Box writer found for conv with box {[0, ((1 + 0) - 1)], [conv.s0.y, conv.s0.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
added for loop: conv.s1.y
added for loop: conv.s1.x
added for loop: conv.s1.r$y.r$y
added for loop: conv.s1.r$y.r9
added for loop: conv.s1.r$x.r$x
added for loop: conv.s1.r$x.r8
writers inside loop conv.s1.r$x.r$x
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.r$x.r$x
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    unrolled (conv.s1.r$y.r9, 0, 3) {
      assert("conv_dim0", 0)
      assert("conv_dim1", 0)
    }
  }
}

writers inside loop conv.s1.r$y.r$y
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.r$y.r$y
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

writers inside loop conv.s1.x
Box writer found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.x
Box reader found for conv with box {[conv.s1.x, conv.s1.x], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

writers inside loop conv.s1.y
Box writer found for conv with box {[0, ((1 + 0) - 1)], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop conv.s1.y
Box reader found for conv with box {[0, ((1 + 0) - 1)], [conv.s1.y, conv.s1.y]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", 0)
    assert("conv_dim1", 0)
  }
}

readers inside pc conv
Box reader found for conv with box {[(hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.x.xi.base + hw_output.s0.x.xi)], [(hw_output.s0.y.yi.base + hw_output.s0.y.yi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)]}
HWBuffer Parameter: reader ports - box extent=[1:1-1 1:1-1 ]
writers inside loop hw_output.s0.x.xi
Box writer found for conv with box {[0, 0], [0, 0]}
HWBuffer Parameter: writer ports - box extent=[1-1 1-1 ]
readers inside loop hw_output.s0.x.xi
Box reader found for conv with box {[min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0), max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)], [min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0), max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)]}
HWBuffer Parameter: reader ports - box extent=[((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1):1-(undefined) ((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1):1-(undefined) ]
HWBuffer Parameter - nested reader loop:
for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))
    assert("conv_dim1", min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))
  }
}

HWBuffer Parameter: conv has Total box of size [62 ]
conv stride_x=1
HWBuffer has 2 dims, while 2 num box_dims
 loops are: [hw_output.s0.y.yi,hw_output.s0.x.xi]
hwbuffer conv in begin 0 here
hwbuffer conv before sliding 0 here
hwbuffer conv in dim 0 here
hwbuffer conv after input block in dim 0 here
hwbuffer conv finished dim 0 has min_pos=0
hwbuffer conv in begin 1 here
hwbuffer conv before sliding 1 here
hwbuffer conv in dim 1 here
hwbuffer conv after input block in dim 1 here
hwbuffer conv finished dim 1 has min_pos=0
sliding stencil map is conv.s0.x, conv.s0.y, conv.s1.r$x.r$x, conv.s1.r$x.r8, conv.s1.r$y.r$y, conv.s1.r$y.r9, conv.s1.x, conv.s1.y, hw_output.s0.x.xi, hw_output.s0.y.yi, 
conv is ehb w/ inline=0
HWBuffer: conv
Logical Buffer: [62,62]
Input Chunk: [1,1]
Input Block: [1,1]
Output Stencil: [(undefined),(undefined)]
Output Block: [1,1]
Output Access Pattern:
 for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))
    assert("conv_dim1", min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))
  }
}

Output Min Pos:
 [0,0]
is_inline=0
is_output=0

hw_input is ehb w/ inline=0
HWBuffer: hw_input
Logical Buffer: [64,64]
Input Chunk: [1,1]
Input Block: [1,1]
Output Stencil: [3,3]
Output Block: [3,3]
Output Access Pattern:
 for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("hw_input_dim0", 0)
    assert("hw_input_dim1", 0)
  }
}

Output Min Pos:
 [(0 + (0 + 0)),(0 + (0 + 0))]
is_inline=0
is_output=0

hw_output is ehb w/ inline=0
HWBuffer: hw_output
Logical Buffer: [62,62]
Input Chunk: [1,1]
Input Block: [1,1]
Output Stencil: [1,1]
Output Block: [1,1]
Output Access Pattern:
 for (output.s0.y, 0, 62) {
  for (output.s0.x, 0, 62) {
    assert("hw_output_dim0", output.s0.x)
    assert("hw_output_dim1", output.s0.y)
  }
}

Output Min Pos:
 [0,0]
is_inline=0
is_output=0

kernel is ehb w/ inline=0
HWBuffer: kernel
Logical Buffer: [3,3]
Input Chunk: [1,1]
Input Block: [1,1]
Output Stencil: [3,3]
Output Block: [3,3]
Output Access Pattern:
 for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("kernel_dim0", 0)
    assert("kernel_dim1", 0)
  }
}

Output Min Pos:
 [(0 + 0),(0 + 0)]
is_inline=0
is_output=0

conv,hw_input,hw_output,kernel,
there are 4 hwbuffers
looking for output
conv,hw_input,hw_output,kernel,
there are 4 hwbuffers
looking for hw_output
hw_output before func
HWBuffer has 2 dims, while 
 loops are: []
 args are: [x,y]
finished is_output 1 consumers
conv,hw_input,hw_output,kernel,
there are 4 hwbuffers
looking for conv
conv before func
conv 0 has min_pos=0
conv 1 has min_pos=0
HWBuffer has 2 dims, while 
 loops are: []
 args are: [x,y]
finished is_output 1 consumers
conv is inline=0 store=loop_level(hw_output.xo) compute=loop_level(hw_output.xi) is_xcel=0 is_hw_kernel=1
hw_output,
right before hw_output consumer of conv
adding conv as an input of hw_output
 size of consumer box is {[hw_output.s0.x.min, hw_output.s0.x.max], [hw_output.s0.y.min, hw_output.s0.y.max]}
 size of consumer box is (hw_output.s0.x.max - hw_output.s0.x.min)
for kernel conv, adding consumer hw_output based on kernel hw_output
conv compute loop is using hw_output.s0.x.xi based on func convcompute=loop_level(hw_output.xi)
looking to find conv output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yo has stride=0 in call for conv stride_map[y]=0
hw_output.s0.x.xo has stride=0 in call for conv stride_map[x]=0
kernel.s0.y has stride=0 in call for conv stride_map[y]=0
kernel.s0.x has stride=0 in call for conv stride_map[x]=0
hw_output.s0.y.yi has stride=1 in call for conv stride_map[y]=1
hw_output.s0.x.xi has stride=1 in call for conv stride_map[x]=1
conv found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: conv output stencil size - box extent=[((max((min(likely_if_innermost((hw_output.s0.x.xo*62)), 0) + hw_output.s0.x.xi), 0) - min((min(likely_if_innermost((hw_output.s0.x.xo*62)), 0) + hw_output.s0.x.xi), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0),min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))   using ((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1)
((max((min(likely_if_innermost((hw_output.s0.y.yo*62)), 0) + hw_output.s0.y.yi), 0) - min((min(likely_if_innermost((hw_output.s0.y.yo*62)), 0) + hw_output.s0.y.yi), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0),min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))   using ((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1)
]
conv.s0.y has stride=0 in call for conv stride_map[y]=1
conv.s0.x has stride=0 in call for conv stride_map[x]=1
conv.s1.y has stride=1 in call for conv stride_map[y]=1
conv.s1.x has stride=1 in call for conv stride_map[x]=1
conv.s1.r$y.r$y has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$y.r9 has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$x.r$x has stride=0 in call for conv stride_map[r$x]=0
conv.s1.r$x.r8 has stride=0 in call for conv stride_map[r$x]=0
output.s0.y has stride=0 in call for conv stride_map[y]=1
output.s0.x has stride=0 in call for conv stride_map[x]=1
conv stride_x=1
r$x,0
r$y,0
x,1
y,1
the output stencil of conv from hw_output at  is [1,1]
produce hw_output {
  let hw_output.s0.y.loop_max = 61
  let hw_output.s0.y.loop_min = 0
  let hw_output.s0.y.loop_extent = 62
  let hw_output.s0.x.loop_max = 61
  let hw_output.s0.x.loop_min = 0
  let hw_output.s0.x.loop_extent = 62
  let hw_output.s0.x.xo.loop_extent = 1
  let hw_output.s0.x.xo.loop_max = 0
  let hw_output.s0.x.xo.loop_min = 0
  let hw_output.s0.x.xi.loop_extent = 62
  let hw_output.s0.x.xi.loop_max = 61
  let hw_output.s0.x.xi.loop_min = 0
  let hw_output.s0.y.yo.loop_extent = 1
  let hw_output.s0.y.yo.loop_max = 0
  let hw_output.s0.y.yo.loop_min = 0
  let hw_output.s0.y.yi.loop_extent = 62
  let hw_output.s0.y.yi.loop_max = 61
  let hw_output.s0.y.yi.loop_min = 0
  for (hw_output.s0.y.yo, 0, 1) {
    let hw_output.s0.y.yi.base = min(likely_if_innermost((hw_output.s0.y.yo*62)), 0)
    for (hw_output.s0.x.xo, 0, 1) {
      let hw_output.s0.x.xi.base = min(likely_if_innermost((hw_output.s0.x.xo*62)), 0)
      let hw_output.s0.y.min = hw_output.s0.y.yi.base
      let hw_output.s0.y.max = (hw_output.s0.y.yi.base + 61)
      let hw_output.s0.x.min = hw_output.s0.x.xi.base
      let hw_output.s0.x.max = (hw_output.s0.x.xi.base + 61)
      let conv.s1.r$y.max = 2
      let conv.s1.r$y.min = 0
      let conv.s1.r$x.max = 2
      let conv.s1.r$x.min = 0
      let conv.s1.y.max = 61
      let conv.s1.y.min = 0
      let conv.s1.x.max = 61
      let conv.s1.x.min = 0
      let conv.s0.y.max = 61
      let conv.s0.y.min = 0
      let conv.s0.x.max = 61
      let conv.s0.x.min = 0
      let kernel.s9.y.max = 2
      let kernel.s9.y.min = 0
      let kernel.s9.x.max = 2
      let kernel.s9.x.min = 0
      let kernel.s8.y.max = 2
      let kernel.s8.y.min = 0
      let kernel.s8.x.max = 2
      let kernel.s8.x.min = 0
      let kernel.s7.y.max = 2
      let kernel.s7.y.min = 0
      let kernel.s7.x.max = 2
      let kernel.s7.x.min = 0
      let kernel.s6.y.max = 2
      let kernel.s6.y.min = 0
      let kernel.s6.x.max = 2
      let kernel.s6.x.min = 0
      let kernel.s5.y.max = 2
      let kernel.s5.y.min = 0
      let kernel.s5.x.max = 2
      let kernel.s5.x.min = 0
      let kernel.s4.y.max = 2
      let kernel.s4.y.min = 0
      let kernel.s4.x.max = 2
      let kernel.s4.x.min = 0
      let kernel.s3.y.max = 2
      let kernel.s3.y.min = 0
      let kernel.s3.x.max = 2
      let kernel.s3.x.min = 0
      let kernel.s2.y.max = 2
      let kernel.s2.y.min = 0
      let kernel.s2.x.max = 2
      let kernel.s2.x.min = 0
      let kernel.s1.y.max = 2
      let kernel.s1.y.min = 0
      let kernel.s1.x.max = 2
      let kernel.s1.x.min = 0
      let kernel.s0.y.max = 2
      let kernel.s0.y.min = 0
      let kernel.s0.x.max = 2
      let kernel.s0.x.min = 0
      let kernel.y.max_realized = 2
      let kernel.y.min_realized = 0
      let kernel.y.extent_realized = 3
      let kernel.x.max_realized = 2
      let kernel.x.min_realized = 0
      let kernel.x.extent_realized = 3
      realize kernel([0, 3], [0, 3]) {
        produce kernel {
          let kernel.s0.y.loop_max = 2
          let kernel.s0.y.loop_min = 0
          let kernel.s0.y.loop_extent = 3
          let kernel.s0.x.loop_max = 2
          let kernel.s0.x.loop_min = 0
          let kernel.s0.x.loop_extent = 3
          let kernel.s1.y.loop_max = 2
          let kernel.s1.y.loop_min = 0
          let kernel.s1.y.loop_extent = 3
          let kernel.s1.x.loop_max = 2
          let kernel.s1.x.loop_min = 0
          let kernel.s1.x.loop_extent = 3
          let kernel.s2.y.loop_max = 2
          let kernel.s2.y.loop_min = 0
          let kernel.s2.y.loop_extent = 3
          let kernel.s2.x.loop_max = 2
          let kernel.s2.x.loop_min = 0
          let kernel.s2.x.loop_extent = 3
          let kernel.s3.y.loop_max = 2
          let kernel.s3.y.loop_min = 0
          let kernel.s3.y.loop_extent = 3
          let kernel.s3.x.loop_max = 2
          let kernel.s3.x.loop_min = 0
          let kernel.s3.x.loop_extent = 3
          let kernel.s4.y.loop_max = 2
          let kernel.s4.y.loop_min = 0
          let kernel.s4.y.loop_extent = 3
          let kernel.s4.x.loop_max = 2
          let kernel.s4.x.loop_min = 0
          let kernel.s4.x.loop_extent = 3
          let kernel.s5.y.loop_max = 2
          let kernel.s5.y.loop_min = 0
          let kernel.s5.y.loop_extent = 3
          let kernel.s5.x.loop_max = 2
          let kernel.s5.x.loop_min = 0
          let kernel.s5.x.loop_extent = 3
          let kernel.s6.y.loop_max = 2
          let kernel.s6.y.loop_min = 0
          let kernel.s6.y.loop_extent = 3
          let kernel.s6.x.loop_max = 2
          let kernel.s6.x.loop_min = 0
          let kernel.s6.x.loop_extent = 3
          let kernel.s7.y.loop_max = 2
          let kernel.s7.y.loop_min = 0
          let kernel.s7.y.loop_extent = 3
          let kernel.s7.x.loop_max = 2
          let kernel.s7.x.loop_min = 0
          let kernel.s7.x.loop_extent = 3
          let kernel.s8.y.loop_max = 2
          let kernel.s8.y.loop_min = 0
          let kernel.s8.y.loop_extent = 3
          let kernel.s8.x.loop_max = 2
          let kernel.s8.x.loop_min = 0
          let kernel.s8.x.loop_extent = 3
          let kernel.s9.y.loop_max = 2
          let kernel.s9.y.loop_min = 0
          let kernel.s9.y.loop_extent = 3
          let kernel.s9.x.loop_max = 2
          let kernel.s9.x.loop_min = 0
          let kernel.s9.x.loop_extent = 3
          for (kernel.s0.y, 0, 3) {
            for (kernel.s0.x, 0, 3) {
              kernel(kernel.s0.x, kernel.s0.y) = 0
            }
          }
          kernel(0, 0) = 1
          kernel(0, 1) = 0
          kernel(0, 2) = 0
          kernel(1, 0) = 0
          kernel(1, 1) = 0
          kernel(1, 2) = 0
          kernel(2, 0) = 0
          kernel(2, 1) = 0
          kernel(2, 2) = 0
        }
        consume kernel {
          let conv.y.max_realized = (hw_output.s0.y.yi.base + 61)
          let conv.y.min_realized = hw_output.s0.y.yi.base
          let conv.y.extent_realized = 62
          let conv.x.max_realized = (hw_output.s0.x.xi.base + 61)
          let conv.x.min_realized = hw_output.s0.x.xi.base
          let conv.x.extent_realized = 62
          realize conv([conv.x.min_realized, 62], [conv.y.min_realized, 62]) {
            for (hw_output.s0.y.yi, 0, 62) {
              let hw_output.s0.y = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
              for (hw_output.s0.x.xi, 0, 62) {
                let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
                let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
                let hw_output.s0.y.max = 0
                let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
                let hw_output.s0.x.max = 0
                let conv.s1.r$y.max = 2
                let conv.s1.r$y.min = 0
                let conv.s1.r$x.max = 2
                let conv.s1.r$x.min = 0
                let conv.s1.y.max = 0
                let conv.s1.y.min = 0
                let conv.s1.x.max = 0
                let conv.s1.x.min = 0
                let conv.s0.y.max = 0
                let conv.s0.y.min = 0
                let conv.s0.x.max = 0
                let conv.s0.x.min = 0
                produce conv {
                  let conv.s0.y.loop_max = 0
                  let conv.s0.y.loop_min = 0
                  let conv.s0.y.loop_extent = 1
                  let conv.s0.x.loop_max = 0
                  let conv.s0.x.loop_min = 0
                  let conv.s0.x.loop_extent = 1
                  let conv.s1.r$y.loop_extent = 3
                  let conv.s1.r$y.loop_max = 2
                  let conv.s1.r$y.loop_min = 0
                  let conv.s1.r$x.loop_extent = 3
                  let conv.s1.r$x.loop_max = 2
                  let conv.s1.r$x.loop_min = 0
                  let conv.s1.y.loop_max = 0
                  let conv.s1.y.loop_min = 0
                  let conv.s1.y.loop_extent = 1
                  let conv.s1.x.loop_max = 0
                  let conv.s1.x.loop_min = 0
                  let conv.s1.x.loop_extent = 1
                  let conv.s1.r$x.r$x.loop_extent = 1
                  let conv.s1.r$x.r$x.loop_max = 0
                  let conv.s1.r$x.r$x.loop_min = 0
                  let conv.s1.r$x.r8.loop_extent = 3
                  let conv.s1.r$x.r8.loop_max = 2
                  let conv.s1.r$x.r8.loop_min = 0
                  let conv.s1.r$y.r$y.loop_extent = 1
                  let conv.s1.r$y.r$y.loop_max = 0
                  let conv.s1.r$y.r$y.loop_min = 0
                  let conv.s1.r$y.r9.loop_extent = 3
                  let conv.s1.r$y.r9.loop_max = 2
                  let conv.s1.r$y.r9.loop_min = 0
                  for (conv.s0.y, 0, 1) {
                    for (conv.s0.x, 0, 1) {
                      conv(conv.s0.x, conv.s0.y) = 0
                    }
                  }
                  for (conv.s1.y, 0, 1) {
                    for (conv.s1.x, 0, 1) {
                      for (conv.s1.r$y.r$y, 0, 1) {
                        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
                        unrolled (conv.s1.r$y.r9, 0, 3) {
                          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
                          for (conv.s1.r$x.r$x, 0, 1) {
                            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
                            unrolled (conv.s1.r$x.r8, 0, 3) {
                              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
                              let conv.s1.r$y.max = conv.s1.r$y
                              let conv.s1.r$y.min = conv.s1.r$y
                              let conv.s1.r$x.max = conv.s1.r$x
                              let conv.s1.r$x.min = conv.s1.r$x
                              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
                            }
                          }
                        }
                      }
                    }
                  }
                }
                consume conv {
                  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
                }
              }
            }
          }
        }
      }
    }
  }
}
consume hw_output {
  assert(((0 <= output.s0.y.min_unbounded) && (((62 + 0) - 1) >= output.s0.y.max_unbounded)), halide_error_explicit_bounds_too_small("y", "output", 0, ((62 + 0) - 1), output.s0.y.min_unbounded, output.s0.y.max_unbounded))
  assert(((0 <= output.s0.x.min_unbounded) && (((62 + 0) - 1) >= output.s0.x.max_unbounded)), halide_error_explicit_bounds_too_small("x", "output", 0, ((62 + 0) - 1), output.s0.x.min_unbounded, output.s0.x.max_unbounded))
  produce output {
    let output.s0.y.loop_max = 61
    let output.s0.y.loop_min = 0
    let output.s0.y.loop_extent = 62
    let output.s0.x.loop_max = 61
    let output.s0.x.loop_min = 0
    let output.s0.x.loop_extent = 62
    for (output.s0.y, 0, 62) {
      for (output.s0.x, 0, 62) {
        output(output.s0.x, output.s0.y) = hw_output(output.s0.x, output.s0.y)
      }
    }
  }
}
saw this for loop hw_output.s0.y.yi while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.x.xi while compute=hw_output.s0.x.xi
let's save this input box num_dims=2 box=2
HWBuffer Parameter: hw_output input chunk size - box extent=[1:1-1 ((hw_output.s0.x.xi + hw_output.s0.x.xi.base),(hw_output.s0.x.xi.base + hw_output.s0.x.xi))  1:1-1 ((hw_output.s0.y.yi + hw_output.s0.y.yi.base),(hw_output.s0.y.yi.base + hw_output.s0.y.yi))  ]
saw this for loop conv.s0.y while compute=hw_output.s0.x.xi
saw this for loop conv.s0.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r$y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r9 while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r$x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r8 while compute=hw_output.s0.x.xi
the input chunk of conv at  is [1,1]
here we have consumer hw_output with 1 found
replaced min pos for conv 0 with (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
replaced output stencil for conv based on consumer hw_output
replaced input=1 and output=1
replaced min pos for conv 1 with (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
replaced output stencil for conv based on consumer hw_output
replaced input=1 and output=1
right before hw_output inputs
conv,hw_input,hw_output,kernel,
there are 4 hwbuffers
looking for conv
conv before func
HWBuffer has 2 dims, while 
 loops are: []
 args are: [x,y]
finished is_output 2 consumers
conv is inline=0 store=loop_level(hw_output.xo) compute=loop_level(hw_output.xi) is_xcel=0 is_hw_kernel=1
conv,hw_output,
right before conv consumer of conv
adding conv as an input of conv
 size of consumer box is {[conv.s1.x.min, conv.s1.x.max], [conv.s1.y.min, conv.s1.y.max]}
 size of consumer box is (conv.s1.x.max - conv.s1.x.min)
for kernel conv, adding consumer conv based on kernel conv
conv compute loop is using hw_output.s0.x.xi based on func convcompute=loop_level(hw_output.xi)
looking to find conv output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yi has stride=1 in call for conv stride_map[y]=1
hw_output.s0.x.xi has stride=1 in call for conv stride_map[x]=1
conv found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: conv output stencil size - box extent=[((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0),min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))   using ((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1)
((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0),min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))   using ((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1)
]
conv.s0.y has stride=0 in call for conv stride_map[y]=1
conv.s0.x has stride=0 in call for conv stride_map[x]=1
conv.s1.y has stride=1 in call for conv stride_map[y]=1
conv.s1.x has stride=1 in call for conv stride_map[x]=1
conv.s1.r$y.r$y has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$y.r9 has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$x.r$x has stride=0 in call for conv stride_map[r$x]=0
conv.s1.r$x.r8 has stride=0 in call for conv stride_map[r$x]=0
conv stride_x=1
r$x,0
r$y,0
x,1
y,1
the output stencil of conv from conv at  is [1,1]
for (hw_output.s0.y.yi, 0, 62) {
  let hw_output.s0.y = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
  for (hw_output.s0.x.xi, 0, 62) {
    let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
    let hw_output.s0.y.max = 0
    let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.x.max = 0
    let conv.s1.r$y.max = 2
    let conv.s1.r$y.min = 0
    let conv.s1.r$x.max = 2
    let conv.s1.r$x.min = 0
    let conv.s1.y.max = 0
    let conv.s1.y.min = 0
    let conv.s1.x.max = 0
    let conv.s1.x.min = 0
    let conv.s0.y.max = 0
    let conv.s0.y.min = 0
    let conv.s0.x.max = 0
    let conv.s0.x.min = 0
    produce conv {
      let conv.s0.y.loop_max = 0
      let conv.s0.y.loop_min = 0
      let conv.s0.y.loop_extent = 1
      let conv.s0.x.loop_max = 0
      let conv.s0.x.loop_min = 0
      let conv.s0.x.loop_extent = 1
      let conv.s1.r$y.loop_extent = 3
      let conv.s1.r$y.loop_max = 2
      let conv.s1.r$y.loop_min = 0
      let conv.s1.r$x.loop_extent = 3
      let conv.s1.r$x.loop_max = 2
      let conv.s1.r$x.loop_min = 0
      let conv.s1.y.loop_max = 0
      let conv.s1.y.loop_min = 0
      let conv.s1.y.loop_extent = 1
      let conv.s1.x.loop_max = 0
      let conv.s1.x.loop_min = 0
      let conv.s1.x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_max = 0
      let conv.s1.r$x.r$x.loop_min = 0
      let conv.s1.r$x.r8.loop_extent = 3
      let conv.s1.r$x.r8.loop_max = 2
      let conv.s1.r$x.r8.loop_min = 0
      let conv.s1.r$y.r$y.loop_extent = 1
      let conv.s1.r$y.r$y.loop_max = 0
      let conv.s1.r$y.r$y.loop_min = 0
      let conv.s1.r$y.r9.loop_extent = 3
      let conv.s1.r$y.r9.loop_max = 2
      let conv.s1.r$y.r9.loop_min = 0
      for (conv.s0.y, 0, 1) {
        for (conv.s0.x, 0, 1) {
          conv(conv.s0.x, conv.s0.y) = 0
        }
      }
      for (conv.s1.y, 0, 1) {
        for (conv.s1.x, 0, 1) {
          for (conv.s1.r$y.r$y, 0, 1) {
            let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
            unrolled (conv.s1.r$y.r9, 0, 3) {
              let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
              for (conv.s1.r$x.r$x, 0, 1) {
                let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
                unrolled (conv.s1.r$x.r8, 0, 3) {
                  let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
                  let conv.s1.r$y.max = conv.s1.r$y
                  let conv.s1.r$y.min = conv.s1.r$y
                  let conv.s1.r$x.max = conv.s1.r$x
                  let conv.s1.r$x.min = conv.s1.r$x
                  conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
                }
              }
            }
          }
        }
      }
    }
    consume conv {
      hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
    }
  }
}
saw this for loop hw_output.s0.y.yi while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.x.xi while compute=hw_output.s0.x.xi
let's save this input box num_dims=2 box=2
HWBuffer Parameter: conv input chunk size - box extent=[1:1-1 (0,0)  1:1-1 (0,0)  ]
saw this for loop conv.s0.y while compute=hw_output.s0.x.xi
saw this for loop conv.s0.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r$y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r9 while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r$x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r8 while compute=hw_output.s0.x.xi
the input chunk of conv at  is [1,1]
here we have consumer conv with 1 found
replaced min pos for conv 0 with 0
replaced output stencil for conv based on consumer conv
replaced input=1 and output=1
replaced min pos for conv 1 with 0
replaced output stencil for conv based on consumer conv
replaced input=1 and output=1
right before conv inputs
right before hw_output consumer of conv
adding conv as an input of hw_output
 size of consumer box is {[hw_output.s0.x.min, hw_output.s0.x.max], [hw_output.s0.y.min, hw_output.s0.y.max]}
 size of consumer box is (hw_output.s0.x.max - hw_output.s0.x.min)
for kernel conv, adding consumer hw_output based on kernel hw_output
conv compute loop is using hw_output.s0.x.xi based on func convcompute=loop_level(hw_output.xi)
looking to find conv output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yo has stride=0 in call for conv stride_map[y]=0
hw_output.s0.x.xo has stride=0 in call for conv stride_map[x]=0
kernel.s0.y has stride=0 in call for conv stride_map[y]=0
kernel.s0.x has stride=0 in call for conv stride_map[x]=0
hw_output.s0.y.yi has stride=1 in call for conv stride_map[y]=1
hw_output.s0.x.xi has stride=1 in call for conv stride_map[x]=1
conv found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: conv output stencil size - box extent=[((max((min(likely_if_innermost((hw_output.s0.x.xo*62)), 0) + hw_output.s0.x.xi), 0) - min((min(likely_if_innermost((hw_output.s0.x.xo*62)), 0) + hw_output.s0.x.xi), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0),min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))   using ((max((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0) - min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0)) + 1)
((max((min(likely_if_innermost((hw_output.s0.y.yo*62)), 0) + hw_output.s0.y.yi), 0) - min((min(likely_if_innermost((hw_output.s0.y.yo*62)), 0) + hw_output.s0.y.yi), 0)) + 1)?1:1-(undefined) (min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0),min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))   using ((max((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0) - min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0)) + 1)
]
conv.s0.y has stride=0 in call for conv stride_map[y]=1
conv.s0.x has stride=0 in call for conv stride_map[x]=1
conv.s1.y has stride=1 in call for conv stride_map[y]=1
conv.s1.x has stride=1 in call for conv stride_map[x]=1
conv.s1.r$y.r$y has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$y.r9 has stride=0 in call for conv stride_map[r$y]=0
conv.s1.r$x.r$x has stride=0 in call for conv stride_map[r$x]=0
conv.s1.r$x.r8 has stride=0 in call for conv stride_map[r$x]=0
output.s0.y has stride=0 in call for conv stride_map[y]=1
output.s0.x has stride=0 in call for conv stride_map[x]=1
conv stride_x=1
r$x,0
r$y,0
x,1
y,1
the output stencil of conv from hw_output at  is [1,1]
produce hw_output {
  let hw_output.s0.y.loop_max = 61
  let hw_output.s0.y.loop_min = 0
  let hw_output.s0.y.loop_extent = 62
  let hw_output.s0.x.loop_max = 61
  let hw_output.s0.x.loop_min = 0
  let hw_output.s0.x.loop_extent = 62
  let hw_output.s0.x.xo.loop_extent = 1
  let hw_output.s0.x.xo.loop_max = 0
  let hw_output.s0.x.xo.loop_min = 0
  let hw_output.s0.x.xi.loop_extent = 62
  let hw_output.s0.x.xi.loop_max = 61
  let hw_output.s0.x.xi.loop_min = 0
  let hw_output.s0.y.yo.loop_extent = 1
  let hw_output.s0.y.yo.loop_max = 0
  let hw_output.s0.y.yo.loop_min = 0
  let hw_output.s0.y.yi.loop_extent = 62
  let hw_output.s0.y.yi.loop_max = 61
  let hw_output.s0.y.yi.loop_min = 0
  for (hw_output.s0.y.yo, 0, 1) {
    let hw_output.s0.y.yi.base = min(likely_if_innermost((hw_output.s0.y.yo*62)), 0)
    for (hw_output.s0.x.xo, 0, 1) {
      let hw_output.s0.x.xi.base = min(likely_if_innermost((hw_output.s0.x.xo*62)), 0)
      let hw_output.s0.y.min = hw_output.s0.y.yi.base
      let hw_output.s0.y.max = (hw_output.s0.y.yi.base + 61)
      let hw_output.s0.x.min = hw_output.s0.x.xi.base
      let hw_output.s0.x.max = (hw_output.s0.x.xi.base + 61)
      let conv.s1.r$y.max = 2
      let conv.s1.r$y.min = 0
      let conv.s1.r$x.max = 2
      let conv.s1.r$x.min = 0
      let conv.s1.y.max = 61
      let conv.s1.y.min = 0
      let conv.s1.x.max = 61
      let conv.s1.x.min = 0
      let conv.s0.y.max = 61
      let conv.s0.y.min = 0
      let conv.s0.x.max = 61
      let conv.s0.x.min = 0
      let kernel.s9.y.max = 2
      let kernel.s9.y.min = 0
      let kernel.s9.x.max = 2
      let kernel.s9.x.min = 0
      let kernel.s8.y.max = 2
      let kernel.s8.y.min = 0
      let kernel.s8.x.max = 2
      let kernel.s8.x.min = 0
      let kernel.s7.y.max = 2
      let kernel.s7.y.min = 0
      let kernel.s7.x.max = 2
      let kernel.s7.x.min = 0
      let kernel.s6.y.max = 2
      let kernel.s6.y.min = 0
      let kernel.s6.x.max = 2
      let kernel.s6.x.min = 0
      let kernel.s5.y.max = 2
      let kernel.s5.y.min = 0
      let kernel.s5.x.max = 2
      let kernel.s5.x.min = 0
      let kernel.s4.y.max = 2
      let kernel.s4.y.min = 0
      let kernel.s4.x.max = 2
      let kernel.s4.x.min = 0
      let kernel.s3.y.max = 2
      let kernel.s3.y.min = 0
      let kernel.s3.x.max = 2
      let kernel.s3.x.min = 0
      let kernel.s2.y.max = 2
      let kernel.s2.y.min = 0
      let kernel.s2.x.max = 2
      let kernel.s2.x.min = 0
      let kernel.s1.y.max = 2
      let kernel.s1.y.min = 0
      let kernel.s1.x.max = 2
      let kernel.s1.x.min = 0
      let kernel.s0.y.max = 2
      let kernel.s0.y.min = 0
      let kernel.s0.x.max = 2
      let kernel.s0.x.min = 0
      let kernel.y.max_realized = 2
      let kernel.y.min_realized = 0
      let kernel.y.extent_realized = 3
      let kernel.x.max_realized = 2
      let kernel.x.min_realized = 0
      let kernel.x.extent_realized = 3
      realize kernel([0, 3], [0, 3]) {
        produce kernel {
          let kernel.s0.y.loop_max = 2
          let kernel.s0.y.loop_min = 0
          let kernel.s0.y.loop_extent = 3
          let kernel.s0.x.loop_max = 2
          let kernel.s0.x.loop_min = 0
          let kernel.s0.x.loop_extent = 3
          let kernel.s1.y.loop_max = 2
          let kernel.s1.y.loop_min = 0
          let kernel.s1.y.loop_extent = 3
          let kernel.s1.x.loop_max = 2
          let kernel.s1.x.loop_min = 0
          let kernel.s1.x.loop_extent = 3
          let kernel.s2.y.loop_max = 2
          let kernel.s2.y.loop_min = 0
          let kernel.s2.y.loop_extent = 3
          let kernel.s2.x.loop_max = 2
          let kernel.s2.x.loop_min = 0
          let kernel.s2.x.loop_extent = 3
          let kernel.s3.y.loop_max = 2
          let kernel.s3.y.loop_min = 0
          let kernel.s3.y.loop_extent = 3
          let kernel.s3.x.loop_max = 2
          let kernel.s3.x.loop_min = 0
          let kernel.s3.x.loop_extent = 3
          let kernel.s4.y.loop_max = 2
          let kernel.s4.y.loop_min = 0
          let kernel.s4.y.loop_extent = 3
          let kernel.s4.x.loop_max = 2
          let kernel.s4.x.loop_min = 0
          let kernel.s4.x.loop_extent = 3
          let kernel.s5.y.loop_max = 2
          let kernel.s5.y.loop_min = 0
          let kernel.s5.y.loop_extent = 3
          let kernel.s5.x.loop_max = 2
          let kernel.s5.x.loop_min = 0
          let kernel.s5.x.loop_extent = 3
          let kernel.s6.y.loop_max = 2
          let kernel.s6.y.loop_min = 0
          let kernel.s6.y.loop_extent = 3
          let kernel.s6.x.loop_max = 2
          let kernel.s6.x.loop_min = 0
          let kernel.s6.x.loop_extent = 3
          let kernel.s7.y.loop_max = 2
          let kernel.s7.y.loop_min = 0
          let kernel.s7.y.loop_extent = 3
          let kernel.s7.x.loop_max = 2
          let kernel.s7.x.loop_min = 0
          let kernel.s7.x.loop_extent = 3
          let kernel.s8.y.loop_max = 2
          let kernel.s8.y.loop_min = 0
          let kernel.s8.y.loop_extent = 3
          let kernel.s8.x.loop_max = 2
          let kernel.s8.x.loop_min = 0
          let kernel.s8.x.loop_extent = 3
          let kernel.s9.y.loop_max = 2
          let kernel.s9.y.loop_min = 0
          let kernel.s9.y.loop_extent = 3
          let kernel.s9.x.loop_max = 2
          let kernel.s9.x.loop_min = 0
          let kernel.s9.x.loop_extent = 3
          for (kernel.s0.y, 0, 3) {
            for (kernel.s0.x, 0, 3) {
              kernel(kernel.s0.x, kernel.s0.y) = 0
            }
          }
          kernel(0, 0) = 1
          kernel(0, 1) = 0
          kernel(0, 2) = 0
          kernel(1, 0) = 0
          kernel(1, 1) = 0
          kernel(1, 2) = 0
          kernel(2, 0) = 0
          kernel(2, 1) = 0
          kernel(2, 2) = 0
        }
        consume kernel {
          let conv.y.max_realized = (hw_output.s0.y.yi.base + 61)
          let conv.y.min_realized = hw_output.s0.y.yi.base
          let conv.y.extent_realized = 62
          let conv.x.max_realized = (hw_output.s0.x.xi.base + 61)
          let conv.x.min_realized = hw_output.s0.x.xi.base
          let conv.x.extent_realized = 62
          realize conv([conv.x.min_realized, 62], [conv.y.min_realized, 62]) {
            for (hw_output.s0.y.yi, 0, 62) {
              let hw_output.s0.y = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
              for (hw_output.s0.x.xi, 0, 62) {
                let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
                let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
                let hw_output.s0.y.max = 0
                let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
                let hw_output.s0.x.max = 0
                let conv.s1.r$y.max = 2
                let conv.s1.r$y.min = 0
                let conv.s1.r$x.max = 2
                let conv.s1.r$x.min = 0
                let conv.s1.y.max = 0
                let conv.s1.y.min = 0
                let conv.s1.x.max = 0
                let conv.s1.x.min = 0
                let conv.s0.y.max = 0
                let conv.s0.y.min = 0
                let conv.s0.x.max = 0
                let conv.s0.x.min = 0
                produce conv {
                  let conv.s0.y.loop_max = 0
                  let conv.s0.y.loop_min = 0
                  let conv.s0.y.loop_extent = 1
                  let conv.s0.x.loop_max = 0
                  let conv.s0.x.loop_min = 0
                  let conv.s0.x.loop_extent = 1
                  let conv.s1.r$y.loop_extent = 3
                  let conv.s1.r$y.loop_max = 2
                  let conv.s1.r$y.loop_min = 0
                  let conv.s1.r$x.loop_extent = 3
                  let conv.s1.r$x.loop_max = 2
                  let conv.s1.r$x.loop_min = 0
                  let conv.s1.y.loop_max = 0
                  let conv.s1.y.loop_min = 0
                  let conv.s1.y.loop_extent = 1
                  let conv.s1.x.loop_max = 0
                  let conv.s1.x.loop_min = 0
                  let conv.s1.x.loop_extent = 1
                  let conv.s1.r$x.r$x.loop_extent = 1
                  let conv.s1.r$x.r$x.loop_max = 0
                  let conv.s1.r$x.r$x.loop_min = 0
                  let conv.s1.r$x.r8.loop_extent = 3
                  let conv.s1.r$x.r8.loop_max = 2
                  let conv.s1.r$x.r8.loop_min = 0
                  let conv.s1.r$y.r$y.loop_extent = 1
                  let conv.s1.r$y.r$y.loop_max = 0
                  let conv.s1.r$y.r$y.loop_min = 0
                  let conv.s1.r$y.r9.loop_extent = 3
                  let conv.s1.r$y.r9.loop_max = 2
                  let conv.s1.r$y.r9.loop_min = 0
                  for (conv.s0.y, 0, 1) {
                    for (conv.s0.x, 0, 1) {
                      conv(conv.s0.x, conv.s0.y) = 0
                    }
                  }
                  for (conv.s1.y, 0, 1) {
                    for (conv.s1.x, 0, 1) {
                      for (conv.s1.r$y.r$y, 0, 1) {
                        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
                        unrolled (conv.s1.r$y.r9, 0, 3) {
                          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
                          for (conv.s1.r$x.r$x, 0, 1) {
                            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
                            unrolled (conv.s1.r$x.r8, 0, 3) {
                              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
                              let conv.s1.r$y.max = conv.s1.r$y
                              let conv.s1.r$y.min = conv.s1.r$y
                              let conv.s1.r$x.max = conv.s1.r$x
                              let conv.s1.r$x.min = conv.s1.r$x
                              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
                            }
                          }
                        }
                      }
                    }
                  }
                }
                consume conv {
                  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
                }
              }
            }
          }
        }
      }
    }
  }
}
consume hw_output {
  assert(((0 <= output.s0.y.min_unbounded) && (((62 + 0) - 1) >= output.s0.y.max_unbounded)), halide_error_explicit_bounds_too_small("y", "output", 0, ((62 + 0) - 1), output.s0.y.min_unbounded, output.s0.y.max_unbounded))
  assert(((0 <= output.s0.x.min_unbounded) && (((62 + 0) - 1) >= output.s0.x.max_unbounded)), halide_error_explicit_bounds_too_small("x", "output", 0, ((62 + 0) - 1), output.s0.x.min_unbounded, output.s0.x.max_unbounded))
  produce output {
    let output.s0.y.loop_max = 61
    let output.s0.y.loop_min = 0
    let output.s0.y.loop_extent = 62
    let output.s0.x.loop_max = 61
    let output.s0.x.loop_min = 0
    let output.s0.x.loop_extent = 62
    for (output.s0.y, 0, 62) {
      for (output.s0.x, 0, 62) {
        output(output.s0.x, output.s0.y) = hw_output(output.s0.x, output.s0.y)
      }
    }
  }
}
saw this for loop hw_output.s0.y.yi while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.x.xi while compute=hw_output.s0.x.xi
let's save this input box num_dims=2 box=2
HWBuffer Parameter: hw_output input chunk size - box extent=[1:1-1 ((hw_output.s0.x.xi + hw_output.s0.x.xi.base),(hw_output.s0.x.xi.base + hw_output.s0.x.xi))  1:1-1 ((hw_output.s0.y.yi + hw_output.s0.y.yi.base),(hw_output.s0.y.yi.base + hw_output.s0.y.yi))  ]
saw this for loop conv.s0.y while compute=hw_output.s0.x.xi
saw this for loop conv.s0.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r$y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r9 while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r$x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r8 while compute=hw_output.s0.x.xi
the input chunk of conv at  is [1,1]
here we have consumer hw_output with 1 found
replaced min pos for conv 0 with (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
replaced output stencil for conv based on consumer hw_output
replaced input=1 and output=1
replaced min pos for conv 1 with (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
replaced output stencil for conv based on consumer hw_output
replaced input=1 and output=1
right before hw_output inputs
conv,hw_input,hw_output,kernel,
there are 4 hwbuffers
looking for kernel
kernel before func
HWBuffer has 2 dims, while 
 loops are: []
 args are: [x,y]
finished is_output 1 consumers
kernel is inline=1 store=loop_level(hw_output.xo) compute=loop_level(hw_output.xo) is_xcel=0 is_hw_kernel=1
conv,
right before conv consumer of kernel
couldn't find consumer conv
 size of consumer box is {[conv.s1.r$x.min, conv.s1.r$x.max], [conv.s1.r$y.min, conv.s1.r$y.max]}
 size of consumer box is (conv.s1.r$x.max - conv.s1.r$x.min)
for kernel kernel, adding consumer conv based on kernel conv
kernel compute loop is using hw_output.s0.x.xi based on func kernelcompute=loop_level(hw_output.xo)
looking to find kernel output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yi has stride=0 in call for kernel stride_map[y]=0
hw_output.s0.x.xi has stride=0 in call for kernel stride_map[x]=0
kernel found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: kernel output stencil size - box extent=[3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
]
conv.s0.y has stride=0 in call for kernel stride_map[y]=0
conv.s0.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.y has stride=0 in call for kernel stride_map[y]=0
conv.s1.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.r$y.r$y has stride=0 in call for kernel stride_map[r$y]=0
conv.s1.r$y.r9 has stride=1 in call for kernel stride_map[r$y]=1
conv.s1.r$x.r$x has stride=0 in call for kernel stride_map[r$x]=0
conv.s1.r$x.r8 has stride=1 in call for kernel stride_map[r$x]=1
kernel stride_x=0
r$x,1
r$y,1
x,0
y,0
the output stencil of kernel from conv at hw_output.s0.x.xi is [3,3]
for (hw_output.s0.y.yi, 0, 62) {
  let hw_output.s0.y = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
  for (hw_output.s0.x.xi, 0, 62) {
    let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
    let hw_output.s0.y.max = 0
    let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.x.max = 0
    let conv.s1.r$y.max = 2
    let conv.s1.r$y.min = 0
    let conv.s1.r$x.max = 2
    let conv.s1.r$x.min = 0
    let conv.s1.y.max = 0
    let conv.s1.y.min = 0
    let conv.s1.x.max = 0
    let conv.s1.x.min = 0
    let conv.s0.y.max = 0
    let conv.s0.y.min = 0
    let conv.s0.x.max = 0
    let conv.s0.x.min = 0
    produce conv {
      let conv.s0.y.loop_max = 0
      let conv.s0.y.loop_min = 0
      let conv.s0.y.loop_extent = 1
      let conv.s0.x.loop_max = 0
      let conv.s0.x.loop_min = 0
      let conv.s0.x.loop_extent = 1
      let conv.s1.r$y.loop_extent = 3
      let conv.s1.r$y.loop_max = 2
      let conv.s1.r$y.loop_min = 0
      let conv.s1.r$x.loop_extent = 3
      let conv.s1.r$x.loop_max = 2
      let conv.s1.r$x.loop_min = 0
      let conv.s1.y.loop_max = 0
      let conv.s1.y.loop_min = 0
      let conv.s1.y.loop_extent = 1
      let conv.s1.x.loop_max = 0
      let conv.s1.x.loop_min = 0
      let conv.s1.x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_max = 0
      let conv.s1.r$x.r$x.loop_min = 0
      let conv.s1.r$x.r8.loop_extent = 3
      let conv.s1.r$x.r8.loop_max = 2
      let conv.s1.r$x.r8.loop_min = 0
      let conv.s1.r$y.r$y.loop_extent = 1
      let conv.s1.r$y.r$y.loop_max = 0
      let conv.s1.r$y.r$y.loop_min = 0
      let conv.s1.r$y.r9.loop_extent = 3
      let conv.s1.r$y.r9.loop_max = 2
      let conv.s1.r$y.r9.loop_min = 0
      for (conv.s0.y, 0, 1) {
        for (conv.s0.x, 0, 1) {
          conv(conv.s0.x, conv.s0.y) = 0
        }
      }
      for (conv.s1.y, 0, 1) {
        for (conv.s1.x, 0, 1) {
          for (conv.s1.r$y.r$y, 0, 1) {
            let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
            unrolled (conv.s1.r$y.r9, 0, 3) {
              let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
              for (conv.s1.r$x.r$x, 0, 1) {
                let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
                unrolled (conv.s1.r$x.r8, 0, 3) {
                  let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
                  let conv.s1.r$y.max = conv.s1.r$y
                  let conv.s1.r$y.min = conv.s1.r$y
                  let conv.s1.r$x.max = conv.s1.r$x
                  let conv.s1.r$x.min = conv.s1.r$x
                  conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
                }
              }
            }
          }
        }
      }
    }
    consume conv {
      hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
    }
  }
}
saw this for loop kernel.s0.y while compute=hw_output.s0.x.xi
saw this for loop kernel.s0.x while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.y.yi while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.x.xi while compute=hw_output.s0.x.xi
let's save this input box num_dims=2 box=2
HWBuffer Parameter: conv input chunk size - box extent=[1:1-1 (0,0)  1:1-1 (0,0)  ]
saw this for loop conv.s0.y while compute=hw_output.s0.x.xi
saw this for loop conv.s0.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r$y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r9 while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r$x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r8 while compute=hw_output.s0.x.xi
the input chunk of kernel at hw_output.s0.x.xi is [1,1]
here we have consumer conv with 1 found
replaced min pos for kernel 0 with 0
replaced output stencil for kernel based on consumer conv
replaced input=1 and output=3
replaced min pos for kernel 1 with 0
replaced output stencil for kernel based on consumer conv
replaced input=1 and output=3
right before conv inputs
conv,hw_input,hw_output,kernel,
there are 4 hwbuffers
looking for kernel
kernel before func
HWBuffer has 2 dims, while 
 loops are: []
 args are: [x,y]
finished is_output 1 consumers
kernel is inline=1 store=loop_level(hw_output.xo) compute=loop_level(hw_output.xo) is_xcel=0 is_hw_kernel=1
conv,
right before conv consumer of kernel
couldn't find consumer conv
 size of consumer box is {[conv.s1.r$x.min, conv.s1.r$x.max], [conv.s1.r$y.min, conv.s1.r$y.max]}
 size of consumer box is (conv.s1.r$x.max - conv.s1.r$x.min)
for kernel kernel, adding consumer conv based on kernel conv
kernel compute loop is using hw_output.s0.x.xi based on func kernelcompute=loop_level(hw_output.xo)
looking to find kernel output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yi has stride=0 in call for kernel stride_map[y]=0
hw_output.s0.x.xi has stride=0 in call for kernel stride_map[x]=0
kernel found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: kernel output stencil size - box extent=[3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
]
conv.s0.y has stride=0 in call for kernel stride_map[y]=0
conv.s0.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.y has stride=0 in call for kernel stride_map[y]=0
conv.s1.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.r$y.r$y has stride=0 in call for kernel stride_map[r$y]=0
conv.s1.r$y.r9 has stride=1 in call for kernel stride_map[r$y]=1
conv.s1.r$x.r$x has stride=0 in call for kernel stride_map[r$x]=0
conv.s1.r$x.r8 has stride=1 in call for kernel stride_map[r$x]=1
kernel stride_x=0
r$x,1
r$y,1
x,0
y,0
the output stencil of kernel from conv at hw_output.s0.x.xi is [3,3]
for (hw_output.s0.y.yi, 0, 62) {
  let hw_output.s0.y = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
  for (hw_output.s0.x.xi, 0, 62) {
    let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
    let hw_output.s0.y.max = 0
    let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.x.max = 0
    let conv.s1.r$y.max = 2
    let conv.s1.r$y.min = 0
    let conv.s1.r$x.max = 2
    let conv.s1.r$x.min = 0
    let conv.s1.y.max = 0
    let conv.s1.y.min = 0
    let conv.s1.x.max = 0
    let conv.s1.x.min = 0
    let conv.s0.y.max = 0
    let conv.s0.y.min = 0
    let conv.s0.x.max = 0
    let conv.s0.x.min = 0
    produce conv {
      let conv.s0.y.loop_max = 0
      let conv.s0.y.loop_min = 0
      let conv.s0.y.loop_extent = 1
      let conv.s0.x.loop_max = 0
      let conv.s0.x.loop_min = 0
      let conv.s0.x.loop_extent = 1
      let conv.s1.r$y.loop_extent = 3
      let conv.s1.r$y.loop_max = 2
      let conv.s1.r$y.loop_min = 0
      let conv.s1.r$x.loop_extent = 3
      let conv.s1.r$x.loop_max = 2
      let conv.s1.r$x.loop_min = 0
      let conv.s1.y.loop_max = 0
      let conv.s1.y.loop_min = 0
      let conv.s1.y.loop_extent = 1
      let conv.s1.x.loop_max = 0
      let conv.s1.x.loop_min = 0
      let conv.s1.x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_max = 0
      let conv.s1.r$x.r$x.loop_min = 0
      let conv.s1.r$x.r8.loop_extent = 3
      let conv.s1.r$x.r8.loop_max = 2
      let conv.s1.r$x.r8.loop_min = 0
      let conv.s1.r$y.r$y.loop_extent = 1
      let conv.s1.r$y.r$y.loop_max = 0
      let conv.s1.r$y.r$y.loop_min = 0
      let conv.s1.r$y.r9.loop_extent = 3
      let conv.s1.r$y.r9.loop_max = 2
      let conv.s1.r$y.r9.loop_min = 0
      for (conv.s0.y, 0, 1) {
        for (conv.s0.x, 0, 1) {
          conv(conv.s0.x, conv.s0.y) = 0
        }
      }
      for (conv.s1.y, 0, 1) {
        for (conv.s1.x, 0, 1) {
          for (conv.s1.r$y.r$y, 0, 1) {
            let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
            unrolled (conv.s1.r$y.r9, 0, 3) {
              let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
              for (conv.s1.r$x.r$x, 0, 1) {
                let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
                unrolled (conv.s1.r$x.r8, 0, 3) {
                  let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
                  let conv.s1.r$y.max = conv.s1.r$y
                  let conv.s1.r$y.min = conv.s1.r$y
                  let conv.s1.r$x.max = conv.s1.r$x
                  let conv.s1.r$x.min = conv.s1.r$x
                  conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
                }
              }
            }
          }
        }
      }
    }
    consume conv {
      hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
    }
  }
}
saw this for loop kernel.s0.y while compute=hw_output.s0.x.xi
saw this for loop kernel.s0.x while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.y.yi while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.x.xi while compute=hw_output.s0.x.xi
let's save this input box num_dims=2 box=2
HWBuffer Parameter: conv input chunk size - box extent=[1:1-1 (0,0)  1:1-1 (0,0)  ]
saw this for loop conv.s0.y while compute=hw_output.s0.x.xi
saw this for loop conv.s0.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r$y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r9 while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r$x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r8 while compute=hw_output.s0.x.xi
the input chunk of kernel at hw_output.s0.x.xi is [1,1]
here we have consumer conv with 1 found
replaced min pos for kernel 0 with 0
replaced output stencil for kernel based on consumer conv
replaced input=1 and output=3
replaced min pos for kernel 1 with 0
replaced output stencil for kernel based on consumer conv
replaced input=1 and output=3
right before conv inputs
conv,hw_input,hw_output,kernel,
there are 4 hwbuffers
looking for kernel
kernel before func
HWBuffer has 2 dims, while 
 loops are: []
 args are: [x,y]
finished is_output 1 consumers
kernel is inline=1 store=loop_level(hw_output.xo) compute=loop_level(hw_output.xo) is_xcel=0 is_hw_kernel=1
conv,
right before conv consumer of kernel
couldn't find consumer conv
 size of consumer box is {[conv.s1.r$x.min, conv.s1.r$x.max], [conv.s1.r$y.min, conv.s1.r$y.max]}
 size of consumer box is (conv.s1.r$x.max - conv.s1.r$x.min)
for kernel kernel, adding consumer conv based on kernel conv
kernel compute loop is using hw_output.s0.x.xi based on func kernelcompute=loop_level(hw_output.xo)
looking to find kernel output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yi has stride=0 in call for kernel stride_map[y]=0
hw_output.s0.x.xi has stride=0 in call for kernel stride_map[x]=0
kernel found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: kernel output stencil size - box extent=[3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
]
conv.s0.y has stride=0 in call for kernel stride_map[y]=0
conv.s0.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.y has stride=0 in call for kernel stride_map[y]=0
conv.s1.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.r$y.r$y has stride=0 in call for kernel stride_map[r$y]=0
conv.s1.r$y.r9 has stride=1 in call for kernel stride_map[r$y]=1
conv.s1.r$x.r$x has stride=0 in call for kernel stride_map[r$x]=0
conv.s1.r$x.r8 has stride=1 in call for kernel stride_map[r$x]=1
kernel stride_x=0
r$x,1
r$y,1
x,0
y,0
the output stencil of kernel from conv at hw_output.s0.x.xi is [3,3]
for (hw_output.s0.y.yi, 0, 62) {
  let hw_output.s0.y = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
  for (hw_output.s0.x.xi, 0, 62) {
    let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
    let hw_output.s0.y.max = 0
    let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.x.max = 0
    let conv.s1.r$y.max = 2
    let conv.s1.r$y.min = 0
    let conv.s1.r$x.max = 2
    let conv.s1.r$x.min = 0
    let conv.s1.y.max = 0
    let conv.s1.y.min = 0
    let conv.s1.x.max = 0
    let conv.s1.x.min = 0
    let conv.s0.y.max = 0
    let conv.s0.y.min = 0
    let conv.s0.x.max = 0
    let conv.s0.x.min = 0
    produce conv {
      let conv.s0.y.loop_max = 0
      let conv.s0.y.loop_min = 0
      let conv.s0.y.loop_extent = 1
      let conv.s0.x.loop_max = 0
      let conv.s0.x.loop_min = 0
      let conv.s0.x.loop_extent = 1
      let conv.s1.r$y.loop_extent = 3
      let conv.s1.r$y.loop_max = 2
      let conv.s1.r$y.loop_min = 0
      let conv.s1.r$x.loop_extent = 3
      let conv.s1.r$x.loop_max = 2
      let conv.s1.r$x.loop_min = 0
      let conv.s1.y.loop_max = 0
      let conv.s1.y.loop_min = 0
      let conv.s1.y.loop_extent = 1
      let conv.s1.x.loop_max = 0
      let conv.s1.x.loop_min = 0
      let conv.s1.x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_max = 0
      let conv.s1.r$x.r$x.loop_min = 0
      let conv.s1.r$x.r8.loop_extent = 3
      let conv.s1.r$x.r8.loop_max = 2
      let conv.s1.r$x.r8.loop_min = 0
      let conv.s1.r$y.r$y.loop_extent = 1
      let conv.s1.r$y.r$y.loop_max = 0
      let conv.s1.r$y.r$y.loop_min = 0
      let conv.s1.r$y.r9.loop_extent = 3
      let conv.s1.r$y.r9.loop_max = 2
      let conv.s1.r$y.r9.loop_min = 0
      for (conv.s0.y, 0, 1) {
        for (conv.s0.x, 0, 1) {
          conv(conv.s0.x, conv.s0.y) = 0
        }
      }
      for (conv.s1.y, 0, 1) {
        for (conv.s1.x, 0, 1) {
          for (conv.s1.r$y.r$y, 0, 1) {
            let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
            unrolled (conv.s1.r$y.r9, 0, 3) {
              let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
              for (conv.s1.r$x.r$x, 0, 1) {
                let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
                unrolled (conv.s1.r$x.r8, 0, 3) {
                  let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
                  let conv.s1.r$y.max = conv.s1.r$y
                  let conv.s1.r$y.min = conv.s1.r$y
                  let conv.s1.r$x.max = conv.s1.r$x
                  let conv.s1.r$x.min = conv.s1.r$x
                  conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
                }
              }
            }
          }
        }
      }
    }
    consume conv {
      hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
    }
  }
}
saw this for loop kernel.s0.y while compute=hw_output.s0.x.xi
saw this for loop kernel.s0.x while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.y.yi while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.x.xi while compute=hw_output.s0.x.xi
let's save this input box num_dims=2 box=2
HWBuffer Parameter: conv input chunk size - box extent=[1:1-1 (0,0)  1:1-1 (0,0)  ]
saw this for loop conv.s0.y while compute=hw_output.s0.x.xi
saw this for loop conv.s0.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r$y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r9 while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r$x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r8 while compute=hw_output.s0.x.xi
the input chunk of kernel at hw_output.s0.x.xi is [1,1]
here we have consumer conv with 1 found
replaced min pos for kernel 0 with 0
replaced output stencil for kernel based on consumer conv
replaced input=1 and output=3
replaced min pos for kernel 1 with 0
replaced output stencil for kernel based on consumer conv
replaced input=1 and output=3
right before conv inputs
conv,hw_input,hw_output,kernel,
there are 4 hwbuffers
looking for kernel
kernel before func
HWBuffer has 2 dims, while 
 loops are: []
 args are: [x,y]
finished is_output 1 consumers
kernel is inline=1 store=loop_level(hw_output.xo) compute=loop_level(hw_output.xo) is_xcel=0 is_hw_kernel=1
conv,
right before conv consumer of kernel
couldn't find consumer conv
 size of consumer box is {[conv.s1.r$x.min, conv.s1.r$x.max], [conv.s1.r$y.min, conv.s1.r$y.max]}
 size of consumer box is (conv.s1.r$x.max - conv.s1.r$x.min)
for kernel kernel, adding consumer conv based on kernel conv
kernel compute loop is using hw_output.s0.x.xi based on func kernelcompute=loop_level(hw_output.xo)
looking to find kernel output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yi has stride=0 in call for kernel stride_map[y]=0
hw_output.s0.x.xi has stride=0 in call for kernel stride_map[x]=0
kernel found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: kernel output stencil size - box extent=[3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
]
conv.s0.y has stride=0 in call for kernel stride_map[y]=0
conv.s0.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.y has stride=0 in call for kernel stride_map[y]=0
conv.s1.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.r$y.r$y has stride=0 in call for kernel stride_map[r$y]=0
conv.s1.r$y.r9 has stride=1 in call for kernel stride_map[r$y]=1
conv.s1.r$x.r$x has stride=0 in call for kernel stride_map[r$x]=0
conv.s1.r$x.r8 has stride=1 in call for kernel stride_map[r$x]=1
kernel stride_x=0
r$x,1
r$y,1
x,0
y,0
the output stencil of kernel from conv at hw_output.s0.x.xi is [3,3]
for (hw_output.s0.y.yi, 0, 62) {
  let hw_output.s0.y = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
  for (hw_output.s0.x.xi, 0, 62) {
    let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
    let hw_output.s0.y.max = 0
    let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.x.max = 0
    let conv.s1.r$y.max = 2
    let conv.s1.r$y.min = 0
    let conv.s1.r$x.max = 2
    let conv.s1.r$x.min = 0
    let conv.s1.y.max = 0
    let conv.s1.y.min = 0
    let conv.s1.x.max = 0
    let conv.s1.x.min = 0
    let conv.s0.y.max = 0
    let conv.s0.y.min = 0
    let conv.s0.x.max = 0
    let conv.s0.x.min = 0
    produce conv {
      let conv.s0.y.loop_max = 0
      let conv.s0.y.loop_min = 0
      let conv.s0.y.loop_extent = 1
      let conv.s0.x.loop_max = 0
      let conv.s0.x.loop_min = 0
      let conv.s0.x.loop_extent = 1
      let conv.s1.r$y.loop_extent = 3
      let conv.s1.r$y.loop_max = 2
      let conv.s1.r$y.loop_min = 0
      let conv.s1.r$x.loop_extent = 3
      let conv.s1.r$x.loop_max = 2
      let conv.s1.r$x.loop_min = 0
      let conv.s1.y.loop_max = 0
      let conv.s1.y.loop_min = 0
      let conv.s1.y.loop_extent = 1
      let conv.s1.x.loop_max = 0
      let conv.s1.x.loop_min = 0
      let conv.s1.x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_max = 0
      let conv.s1.r$x.r$x.loop_min = 0
      let conv.s1.r$x.r8.loop_extent = 3
      let conv.s1.r$x.r8.loop_max = 2
      let conv.s1.r$x.r8.loop_min = 0
      let conv.s1.r$y.r$y.loop_extent = 1
      let conv.s1.r$y.r$y.loop_max = 0
      let conv.s1.r$y.r$y.loop_min = 0
      let conv.s1.r$y.r9.loop_extent = 3
      let conv.s1.r$y.r9.loop_max = 2
      let conv.s1.r$y.r9.loop_min = 0
      for (conv.s0.y, 0, 1) {
        for (conv.s0.x, 0, 1) {
          conv(conv.s0.x, conv.s0.y) = 0
        }
      }
      for (conv.s1.y, 0, 1) {
        for (conv.s1.x, 0, 1) {
          for (conv.s1.r$y.r$y, 0, 1) {
            let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
            unrolled (conv.s1.r$y.r9, 0, 3) {
              let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
              for (conv.s1.r$x.r$x, 0, 1) {
                let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
                unrolled (conv.s1.r$x.r8, 0, 3) {
                  let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
                  let conv.s1.r$y.max = conv.s1.r$y
                  let conv.s1.r$y.min = conv.s1.r$y
                  let conv.s1.r$x.max = conv.s1.r$x
                  let conv.s1.r$x.min = conv.s1.r$x
                  conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
                }
              }
            }
          }
        }
      }
    }
    consume conv {
      hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
    }
  }
}
saw this for loop kernel.s0.y while compute=hw_output.s0.x.xi
saw this for loop kernel.s0.x while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.y.yi while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.x.xi while compute=hw_output.s0.x.xi
let's save this input box num_dims=2 box=2
HWBuffer Parameter: conv input chunk size - box extent=[1:1-1 (0,0)  1:1-1 (0,0)  ]
saw this for loop conv.s0.y while compute=hw_output.s0.x.xi
saw this for loop conv.s0.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r$y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r9 while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r$x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r8 while compute=hw_output.s0.x.xi
the input chunk of kernel at hw_output.s0.x.xi is [1,1]
here we have consumer conv with 1 found
replaced min pos for kernel 0 with 0
replaced output stencil for kernel based on consumer conv
replaced input=1 and output=3
replaced min pos for kernel 1 with 0
replaced output stencil for kernel based on consumer conv
replaced input=1 and output=3
right before conv inputs
conv,hw_input,hw_output,kernel,
there are 4 hwbuffers
looking for kernel
kernel before func
HWBuffer has 2 dims, while 
 loops are: []
 args are: [x,y]
finished is_output 1 consumers
kernel is inline=1 store=loop_level(hw_output.xo) compute=loop_level(hw_output.xo) is_xcel=0 is_hw_kernel=1
conv,
right before conv consumer of kernel
couldn't find consumer conv
 size of consumer box is {[conv.s1.r$x.min, conv.s1.r$x.max], [conv.s1.r$y.min, conv.s1.r$y.max]}
 size of consumer box is (conv.s1.r$x.max - conv.s1.r$x.min)
for kernel kernel, adding consumer conv based on kernel conv
kernel compute loop is using hw_output.s0.x.xi based on func kernelcompute=loop_level(hw_output.xo)
looking to find kernel output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yi has stride=0 in call for kernel stride_map[y]=0
hw_output.s0.x.xi has stride=0 in call for kernel stride_map[x]=0
kernel found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: kernel output stencil size - box extent=[3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
]
conv.s0.y has stride=0 in call for kernel stride_map[y]=0
conv.s0.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.y has stride=0 in call for kernel stride_map[y]=0
conv.s1.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.r$y.r$y has stride=0 in call for kernel stride_map[r$y]=0
conv.s1.r$y.r9 has stride=1 in call for kernel stride_map[r$y]=1
conv.s1.r$x.r$x has stride=0 in call for kernel stride_map[r$x]=0
conv.s1.r$x.r8 has stride=1 in call for kernel stride_map[r$x]=1
kernel stride_x=0
r$x,1
r$y,1
x,0
y,0
the output stencil of kernel from conv at hw_output.s0.x.xi is [3,3]
for (hw_output.s0.y.yi, 0, 62) {
  let hw_output.s0.y = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
  for (hw_output.s0.x.xi, 0, 62) {
    let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
    let hw_output.s0.y.max = 0
    let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.x.max = 0
    let conv.s1.r$y.max = 2
    let conv.s1.r$y.min = 0
    let conv.s1.r$x.max = 2
    let conv.s1.r$x.min = 0
    let conv.s1.y.max = 0
    let conv.s1.y.min = 0
    let conv.s1.x.max = 0
    let conv.s1.x.min = 0
    let conv.s0.y.max = 0
    let conv.s0.y.min = 0
    let conv.s0.x.max = 0
    let conv.s0.x.min = 0
    produce conv {
      let conv.s0.y.loop_max = 0
      let conv.s0.y.loop_min = 0
      let conv.s0.y.loop_extent = 1
      let conv.s0.x.loop_max = 0
      let conv.s0.x.loop_min = 0
      let conv.s0.x.loop_extent = 1
      let conv.s1.r$y.loop_extent = 3
      let conv.s1.r$y.loop_max = 2
      let conv.s1.r$y.loop_min = 0
      let conv.s1.r$x.loop_extent = 3
      let conv.s1.r$x.loop_max = 2
      let conv.s1.r$x.loop_min = 0
      let conv.s1.y.loop_max = 0
      let conv.s1.y.loop_min = 0
      let conv.s1.y.loop_extent = 1
      let conv.s1.x.loop_max = 0
      let conv.s1.x.loop_min = 0
      let conv.s1.x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_max = 0
      let conv.s1.r$x.r$x.loop_min = 0
      let conv.s1.r$x.r8.loop_extent = 3
      let conv.s1.r$x.r8.loop_max = 2
      let conv.s1.r$x.r8.loop_min = 0
      let conv.s1.r$y.r$y.loop_extent = 1
      let conv.s1.r$y.r$y.loop_max = 0
      let conv.s1.r$y.r$y.loop_min = 0
      let conv.s1.r$y.r9.loop_extent = 3
      let conv.s1.r$y.r9.loop_max = 2
      let conv.s1.r$y.r9.loop_min = 0
      for (conv.s0.y, 0, 1) {
        for (conv.s0.x, 0, 1) {
          conv(conv.s0.x, conv.s0.y) = 0
        }
      }
      for (conv.s1.y, 0, 1) {
        for (conv.s1.x, 0, 1) {
          for (conv.s1.r$y.r$y, 0, 1) {
            let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
            unrolled (conv.s1.r$y.r9, 0, 3) {
              let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
              for (conv.s1.r$x.r$x, 0, 1) {
                let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
                unrolled (conv.s1.r$x.r8, 0, 3) {
                  let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
                  let conv.s1.r$y.max = conv.s1.r$y
                  let conv.s1.r$y.min = conv.s1.r$y
                  let conv.s1.r$x.max = conv.s1.r$x
                  let conv.s1.r$x.min = conv.s1.r$x
                  conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
                }
              }
            }
          }
        }
      }
    }
    consume conv {
      hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
    }
  }
}
saw this for loop kernel.s0.y while compute=hw_output.s0.x.xi
saw this for loop kernel.s0.x while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.y.yi while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.x.xi while compute=hw_output.s0.x.xi
let's save this input box num_dims=2 box=2
HWBuffer Parameter: conv input chunk size - box extent=[1:1-1 (0,0)  1:1-1 (0,0)  ]
saw this for loop conv.s0.y while compute=hw_output.s0.x.xi
saw this for loop conv.s0.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r$y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r9 while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r$x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r8 while compute=hw_output.s0.x.xi
the input chunk of kernel at hw_output.s0.x.xi is [1,1]
here we have consumer conv with 1 found
replaced min pos for kernel 0 with 0
replaced output stencil for kernel based on consumer conv
replaced input=1 and output=3
replaced min pos for kernel 1 with 0
replaced output stencil for kernel based on consumer conv
replaced input=1 and output=3
right before conv inputs
conv,hw_input,hw_output,kernel,
there are 4 hwbuffers
looking for kernel
kernel before func
HWBuffer has 2 dims, while 
 loops are: []
 args are: [x,y]
finished is_output 1 consumers
kernel is inline=1 store=loop_level(hw_output.xo) compute=loop_level(hw_output.xo) is_xcel=0 is_hw_kernel=1
conv,
right before conv consumer of kernel
couldn't find consumer conv
 size of consumer box is {[conv.s1.r$x.min, conv.s1.r$x.max], [conv.s1.r$y.min, conv.s1.r$y.max]}
 size of consumer box is (conv.s1.r$x.max - conv.s1.r$x.min)
for kernel kernel, adding consumer conv based on kernel conv
kernel compute loop is using hw_output.s0.x.xi based on func kernelcompute=loop_level(hw_output.xo)
looking to find kernel output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yi has stride=0 in call for kernel stride_map[y]=0
hw_output.s0.x.xi has stride=0 in call for kernel stride_map[x]=0
kernel found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: kernel output stencil size - box extent=[3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
]
conv.s0.y has stride=0 in call for kernel stride_map[y]=0
conv.s0.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.y has stride=0 in call for kernel stride_map[y]=0
conv.s1.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.r$y.r$y has stride=0 in call for kernel stride_map[r$y]=0
conv.s1.r$y.r9 has stride=1 in call for kernel stride_map[r$y]=1
conv.s1.r$x.r$x has stride=0 in call for kernel stride_map[r$x]=0
conv.s1.r$x.r8 has stride=1 in call for kernel stride_map[r$x]=1
kernel stride_x=0
r$x,1
r$y,1
x,0
y,0
the output stencil of kernel from conv at hw_output.s0.x.xi is [3,3]
for (hw_output.s0.y.yi, 0, 62) {
  let hw_output.s0.y = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
  for (hw_output.s0.x.xi, 0, 62) {
    let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
    let hw_output.s0.y.max = 0
    let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.x.max = 0
    let conv.s1.r$y.max = 2
    let conv.s1.r$y.min = 0
    let conv.s1.r$x.max = 2
    let conv.s1.r$x.min = 0
    let conv.s1.y.max = 0
    let conv.s1.y.min = 0
    let conv.s1.x.max = 0
    let conv.s1.x.min = 0
    let conv.s0.y.max = 0
    let conv.s0.y.min = 0
    let conv.s0.x.max = 0
    let conv.s0.x.min = 0
    produce conv {
      let conv.s0.y.loop_max = 0
      let conv.s0.y.loop_min = 0
      let conv.s0.y.loop_extent = 1
      let conv.s0.x.loop_max = 0
      let conv.s0.x.loop_min = 0
      let conv.s0.x.loop_extent = 1
      let conv.s1.r$y.loop_extent = 3
      let conv.s1.r$y.loop_max = 2
      let conv.s1.r$y.loop_min = 0
      let conv.s1.r$x.loop_extent = 3
      let conv.s1.r$x.loop_max = 2
      let conv.s1.r$x.loop_min = 0
      let conv.s1.y.loop_max = 0
      let conv.s1.y.loop_min = 0
      let conv.s1.y.loop_extent = 1
      let conv.s1.x.loop_max = 0
      let conv.s1.x.loop_min = 0
      let conv.s1.x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_max = 0
      let conv.s1.r$x.r$x.loop_min = 0
      let conv.s1.r$x.r8.loop_extent = 3
      let conv.s1.r$x.r8.loop_max = 2
      let conv.s1.r$x.r8.loop_min = 0
      let conv.s1.r$y.r$y.loop_extent = 1
      let conv.s1.r$y.r$y.loop_max = 0
      let conv.s1.r$y.r$y.loop_min = 0
      let conv.s1.r$y.r9.loop_extent = 3
      let conv.s1.r$y.r9.loop_max = 2
      let conv.s1.r$y.r9.loop_min = 0
      for (conv.s0.y, 0, 1) {
        for (conv.s0.x, 0, 1) {
          conv(conv.s0.x, conv.s0.y) = 0
        }
      }
      for (conv.s1.y, 0, 1) {
        for (conv.s1.x, 0, 1) {
          for (conv.s1.r$y.r$y, 0, 1) {
            let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
            unrolled (conv.s1.r$y.r9, 0, 3) {
              let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
              for (conv.s1.r$x.r$x, 0, 1) {
                let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
                unrolled (conv.s1.r$x.r8, 0, 3) {
                  let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
                  let conv.s1.r$y.max = conv.s1.r$y
                  let conv.s1.r$y.min = conv.s1.r$y
                  let conv.s1.r$x.max = conv.s1.r$x
                  let conv.s1.r$x.min = conv.s1.r$x
                  conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
                }
              }
            }
          }
        }
      }
    }
    consume conv {
      hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
    }
  }
}
saw this for loop kernel.s0.y while compute=hw_output.s0.x.xi
saw this for loop kernel.s0.x while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.y.yi while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.x.xi while compute=hw_output.s0.x.xi
let's save this input box num_dims=2 box=2
HWBuffer Parameter: conv input chunk size - box extent=[1:1-1 (0,0)  1:1-1 (0,0)  ]
saw this for loop conv.s0.y while compute=hw_output.s0.x.xi
saw this for loop conv.s0.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r$y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r9 while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r$x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r8 while compute=hw_output.s0.x.xi
the input chunk of kernel at hw_output.s0.x.xi is [1,1]
here we have consumer conv with 1 found
replaced min pos for kernel 0 with 0
replaced output stencil for kernel based on consumer conv
replaced input=1 and output=3
replaced min pos for kernel 1 with 0
replaced output stencil for kernel based on consumer conv
replaced input=1 and output=3
right before conv inputs
conv,hw_input,hw_output,kernel,
there are 4 hwbuffers
looking for kernel
kernel before func
HWBuffer has 2 dims, while 
 loops are: []
 args are: [x,y]
finished is_output 1 consumers
kernel is inline=1 store=loop_level(hw_output.xo) compute=loop_level(hw_output.xo) is_xcel=0 is_hw_kernel=1
conv,
right before conv consumer of kernel
couldn't find consumer conv
 size of consumer box is {[conv.s1.r$x.min, conv.s1.r$x.max], [conv.s1.r$y.min, conv.s1.r$y.max]}
 size of consumer box is (conv.s1.r$x.max - conv.s1.r$x.min)
for kernel kernel, adding consumer conv based on kernel conv
kernel compute loop is using hw_output.s0.x.xi based on func kernelcompute=loop_level(hw_output.xo)
looking to find kernel output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yi has stride=0 in call for kernel stride_map[y]=0
hw_output.s0.x.xi has stride=0 in call for kernel stride_map[x]=0
kernel found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: kernel output stencil size - box extent=[3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
]
conv.s0.y has stride=0 in call for kernel stride_map[y]=0
conv.s0.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.y has stride=0 in call for kernel stride_map[y]=0
conv.s1.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.r$y.r$y has stride=0 in call for kernel stride_map[r$y]=0
conv.s1.r$y.r9 has stride=1 in call for kernel stride_map[r$y]=1
conv.s1.r$x.r$x has stride=0 in call for kernel stride_map[r$x]=0
conv.s1.r$x.r8 has stride=1 in call for kernel stride_map[r$x]=1
kernel stride_x=0
r$x,1
r$y,1
x,0
y,0
the output stencil of kernel from conv at hw_output.s0.x.xi is [3,3]
for (hw_output.s0.y.yi, 0, 62) {
  let hw_output.s0.y = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
  for (hw_output.s0.x.xi, 0, 62) {
    let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
    let hw_output.s0.y.max = 0
    let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.x.max = 0
    let conv.s1.r$y.max = 2
    let conv.s1.r$y.min = 0
    let conv.s1.r$x.max = 2
    let conv.s1.r$x.min = 0
    let conv.s1.y.max = 0
    let conv.s1.y.min = 0
    let conv.s1.x.max = 0
    let conv.s1.x.min = 0
    let conv.s0.y.max = 0
    let conv.s0.y.min = 0
    let conv.s0.x.max = 0
    let conv.s0.x.min = 0
    produce conv {
      let conv.s0.y.loop_max = 0
      let conv.s0.y.loop_min = 0
      let conv.s0.y.loop_extent = 1
      let conv.s0.x.loop_max = 0
      let conv.s0.x.loop_min = 0
      let conv.s0.x.loop_extent = 1
      let conv.s1.r$y.loop_extent = 3
      let conv.s1.r$y.loop_max = 2
      let conv.s1.r$y.loop_min = 0
      let conv.s1.r$x.loop_extent = 3
      let conv.s1.r$x.loop_max = 2
      let conv.s1.r$x.loop_min = 0
      let conv.s1.y.loop_max = 0
      let conv.s1.y.loop_min = 0
      let conv.s1.y.loop_extent = 1
      let conv.s1.x.loop_max = 0
      let conv.s1.x.loop_min = 0
      let conv.s1.x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_max = 0
      let conv.s1.r$x.r$x.loop_min = 0
      let conv.s1.r$x.r8.loop_extent = 3
      let conv.s1.r$x.r8.loop_max = 2
      let conv.s1.r$x.r8.loop_min = 0
      let conv.s1.r$y.r$y.loop_extent = 1
      let conv.s1.r$y.r$y.loop_max = 0
      let conv.s1.r$y.r$y.loop_min = 0
      let conv.s1.r$y.r9.loop_extent = 3
      let conv.s1.r$y.r9.loop_max = 2
      let conv.s1.r$y.r9.loop_min = 0
      for (conv.s0.y, 0, 1) {
        for (conv.s0.x, 0, 1) {
          conv(conv.s0.x, conv.s0.y) = 0
        }
      }
      for (conv.s1.y, 0, 1) {
        for (conv.s1.x, 0, 1) {
          for (conv.s1.r$y.r$y, 0, 1) {
            let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
            unrolled (conv.s1.r$y.r9, 0, 3) {
              let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
              for (conv.s1.r$x.r$x, 0, 1) {
                let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
                unrolled (conv.s1.r$x.r8, 0, 3) {
                  let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
                  let conv.s1.r$y.max = conv.s1.r$y
                  let conv.s1.r$y.min = conv.s1.r$y
                  let conv.s1.r$x.max = conv.s1.r$x
                  let conv.s1.r$x.min = conv.s1.r$x
                  conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
                }
              }
            }
          }
        }
      }
    }
    consume conv {
      hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
    }
  }
}
saw this for loop kernel.s0.y while compute=hw_output.s0.x.xi
saw this for loop kernel.s0.x while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.y.yi while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.x.xi while compute=hw_output.s0.x.xi
let's save this input box num_dims=2 box=2
HWBuffer Parameter: conv input chunk size - box extent=[1:1-1 (0,0)  1:1-1 (0,0)  ]
saw this for loop conv.s0.y while compute=hw_output.s0.x.xi
saw this for loop conv.s0.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r$y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r9 while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r$x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r8 while compute=hw_output.s0.x.xi
the input chunk of kernel at hw_output.s0.x.xi is [1,1]
here we have consumer conv with 1 found
replaced min pos for kernel 0 with 0
replaced output stencil for kernel based on consumer conv
replaced input=1 and output=3
replaced min pos for kernel 1 with 0
replaced output stencil for kernel based on consumer conv
replaced input=1 and output=3
right before conv inputs
conv,hw_input,hw_output,kernel,
there are 4 hwbuffers
looking for kernel
kernel before func
HWBuffer has 2 dims, while 
 loops are: []
 args are: [x,y]
finished is_output 1 consumers
kernel is inline=1 store=loop_level(hw_output.xo) compute=loop_level(hw_output.xo) is_xcel=0 is_hw_kernel=1
conv,
right before conv consumer of kernel
couldn't find consumer conv
 size of consumer box is {[conv.s1.r$x.min, conv.s1.r$x.max], [conv.s1.r$y.min, conv.s1.r$y.max]}
 size of consumer box is (conv.s1.r$x.max - conv.s1.r$x.min)
for kernel kernel, adding consumer conv based on kernel conv
kernel compute loop is using hw_output.s0.x.xi based on func kernelcompute=loop_level(hw_output.xo)
looking to find kernel output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yi has stride=0 in call for kernel stride_map[y]=0
hw_output.s0.x.xi has stride=0 in call for kernel stride_map[x]=0
kernel found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: kernel output stencil size - box extent=[3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
]
conv.s0.y has stride=0 in call for kernel stride_map[y]=0
conv.s0.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.y has stride=0 in call for kernel stride_map[y]=0
conv.s1.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.r$y.r$y has stride=0 in call for kernel stride_map[r$y]=0
conv.s1.r$y.r9 has stride=1 in call for kernel stride_map[r$y]=1
conv.s1.r$x.r$x has stride=0 in call for kernel stride_map[r$x]=0
conv.s1.r$x.r8 has stride=1 in call for kernel stride_map[r$x]=1
kernel stride_x=0
r$x,1
r$y,1
x,0
y,0
the output stencil of kernel from conv at hw_output.s0.x.xi is [3,3]
for (hw_output.s0.y.yi, 0, 62) {
  let hw_output.s0.y = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
  for (hw_output.s0.x.xi, 0, 62) {
    let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
    let hw_output.s0.y.max = 0
    let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.x.max = 0
    let conv.s1.r$y.max = 2
    let conv.s1.r$y.min = 0
    let conv.s1.r$x.max = 2
    let conv.s1.r$x.min = 0
    let conv.s1.y.max = 0
    let conv.s1.y.min = 0
    let conv.s1.x.max = 0
    let conv.s1.x.min = 0
    let conv.s0.y.max = 0
    let conv.s0.y.min = 0
    let conv.s0.x.max = 0
    let conv.s0.x.min = 0
    produce conv {
      let conv.s0.y.loop_max = 0
      let conv.s0.y.loop_min = 0
      let conv.s0.y.loop_extent = 1
      let conv.s0.x.loop_max = 0
      let conv.s0.x.loop_min = 0
      let conv.s0.x.loop_extent = 1
      let conv.s1.r$y.loop_extent = 3
      let conv.s1.r$y.loop_max = 2
      let conv.s1.r$y.loop_min = 0
      let conv.s1.r$x.loop_extent = 3
      let conv.s1.r$x.loop_max = 2
      let conv.s1.r$x.loop_min = 0
      let conv.s1.y.loop_max = 0
      let conv.s1.y.loop_min = 0
      let conv.s1.y.loop_extent = 1
      let conv.s1.x.loop_max = 0
      let conv.s1.x.loop_min = 0
      let conv.s1.x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_max = 0
      let conv.s1.r$x.r$x.loop_min = 0
      let conv.s1.r$x.r8.loop_extent = 3
      let conv.s1.r$x.r8.loop_max = 2
      let conv.s1.r$x.r8.loop_min = 0
      let conv.s1.r$y.r$y.loop_extent = 1
      let conv.s1.r$y.r$y.loop_max = 0
      let conv.s1.r$y.r$y.loop_min = 0
      let conv.s1.r$y.r9.loop_extent = 3
      let conv.s1.r$y.r9.loop_max = 2
      let conv.s1.r$y.r9.loop_min = 0
      for (conv.s0.y, 0, 1) {
        for (conv.s0.x, 0, 1) {
          conv(conv.s0.x, conv.s0.y) = 0
        }
      }
      for (conv.s1.y, 0, 1) {
        for (conv.s1.x, 0, 1) {
          for (conv.s1.r$y.r$y, 0, 1) {
            let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
            unrolled (conv.s1.r$y.r9, 0, 3) {
              let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
              for (conv.s1.r$x.r$x, 0, 1) {
                let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
                unrolled (conv.s1.r$x.r8, 0, 3) {
                  let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
                  let conv.s1.r$y.max = conv.s1.r$y
                  let conv.s1.r$y.min = conv.s1.r$y
                  let conv.s1.r$x.max = conv.s1.r$x
                  let conv.s1.r$x.min = conv.s1.r$x
                  conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
                }
              }
            }
          }
        }
      }
    }
    consume conv {
      hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
    }
  }
}
saw this for loop kernel.s0.y while compute=hw_output.s0.x.xi
saw this for loop kernel.s0.x while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.y.yi while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.x.xi while compute=hw_output.s0.x.xi
let's save this input box num_dims=2 box=2
HWBuffer Parameter: conv input chunk size - box extent=[1:1-1 (0,0)  1:1-1 (0,0)  ]
saw this for loop conv.s0.y while compute=hw_output.s0.x.xi
saw this for loop conv.s0.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r$y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r9 while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r$x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r8 while compute=hw_output.s0.x.xi
the input chunk of kernel at hw_output.s0.x.xi is [1,1]
here we have consumer conv with 1 found
replaced min pos for kernel 0 with 0
replaced output stencil for kernel based on consumer conv
replaced input=1 and output=3
replaced min pos for kernel 1 with 0
replaced output stencil for kernel based on consumer conv
replaced input=1 and output=3
right before conv inputs
conv,hw_input,hw_output,kernel,
there are 4 hwbuffers
looking for kernel
kernel before func
HWBuffer has 2 dims, while 
 loops are: []
 args are: [x,y]
finished is_output 1 consumers
kernel is inline=1 store=loop_level(hw_output.xo) compute=loop_level(hw_output.xo) is_xcel=0 is_hw_kernel=1
conv,
right before conv consumer of kernel
couldn't find consumer conv
 size of consumer box is {[conv.s1.r$x.min, conv.s1.r$x.max], [conv.s1.r$y.min, conv.s1.r$y.max]}
 size of consumer box is (conv.s1.r$x.max - conv.s1.r$x.min)
for kernel kernel, adding consumer conv based on kernel conv
kernel compute loop is using hw_output.s0.x.xi based on func kernelcompute=loop_level(hw_output.xo)
looking to find kernel output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yi has stride=0 in call for kernel stride_map[y]=0
hw_output.s0.x.xi has stride=0 in call for kernel stride_map[x]=0
kernel found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: kernel output stencil size - box extent=[3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
]
conv.s0.y has stride=0 in call for kernel stride_map[y]=0
conv.s0.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.y has stride=0 in call for kernel stride_map[y]=0
conv.s1.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.r$y.r$y has stride=0 in call for kernel stride_map[r$y]=0
conv.s1.r$y.r9 has stride=1 in call for kernel stride_map[r$y]=1
conv.s1.r$x.r$x has stride=0 in call for kernel stride_map[r$x]=0
conv.s1.r$x.r8 has stride=1 in call for kernel stride_map[r$x]=1
kernel stride_x=0
r$x,1
r$y,1
x,0
y,0
the output stencil of kernel from conv at hw_output.s0.x.xi is [3,3]
for (hw_output.s0.y.yi, 0, 62) {
  let hw_output.s0.y = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
  for (hw_output.s0.x.xi, 0, 62) {
    let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
    let hw_output.s0.y.max = 0
    let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.x.max = 0
    let conv.s1.r$y.max = 2
    let conv.s1.r$y.min = 0
    let conv.s1.r$x.max = 2
    let conv.s1.r$x.min = 0
    let conv.s1.y.max = 0
    let conv.s1.y.min = 0
    let conv.s1.x.max = 0
    let conv.s1.x.min = 0
    let conv.s0.y.max = 0
    let conv.s0.y.min = 0
    let conv.s0.x.max = 0
    let conv.s0.x.min = 0
    produce conv {
      let conv.s0.y.loop_max = 0
      let conv.s0.y.loop_min = 0
      let conv.s0.y.loop_extent = 1
      let conv.s0.x.loop_max = 0
      let conv.s0.x.loop_min = 0
      let conv.s0.x.loop_extent = 1
      let conv.s1.r$y.loop_extent = 3
      let conv.s1.r$y.loop_max = 2
      let conv.s1.r$y.loop_min = 0
      let conv.s1.r$x.loop_extent = 3
      let conv.s1.r$x.loop_max = 2
      let conv.s1.r$x.loop_min = 0
      let conv.s1.y.loop_max = 0
      let conv.s1.y.loop_min = 0
      let conv.s1.y.loop_extent = 1
      let conv.s1.x.loop_max = 0
      let conv.s1.x.loop_min = 0
      let conv.s1.x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_max = 0
      let conv.s1.r$x.r$x.loop_min = 0
      let conv.s1.r$x.r8.loop_extent = 3
      let conv.s1.r$x.r8.loop_max = 2
      let conv.s1.r$x.r8.loop_min = 0
      let conv.s1.r$y.r$y.loop_extent = 1
      let conv.s1.r$y.r$y.loop_max = 0
      let conv.s1.r$y.r$y.loop_min = 0
      let conv.s1.r$y.r9.loop_extent = 3
      let conv.s1.r$y.r9.loop_max = 2
      let conv.s1.r$y.r9.loop_min = 0
      for (conv.s0.y, 0, 1) {
        for (conv.s0.x, 0, 1) {
          conv(conv.s0.x, conv.s0.y) = 0
        }
      }
      for (conv.s1.y, 0, 1) {
        for (conv.s1.x, 0, 1) {
          for (conv.s1.r$y.r$y, 0, 1) {
            let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
            unrolled (conv.s1.r$y.r9, 0, 3) {
              let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
              for (conv.s1.r$x.r$x, 0, 1) {
                let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
                unrolled (conv.s1.r$x.r8, 0, 3) {
                  let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
                  let conv.s1.r$y.max = conv.s1.r$y
                  let conv.s1.r$y.min = conv.s1.r$y
                  let conv.s1.r$x.max = conv.s1.r$x
                  let conv.s1.r$x.min = conv.s1.r$x
                  conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
                }
              }
            }
          }
        }
      }
    }
    consume conv {
      hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
    }
  }
}
saw this for loop kernel.s0.y while compute=hw_output.s0.x.xi
saw this for loop kernel.s0.x while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.y.yi while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.x.xi while compute=hw_output.s0.x.xi
let's save this input box num_dims=2 box=2
HWBuffer Parameter: conv input chunk size - box extent=[1:1-1 (0,0)  1:1-1 (0,0)  ]
saw this for loop conv.s0.y while compute=hw_output.s0.x.xi
saw this for loop conv.s0.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r$y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r9 while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r$x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r8 while compute=hw_output.s0.x.xi
the input chunk of kernel at hw_output.s0.x.xi is [1,1]
here we have consumer conv with 1 found
replaced min pos for kernel 0 with 0
replaced output stencil for kernel based on consumer conv
replaced input=1 and output=3
replaced min pos for kernel 1 with 0
replaced output stencil for kernel based on consumer conv
replaced input=1 and output=3
right before conv inputs
conv,hw_input,hw_output,kernel,
there are 4 hwbuffers
looking for kernel
kernel before func
HWBuffer has 2 dims, while 
 loops are: []
 args are: [x,y]
finished is_output 1 consumers
kernel is inline=1 store=loop_level(hw_output.xo) compute=loop_level(hw_output.xo) is_xcel=0 is_hw_kernel=1
conv,
right before conv consumer of kernel
couldn't find consumer conv
 size of consumer box is {[conv.s1.r$x.min, conv.s1.r$x.max], [conv.s1.r$y.min, conv.s1.r$y.max]}
 size of consumer box is (conv.s1.r$x.max - conv.s1.r$x.min)
for kernel kernel, adding consumer conv based on kernel conv
kernel compute loop is using hw_output.s0.x.xi based on func kernelcompute=loop_level(hw_output.xo)
looking to find kernel output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yi has stride=0 in call for kernel stride_map[y]=0
hw_output.s0.x.xi has stride=0 in call for kernel stride_map[x]=0
kernel found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: kernel output stencil size - box extent=[3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
3?1:3-3 ((0 + 0),(0 + 0))   using (((0 + 2) - (0 + 0)) + 1)
]
conv.s0.y has stride=0 in call for kernel stride_map[y]=0
conv.s0.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.y has stride=0 in call for kernel stride_map[y]=0
conv.s1.x has stride=0 in call for kernel stride_map[x]=0
conv.s1.r$y.r$y has stride=0 in call for kernel stride_map[r$y]=0
conv.s1.r$y.r9 has stride=1 in call for kernel stride_map[r$y]=1
conv.s1.r$x.r$x has stride=0 in call for kernel stride_map[r$x]=0
conv.s1.r$x.r8 has stride=1 in call for kernel stride_map[r$x]=1
kernel stride_x=0
r$x,1
r$y,1
x,0
y,0
the output stencil of kernel from conv at hw_output.s0.x.xi is [3,3]
for (hw_output.s0.y.yi, 0, 62) {
  let hw_output.s0.y = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
  for (hw_output.s0.x.xi, 0, 62) {
    let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
    let hw_output.s0.y.max = 0
    let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.x.max = 0
    let conv.s1.r$y.max = 2
    let conv.s1.r$y.min = 0
    let conv.s1.r$x.max = 2
    let conv.s1.r$x.min = 0
    let conv.s1.y.max = 0
    let conv.s1.y.min = 0
    let conv.s1.x.max = 0
    let conv.s1.x.min = 0
    let conv.s0.y.max = 0
    let conv.s0.y.min = 0
    let conv.s0.x.max = 0
    let conv.s0.x.min = 0
    produce conv {
      let conv.s0.y.loop_max = 0
      let conv.s0.y.loop_min = 0
      let conv.s0.y.loop_extent = 1
      let conv.s0.x.loop_max = 0
      let conv.s0.x.loop_min = 0
      let conv.s0.x.loop_extent = 1
      let conv.s1.r$y.loop_extent = 3
      let conv.s1.r$y.loop_max = 2
      let conv.s1.r$y.loop_min = 0
      let conv.s1.r$x.loop_extent = 3
      let conv.s1.r$x.loop_max = 2
      let conv.s1.r$x.loop_min = 0
      let conv.s1.y.loop_max = 0
      let conv.s1.y.loop_min = 0
      let conv.s1.y.loop_extent = 1
      let conv.s1.x.loop_max = 0
      let conv.s1.x.loop_min = 0
      let conv.s1.x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_max = 0
      let conv.s1.r$x.r$x.loop_min = 0
      let conv.s1.r$x.r8.loop_extent = 3
      let conv.s1.r$x.r8.loop_max = 2
      let conv.s1.r$x.r8.loop_min = 0
      let conv.s1.r$y.r$y.loop_extent = 1
      let conv.s1.r$y.r$y.loop_max = 0
      let conv.s1.r$y.r$y.loop_min = 0
      let conv.s1.r$y.r9.loop_extent = 3
      let conv.s1.r$y.r9.loop_max = 2
      let conv.s1.r$y.r9.loop_min = 0
      for (conv.s0.y, 0, 1) {
        for (conv.s0.x, 0, 1) {
          conv(conv.s0.x, conv.s0.y) = 0
        }
      }
      for (conv.s1.y, 0, 1) {
        for (conv.s1.x, 0, 1) {
          for (conv.s1.r$y.r$y, 0, 1) {
            let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
            unrolled (conv.s1.r$y.r9, 0, 3) {
              let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
              for (conv.s1.r$x.r$x, 0, 1) {
                let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
                unrolled (conv.s1.r$x.r8, 0, 3) {
                  let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
                  let conv.s1.r$y.max = conv.s1.r$y
                  let conv.s1.r$y.min = conv.s1.r$y
                  let conv.s1.r$x.max = conv.s1.r$x
                  let conv.s1.r$x.min = conv.s1.r$x
                  conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
                }
              }
            }
          }
        }
      }
    }
    consume conv {
      hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
    }
  }
}
saw this for loop kernel.s0.y while compute=hw_output.s0.x.xi
saw this for loop kernel.s0.x while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.y.yi while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.x.xi while compute=hw_output.s0.x.xi
let's save this input box num_dims=2 box=2
HWBuffer Parameter: conv input chunk size - box extent=[1:1-1 (0,0)  1:1-1 (0,0)  ]
saw this for loop conv.s0.y while compute=hw_output.s0.x.xi
saw this for loop conv.s0.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r$y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r9 while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r$x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r8 while compute=hw_output.s0.x.xi
the input chunk of kernel at hw_output.s0.x.xi is [1,1]
here we have consumer conv with 1 found
replaced min pos for kernel 0 with 0
replaced output stencil for kernel based on consumer conv
replaced input=1 and output=3
replaced min pos for kernel 1 with 0
replaced output stencil for kernel based on consumer conv
replaced input=1 and output=3
right before conv inputs
conv,hw_input,hw_output,kernel,
there are 4 hwbuffers
looking for hw_input
hw_input before func
HWBuffer has 2 dims, while 
 loops are: []
 args are: [x,y]
finished is_output 1 consumers
hw_input is inline=0 store=loop_level(.__root) compute=loop_level(.__root) is_xcel=0 is_hw_kernel=1
conv,
right before conv consumer of hw_input
adding hw_input as an input of conv
 size of consumer box is {[(conv.s1.x.min + conv.s1.r$x.min), (conv.s1.x.max + conv.s1.r$x.max)], [(conv.s1.y.min + conv.s1.r$y.min), (conv.s1.y.max + conv.s1.r$y.max)]}
 size of consumer box is ((conv.s1.r$x.max + conv.s1.x.max) - (conv.s1.r$x.min + conv.s1.x.min))
for kernel hw_input, adding consumer conv based on kernel conv
hw_input compute loop is using hw_output.s0.x.xi based on func hw_inputcompute=loop_level(.__root)
looking to find hw_input output stencil where compute_level=hw_output.s0.x.xi
hw_output.s0.y.yi has stride=0 in call for hw_input stride_map[y]=0
hw_output.s0.x.xi has stride=0 in call for hw_input stride_map[x]=0
hw_input found compute level with for loop hw_output.s0.x.xi
conv.s0.x same replaced this min from 0 to 0
conv.s0.y same replaced this min from 0 to 0
couldn't find for loop conv.s1.r$x.r8.min
couldn't find for loop conv.s1.r$x.r$x.min
couldn't find for loop conv.s1.r$y.r9.min
couldn't find for loop conv.s1.r$y.r$y.min
conv.s1.x same replaced this min from 0 to 0
conv.s1.y same replaced this min from 0 to 0
let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
let hw_output.s0.y.max = 0
let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
let hw_output.s0.x.max = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 0
let conv.s1.y.min = 0
let conv.s1.x.max = 0
let conv.s1.x.min = 0
let conv.s0.y.max = 0
let conv.s0.y.min = 0
let conv.s0.x.max = 0
let conv.s0.x.min = 0
produce conv {
  let conv.s0.y.loop_max = 0
  let conv.s0.y.loop_min = 0
  let conv.s0.y.loop_extent = 1
  let conv.s0.x.loop_max = 0
  let conv.s0.x.loop_min = 0
  let conv.s0.x.loop_extent = 1
  let conv.s1.r$y.loop_extent = 3
  let conv.s1.r$y.loop_max = 2
  let conv.s1.r$y.loop_min = 0
  let conv.s1.r$x.loop_extent = 3
  let conv.s1.r$x.loop_max = 2
  let conv.s1.r$x.loop_min = 0
  let conv.s1.y.loop_max = 0
  let conv.s1.y.loop_min = 0
  let conv.s1.y.loop_extent = 1
  let conv.s1.x.loop_max = 0
  let conv.s1.x.loop_min = 0
  let conv.s1.x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_extent = 1
  let conv.s1.r$x.r$x.loop_max = 0
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = 2
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = 1
  let conv.s1.r$y.r$y.loop_max = 0
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = 2
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, 0, 1) {
    for (conv.s0.x, 0, 1) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, 0, 1) {
    for (conv.s1.x, 0, 1) {
      for (conv.s1.r$y.r$y, 0, 1) {
        let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
        unrolled (conv.s1.r$y.r9, 0, 3) {
          let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
          for (conv.s1.r$x.r$x, 0, 1) {
            let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
            unrolled (conv.s1.r$x.r8, 0, 3) {
              let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
              let conv.s1.r$y.max = conv.s1.r$y
              let conv.s1.r$y.min = conv.s1.r$y
              let conv.s1.r$x.max = conv.s1.r$x
              let conv.s1.r$x.min = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}
HWBuffer Parameter: hw_input output stencil size - box extent=[3?1:3-3 ((0 + (0 + 0)),(0 + (0 + 0)))   using (((0 + (0 + 2)) - (0 + (0 + 0))) + 1)
3?1:3-3 ((0 + (0 + 0)),(0 + (0 + 0)))   using (((0 + (0 + 2)) - (0 + (0 + 0))) + 1)
]
conv.s0.y has stride=0 in call for hw_input stride_map[y]=0
conv.s0.x has stride=0 in call for hw_input stride_map[x]=0
conv.s1.y has stride=1 in call for hw_input stride_map[y]=1
conv.s1.x has stride=1 in call for hw_input stride_map[x]=1
conv.s1.r$y.r$y has stride=0 in call for hw_input stride_map[r$y]=0
conv.s1.r$y.r9 has stride=1 in call for hw_input stride_map[r$y]=1
conv.s1.r$x.r$x has stride=0 in call for hw_input stride_map[r$x]=0
conv.s1.r$x.r8 has stride=1 in call for hw_input stride_map[r$x]=1
hw_input stride_x=1
r$x,1
r$y,1
x,1
y,1
the output stencil of hw_input from conv at hw_output.s0.x.xi is [3,3]
for (hw_output.s0.y.yi, 0, 62) {
  let hw_output.s0.y = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
  for (hw_output.s0.x.xi, 0, 62) {
    let hw_output.s0.x = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.y.min = (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
    let hw_output.s0.y.max = 0
    let hw_output.s0.x.min = (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
    let hw_output.s0.x.max = 0
    let conv.s1.r$y.max = 2
    let conv.s1.r$y.min = 0
    let conv.s1.r$x.max = 2
    let conv.s1.r$x.min = 0
    let conv.s1.y.max = 0
    let conv.s1.y.min = 0
    let conv.s1.x.max = 0
    let conv.s1.x.min = 0
    let conv.s0.y.max = 0
    let conv.s0.y.min = 0
    let conv.s0.x.max = 0
    let conv.s0.x.min = 0
    produce conv {
      let conv.s0.y.loop_max = 0
      let conv.s0.y.loop_min = 0
      let conv.s0.y.loop_extent = 1
      let conv.s0.x.loop_max = 0
      let conv.s0.x.loop_min = 0
      let conv.s0.x.loop_extent = 1
      let conv.s1.r$y.loop_extent = 3
      let conv.s1.r$y.loop_max = 2
      let conv.s1.r$y.loop_min = 0
      let conv.s1.r$x.loop_extent = 3
      let conv.s1.r$x.loop_max = 2
      let conv.s1.r$x.loop_min = 0
      let conv.s1.y.loop_max = 0
      let conv.s1.y.loop_min = 0
      let conv.s1.y.loop_extent = 1
      let conv.s1.x.loop_max = 0
      let conv.s1.x.loop_min = 0
      let conv.s1.x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_extent = 1
      let conv.s1.r$x.r$x.loop_max = 0
      let conv.s1.r$x.r$x.loop_min = 0
      let conv.s1.r$x.r8.loop_extent = 3
      let conv.s1.r$x.r8.loop_max = 2
      let conv.s1.r$x.r8.loop_min = 0
      let conv.s1.r$y.r$y.loop_extent = 1
      let conv.s1.r$y.r$y.loop_max = 0
      let conv.s1.r$y.r$y.loop_min = 0
      let conv.s1.r$y.r9.loop_extent = 3
      let conv.s1.r$y.r9.loop_max = 2
      let conv.s1.r$y.r9.loop_min = 0
      for (conv.s0.y, 0, 1) {
        for (conv.s0.x, 0, 1) {
          conv(conv.s0.x, conv.s0.y) = 0
        }
      }
      for (conv.s1.y, 0, 1) {
        for (conv.s1.x, 0, 1) {
          for (conv.s1.r$y.r$y, 0, 1) {
            let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
            unrolled (conv.s1.r$y.r9, 0, 3) {
              let conv.s1.r$y = (conv.s1.r$y.r9 + conv.s1.r$y.r9.base)
              for (conv.s1.r$x.r$x, 0, 1) {
                let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
                unrolled (conv.s1.r$x.r8, 0, 3) {
                  let conv.s1.r$x = (conv.s1.r$x.r8 + conv.s1.r$x.r8.base)
                  let conv.s1.r$y.max = conv.s1.r$y
                  let conv.s1.r$y.min = conv.s1.r$y
                  let conv.s1.r$x.max = conv.s1.r$x
                  let conv.s1.r$x.min = conv.s1.r$x
                  conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
                }
              }
            }
          }
        }
      }
    }
    consume conv {
      hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
    }
  }
}
saw this for loop hw_input.s0.y while compute=hw_output.s0.x.xi
saw this for loop hw_input.s0.x while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.y.yo while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.x.xo while compute=hw_output.s0.x.xi
saw this for loop kernel.s0.y while compute=hw_output.s0.x.xi
saw this for loop kernel.s0.x while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.y.yi while compute=hw_output.s0.x.xi
saw this for loop hw_output.s0.x.xi while compute=hw_output.s0.x.xi
let's save this input box num_dims=2 box=2
HWBuffer Parameter: conv input chunk size - box extent=[1:1-1 (0,0)  1:1-1 (0,0)  ]
saw this for loop conv.s0.y while compute=hw_output.s0.x.xi
saw this for loop conv.s0.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r$y while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$y.r9 while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r$x while compute=hw_output.s0.x.xi
saw this for loop conv.s1.r$x.r8 while compute=hw_output.s0.x.xi
saw this for loop output.s0.y while compute=hw_output.s0.x.xi
saw this for loop output.s0.x while compute=hw_output.s0.x.xi
the input chunk of hw_input at hw_output.s0.x.xi is [1,1]
here we have consumer conv with 1 found
replaced min pos for hw_input 0 with 0
replaced output stencil for hw_input based on consumer conv
replaced input=1 and output=3
replaced min pos for hw_input 1 with 0
replaced output stencil for hw_input based on consumer conv
replaced input=1 and output=3
right before conv inputs
conv is extracted w/ inline=0 and num_dims=2
Final buffer:
HWBuffer: conv
Logical Buffer: [62,62]
Input Chunk: [1,1]
Input Block: [1,1]
Output Stencil: [1,1]
Output Block: [1,1]
Output Access Pattern:
 for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("conv_dim0", min((hw_output.s0.x.xi + hw_output.s0.x.xi.base), 0))
    assert("conv_dim1", min((hw_output.s0.y.yi + hw_output.s0.y.yi.base), 0))
  }
}

Output Min Pos:
 [(hw_output.s0.x.xi + hw_output.s0.x.xi.base),(hw_output.s0.y.yi + hw_output.s0.y.yi.base)]
is_inline=0
is_output=0

hw_input is extracted w/ inline=0 and num_dims=2
Final buffer:
HWBuffer: hw_input
Logical Buffer: [64,64]
Input Chunk: [1,1]
Input Block: [1,1]
Output Stencil: [3,3]
Output Block: [3,3]
Output Access Pattern:
 for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("hw_input_dim0", 0)
    assert("hw_input_dim1", 0)
  }
}

Output Min Pos:
 [0,0]
is_inline=0
is_output=0

hw_output is extracted w/ inline=0 and num_dims=2
Final buffer:
HWBuffer: hw_output
Logical Buffer: [62,62]
Input Chunk: [1,1]
Input Block: [1,1]
Output Stencil: [1,1]
Output Block: [1,1]
Output Access Pattern:
 for (output.s0.y, 0, 62) {
  for (output.s0.x, 0, 62) {
    assert("hw_output_dim0", output.s0.x)
    assert("hw_output_dim1", output.s0.y)
  }
}

Output Min Pos:
 [0,0]
is_inline=0
is_output=1

kernel is extracted w/ inline=1 and num_dims=2
Final buffer:
HWBuffer: kernel
Logical Buffer: [3,3]
Input Chunk: [1,1]
Input Block: [1,1]
Output Stencil: [3,3]
Output Block: [3,3]
Output Access Pattern:
 for (hw_output.s0.y.yi, 0, 62) {
  for (hw_output.s0.x.xi, 0, 62) {
    assert("kernel_dim0", 0)
    assert("kernel_dim1", 0)
  }
}

Output Min Pos:
 [0,0]
is_inline=1
is_output=0

conv is lower w/ inline=0
hw_input is lower w/ inline=0
hw_output is lower w/ inline=0
kernel is lower w/ inline=1
conv is inline=0 with num_dims=2
hw_input is inline=0 with num_dims=2
hw_output is inline=0 with num_dims=2
kernel is inline=1 with num_dims=2
Scope does not contain  output.min.1
Scope does not contain  output.extent.1
Scope does not contain  output.min.1
Scope does not contain  output.min.0
Scope does not contain  output.extent.0
Scope does not contain  output.min.0
Scope does not contain  input.extent.0
Scope does not contain  input.extent.1
Scope does not contain  output.extent.0
Scope does not contain  output.extent.1
this a realize
visiting for loop named hw_input.s0.y where store_lvl=loop_level(hw_output.xo) where compute_lvl=loop_level(hw_output.xi)
streaming loops:
hw_output.s0.y.yi,hw_output.s0.x.xi,
just continue
visiting for loop named hw_input.s0.x where store_lvl=loop_level(hw_output.xo) where compute_lvl=loop_level(hw_output.xi)
streaming loops:
hw_output.s0.y.yi,hw_output.s0.x.xi,
just continue
this a realize
visiting for loop named hw_output.s0.y.yo where store_lvl=loop_level(hw_output.xo) where compute_lvl=loop_level(hw_output.xi)
streaming loops:
hw_output.s0.y.yi,hw_output.s0.x.xi,
just continue
Scope does not contain  hw_output.s0.y.yo
visiting for loop named hw_output.s0.x.xo where store_lvl=loop_level(hw_output.xo) where compute_lvl=loop_level(hw_output.xi)
streaming loops:
hw_output.s0.y.yi,hw_output.s0.x.xi,
create xcel
find the pipeline producing hw_output
Scope does not contain  hw_output.s0.x.xo
this a realize
visiting for loop named kernel.s0.y where store_lvl=loop_level(hw_output.xo) where compute_lvl=loop_level(hw_output.xi)
streaming loops:
hw_output.s0.y.yi,hw_output.s0.x.xi,
just continue
visiting for loop named kernel.s0.x where store_lvl=loop_level(hw_output.xo) where compute_lvl=loop_level(hw_output.xi)
streaming loops:
hw_output.s0.y.yi,hw_output.s0.x.xi,
just continue
this a realize
visiting for loop named hw_output.s0.y.yi where store_lvl=loop_level(hw_output.xo) where compute_lvl=loop_level(hw_output.xi)
streaming loops:
hw_output.s0.y.yi,hw_output.s0.x.xi,
loopy
Scope does not contain  hw_output.s0.y.yi
visiting for loop named hw_output.s0.x.xi where store_lvl=loop_level(hw_output.xo) where compute_lvl=loop_level(hw_output.xi)
streaming loops:
hw_output.s0.y.yi,hw_output.s0.x.xi,
xcel compute
Scope does not contain  hw_output.s0.x.xi
Scope does not contain  hw_output.s0.y.yi
Scope does not contain  hw_output.s0.x.xi
about to transform
transforming:
produce conv {
  let conv.s0.y.loop_max = conv.s0.y.max_2
  let conv.s0.y.loop_min = conv.s0.y.min_2
  let conv.s0.y.loop_extent = ((conv.s0.y.max_2 + 1) - conv.s0.y.min_2)
  let conv.s0.x.loop_max = conv.s0.x.max_2
  let conv.s0.x.loop_min = conv.s0.x.min_2
  let conv.s0.x.loop_extent = ((conv.s0.x.max_2 + 1) - conv.s0.x.min_2)
  let conv.s1.r$y.loop_extent = ((conv.s1.r$y.max_2 - conv.s1.r$y.min_2) + 1)
  let conv.s1.r$y.loop_max = conv.s1.r$y.max_2
  let conv.s1.r$y.loop_min = conv.s1.r$y.min_2
  let conv.s1.r$x.loop_extent = ((conv.s1.r$x.max_2 - conv.s1.r$x.min_2) + 1)
  let conv.s1.r$x.loop_max = conv.s1.r$x.max_2
  let conv.s1.r$x.loop_min = conv.s1.r$x.min_2
  let conv.s1.y.loop_max = conv.s1.y.max_2
  let conv.s1.y.loop_min = conv.s1.y.min_2
  let conv.s1.y.loop_extent = ((conv.s1.y.max_2 + 1) - conv.s1.y.min_2)
  let conv.s1.x.loop_max = conv.s1.x.max_2
  let conv.s1.x.loop_min = conv.s1.x.min_2
  let conv.s1.x.loop_extent = ((conv.s1.x.max_2 + 1) - conv.s1.x.min_2)
  let conv.s1.r$x.r$x.loop_extent = (((conv.s1.r$x.loop_max - conv.s1.r$x.loop_min) + 3)/3)
  let conv.s1.r$x.r$x.loop_max = ((((conv.s1.r$x.loop_max - conv.s1.r$x.loop_min) + 3)/3) - 1)
  let conv.s1.r$x.r$x.loop_min = 0
  let conv.s1.r$x.r8.loop_extent = 3
  let conv.s1.r$x.r8.loop_max = (3 - 1)
  let conv.s1.r$x.r8.loop_min = 0
  let conv.s1.r$y.r$y.loop_extent = (((conv.s1.r$y.loop_max - conv.s1.r$y.loop_min) + 3)/3)
  let conv.s1.r$y.r$y.loop_max = ((((conv.s1.r$y.loop_max - conv.s1.r$y.loop_min) + 3)/3) - 1)
  let conv.s1.r$y.r$y.loop_min = 0
  let conv.s1.r$y.r9.loop_extent = 3
  let conv.s1.r$y.r9.loop_max = (3 - 1)
  let conv.s1.r$y.r9.loop_min = 0
  for (conv.s0.y, conv.s0.y.loop_min, conv.s0.y.loop_extent) {
    for (conv.s0.x, conv.s0.x.loop_min, conv.s0.x.loop_extent) {
      conv(conv.s0.x, conv.s0.y) = 0
    }
  }
  for (conv.s1.y, conv.s1.y.loop_min, conv.s1.y.loop_extent) {
    for (conv.s1.x, conv.s1.x.loop_min, conv.s1.x.loop_extent) {
      for (conv.s1.r$y.r$y, conv.s1.r$y.r$y.loop_min, conv.s1.r$y.r$y.loop_extent) {
        let conv.s1.r$y.r9.base = ((conv.s1.r$y.r$y*3) + conv.s1.r$y.loop_min)
        unrolled (conv.s1.r$y.r9, conv.s1.r$y.r9.loop_min, conv.s1.r$y.r9.loop_extent) {
          let conv.s1.r$y = (conv.s1.r$y.r9.base + conv.s1.r$y.r9)
          for (conv.s1.r$x.r$x, conv.s1.r$x.r$x.loop_min, conv.s1.r$x.r$x.loop_extent) {
            let conv.s1.r$x.r8.base = ((conv.s1.r$x.r$x*3) + conv.s1.r$x.loop_min)
            unrolled (conv.s1.r$x.r8, conv.s1.r$x.r8.loop_min, conv.s1.r$x.r8.loop_extent) {
              let conv.s1.r$x = (conv.s1.r$x.r8.base + conv.s1.r$x.r8)
              let conv.s1.r$y.max_3 = conv.s1.r$y
              let conv.s1.r$y.min_3 = conv.s1.r$y
              let conv.s1.r$x.max_3 = conv.s1.r$x
              let conv.s1.r$x.min_3 = conv.s1.r$x
              conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
            }
          }
        }
      }
    }
  }
}
consume conv {
  hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
}

conv=conv,hw_input=hw_input,hw_output=hw_output,kernel=kernel,
going through block conv
conv has inline=0 num_dims=2
 compute=loop_level(hw_output.xi)
 store=loop_level(hw_output.xo)
kernel conv has size=1 step=1
kernel conv has size=1 step=1
r$x has stride=0
r$y has stride=0
x has stride=1
y has stride=1
replacing some refs: let conv.s0.y.loop_max = conv.s0.y.max_2
let conv.s0.y.loop_min = conv.s0.y.min_2
let conv.s0.y.loop_extent = ((conv.s0.y.max_2 + 1) - conv.s0.y.min_2)
let conv.s0.x.loop_max = conv.s0.x.max_2
let conv.s0.x.loop_min = conv.s0.x.min_2
let conv.s0.x.loop_extent = ((conv.s0.x.max_2 + 1) - conv.s0.x.min_2)
let conv.s1.r$y.loop_extent = ((conv.s1.r$y.max_2 - conv.s1.r$y.min_2) + 1)
let conv.s1.r$y.loop_max = conv.s1.r$y.max_2
let conv.s1.r$y.loop_min = conv.s1.r$y.min_2
let conv.s1.r$x.loop_extent = ((conv.s1.r$x.max_2 - conv.s1.r$x.min_2) + 1)
let conv.s1.r$x.loop_max = conv.s1.r$x.max_2
let conv.s1.r$x.loop_min = conv.s1.r$x.min_2
let conv.s1.y.loop_max = conv.s1.y.max_2
let conv.s1.y.loop_min = conv.s1.y.min_2
let conv.s1.y.loop_extent = ((conv.s1.y.max_2 + 1) - conv.s1.y.min_2)
let conv.s1.x.loop_max = conv.s1.x.max_2
let conv.s1.x.loop_min = conv.s1.x.min_2
let conv.s1.x.loop_extent = ((conv.s1.x.max_2 + 1) - conv.s1.x.min_2)
let conv.s1.r$x.r$x.loop_extent = (((conv.s1.r$x.loop_max - conv.s1.r$x.loop_min) + 3)/3)
let conv.s1.r$x.r$x.loop_max = ((((conv.s1.r$x.loop_max - conv.s1.r$x.loop_min) + 3)/3) - 1)
let conv.s1.r$x.r$x.loop_min = 0
let conv.s1.r$x.r8.loop_extent = 3
let conv.s1.r$x.r8.loop_max = (3 - 1)
let conv.s1.r$x.r8.loop_min = 0
let conv.s1.r$y.r$y.loop_extent = (((conv.s1.r$y.loop_max - conv.s1.r$y.loop_min) + 3)/3)
let conv.s1.r$y.r$y.loop_max = ((((conv.s1.r$y.loop_max - conv.s1.r$y.loop_min) + 3)/3) - 1)
let conv.s1.r$y.r$y.loop_min = 0
let conv.s1.r$y.r9.loop_extent = 3
let conv.s1.r$y.r9.loop_max = (3 - 1)
let conv.s1.r$y.r9.loop_min = 0
for (conv.s0.y, conv.s0.y.loop_min, conv.s0.y.loop_extent) {
  for (conv.s0.x, conv.s0.x.loop_min, conv.s0.x.loop_extent) {
    conv(conv.s0.x, conv.s0.y) = 0
  }
}
for (conv.s1.y, conv.s1.y.loop_min, conv.s1.y.loop_extent) {
  for (conv.s1.x, conv.s1.x.loop_min, conv.s1.x.loop_extent) {
    for (conv.s1.r$y.r$y, conv.s1.r$y.r$y.loop_min, conv.s1.r$y.r$y.loop_extent) {
      let conv.s1.r$y.r9.base = ((conv.s1.r$y.r$y*3) + conv.s1.r$y.loop_min)
      unrolled (conv.s1.r$y.r9, conv.s1.r$y.r9.loop_min, conv.s1.r$y.r9.loop_extent) {
        let conv.s1.r$y = (conv.s1.r$y.r9.base + conv.s1.r$y.r9)
        for (conv.s1.r$x.r$x, conv.s1.r$x.r$x.loop_min, conv.s1.r$x.r$x.loop_extent) {
          let conv.s1.r$x.r8.base = ((conv.s1.r$x.r$x*3) + conv.s1.r$x.loop_min)
          unrolled (conv.s1.r$x.r8, conv.s1.r$x.r8.loop_min, conv.s1.r$x.r8.loop_extent) {
            let conv.s1.r$x = (conv.s1.r$x.r8.base + conv.s1.r$x.r8)
            let conv.s1.r$y.max_3 = conv.s1.r$y
            let conv.s1.r$y.min_3 = conv.s1.r$y
            let conv.s1.r$x.max_3 = conv.s1.r$x
            let conv.s1.r$x.min_3 = conv.s1.r$x
            conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
          }
        }
      }
    }
  }
}

created pass to replace refs for conv
starting this for replace
starting this replace: conv.s0.y
doing dim=1 for kernel size 2
replacing conv.s0.y with the value=(conv.stencil.s0.y + conv.s0.y.loop_min)
Scope does not contain  conv.stencil.s0.y
starting this for replace
starting this replace: conv.s0.x
doing dim=0 for kernel size 2
replacing conv.s0.x with the value=(conv.stencil.s0.x + conv.s0.x.loop_min)
Scope does not contain  conv.stencil.s0.x
looking at this provide: conv while kernel is conv
old_arg0 is conv.s0.x while shift is (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
new_arg0 is 0
old_arg1 is conv.s0.y while shift is (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
new_arg1 is 0
old provide replaced conv(conv.s0.x, conv.s0.y) = 0
 with conv.stencil(0, 0) = 0

 using min_x=(hw_output.s0.x.xi + hw_output.s0.x.xi.base)
finishing this for
finishing this for
starting this for replace
starting this replace: conv.s1.y
doing dim=1 for kernel size 2
replacing conv.s1.y with the value=(conv.stencil.s1.y + conv.s1.y.loop_min)
Scope does not contain  conv.stencil.s1.y
starting this for replace
starting this replace: conv.s1.x
doing dim=0 for kernel size 2
replacing conv.s1.x with the value=(conv.stencil.s1.x + conv.s1.x.loop_min)
Scope does not contain  conv.stencil.s1.x
starting this for replace
starting this replace: conv.s1.r$y.r$y
nvm this is a reduction
Scope does not contain  conv.s1.r$y.r$y
starting this for replace
starting this replace: conv.s1.r$y.r9
nvm this is a reduction
Scope does not contain  conv.s1.r$y.r9
starting this for replace
starting this replace: conv.s1.r$x.r$x
nvm this is a reduction
Scope does not contain  conv.s1.r$x.r$x
starting this for replace
starting this replace: conv.s1.r$x.r8
nvm this is a reduction
Scope does not contain  conv.s1.r$x.r8
looking at this provide: conv while kernel is conv
old_arg0 is conv.s1.x while shift is (hw_output.s0.x.xi + hw_output.s0.x.xi.base)
new_arg0 is 0
old_arg1 is conv.s1.y while shift is (hw_output.s0.y.yi + hw_output.s0.y.yi.base)
new_arg1 is 0
conv is a call in the replacerefs
kernelname=conv input_streams=[conv,conv,hw_input,hw_input]
inside call
offset from own kernel for conv
offset=(hw_output.s0.x.xi + hw_output.s0.x.xi.base)
new_arg0 = 0
replacing call to conv: offset=0 since stencil_name=conv kernel_name=conv
offset from own kernel for conv
offset=(hw_output.s0.y.yi + hw_output.s0.y.yi.base)
new_arg1 = 0
replacing call to conv: offset=0 since stencil_name=conv kernel_name=conv
done with call
replacing call conv(conv.s1.x, conv.s1.y) with
	conv.stencil(0, 0)
kernel is a call in the replacerefs
kernelname=conv input_streams=[conv,conv,hw_input,hw_input]
hw_input is a call in the replacerefs
kernelname=conv input_streams=[conv,conv,hw_input,hw_input]
inside call
tricky offset here for conv
offset=(hw_output.s0.x.xi + hw_output.s0.x.xi.base)
Scope does not contain  conv.s1.r$x.r8
new_arg0 = conv.s1.r$x.r8
replacing call to hw_input: offset=0 since stencil_name=hw_input kernel_name=conv
tricky offset here for conv
offset=(hw_output.s0.y.yi + hw_output.s0.y.yi.base)
Scope does not contain  conv.s1.r$y.r9
new_arg1 = conv.s1.r$y.r9
replacing call to hw_input: offset=0 since stencil_name=hw_input kernel_name=conv
done with call
replacing call hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))) with
	hw_input.stencil(conv.s1.r$x.r8, conv.s1.r$y.r9)
old provide replaced conv(conv.s1.x, conv.s1.y) = (conv(conv.s1.x, conv.s1.y) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input((conv.s1.x + (conv.s1.r$x.r8.base + conv.s1.r$x.r8)), (conv.s1.y + (conv.s1.r$y.r9.base + conv.s1.r$y.r9))))))
 with conv.stencil(0, 0) = (conv.stencil(0, 0) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input.stencil(conv.s1.r$x.r8, conv.s1.r$y.r9))))

 using min_x=(hw_output.s0.x.xi + hw_output.s0.x.xi.base)
finishing this for
finishing this for
continuing
write streams created
read streams created
writing kernel named conv.stencil with bounds 
store=62 in_chunk=1
store=62 in_chunk=1
transforming:
hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))

this is output
this is output: hw_output=hw_output
replacing some output refs: hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))

created pass to replace refs for hw_output
looking at this provide: hw_output while kernel is hw_output
Scope does not contain  hw_output.s0.x.xi
old_arg0 is (hw_output.s0.x.xi.base + hw_output.s0.x.xi) while shift is 0
new_arg0 is hw_output.s0.x.xi
Scope does not contain  hw_output.s0.y.yi
old_arg1 is (hw_output.s0.y.yi.base + hw_output.s0.y.yi) while shift is 0
new_arg1 is hw_output.s0.y.yi
conv is a call in the replacerefs
kernelname=hw_output input_streams=[conv,conv,conv,conv]
inside call
tricky offset here for hw_output
offset=0
Scope does not contain  hw_output.s0.x.xi
new_arg0 = hw_output.s0.x.xi
replacing call to conv: offset=0 since stencil_name=conv kernel_name=hw_output
tricky offset here for hw_output
offset=0
Scope does not contain  hw_output.s0.y.yi
new_arg1 = hw_output.s0.y.yi
replacing call to conv: offset=0 since stencil_name=conv kernel_name=hw_output
done with call
replacing call conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) with
	conv.stencil(hw_output.s0.x.xi, hw_output.s0.y.yi)
old provide replaced hw_output((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)) = uint8(conv((hw_output.s0.x.xi.base + hw_output.s0.x.xi), (hw_output.s0.y.yi.base + hw_output.s0.y.yi)))
 with hw_output.stencil(hw_output.s0.x.xi, hw_output.s0.y.yi) = uint8(conv.stencil(hw_output.s0.x.xi, hw_output.s0.y.yi))

 using min_x=0
considering a hwbuffer for conv
kernel conv has size=1 step=1
kernel conv has size=1 step=1
r$x has stride=0
r$y has stride=0
x has stride=1
y has stride=1
creating dispatch from conv of 2 dims
   going to 2 consumers: conv(2 dims), 
hw_output(2 dims), 
let's add input stream hw_input
considering a hwbuffer for hw_input
kernel hw_input has size=3 step=1
r$x has stride=1
r$y has stride=1
x has stride=1
y has stride=1
creating a hwbuffer for hw_input
hwbuffer num_dims=2
store extent in this hwbuffer: 64
store extent in this hwbuffer: 64
output_blk0 = 3
output_blk1 = 3
doing some addressing for kernel=hw_input
r$x,1
r$y,1
x,1
y,1
storage name=x has dim_idx=0
storage name=y has dim_idx=1
going to be looking for range and strides where storage=[x,y]
hw_output.s0.y.yi is probably referring to storage y
this is a streaming loop: y for hw_output.s0.y.yi
r$x,1
r$y,1
x,1
y,1
 and mapcount=4 1
stride=1 is_inv=0
hw_output.s0.y.yi has stride=1 dim_ref=1
hw_output.s0.x.xi is probably referring to storage x
this is a streaming loop: x for hw_output.s0.x.xi
r$x,1
r$y,1
x,1
y,1
 and mapcount=4 1
stride=1 is_inv=0
hw_output.s0.x.xi has stride=1 dim_ref=0
range0 = 62
range1 = 62
creating dispatch from hw_input of 2 dims
   going to 1 consumers: conv(2 dims), 
kernel hw_output has size=1 step=1
kernel hw_output has size=1 step=1
r$x has stride=0
r$y has stride=0
x has stride=1
y has stride=1
kernel hw_input has size=3 step=1
r$x has stride=1
r$y has stride=1
x has stride=1
y has stride=1
visiting for loop named output.s0.y where store_lvl=loop_level(hw_output.xo) where compute_lvl=loop_level(hw_output.xi)
streaming loops:
hw_output.s0.y.yi,hw_output.s0.x.xi,
just continue
visiting for loop named output.s0.x where store_lvl=loop_level(hw_output.xo) where compute_lvl=loop_level(hw_output.xi)
streaming loops:
hw_output.s0.y.yi,hw_output.s0.x.xi,
just continue
Inserted hwbuffers: 
let output.s0.y.max = ((output.extent.1 + output.min.1) + -1)
let output.s0.y.min = output.min.1
let output.s0.x.max = ((output.extent.0 + output.min.0) + -1)
let output.s0.x.min = output.min.0
let output.s0.y.max_unbounded = ((output.extent.1 + output.min.1) + -1)
let output.s0.y.min_unbounded = output.min.1
let output.s0.y.max_1 = 61
let output.s0.y.min_1 = 0
let output.s0.x.max_unbounded = ((output.extent.0 + output.min.0) + -1)
let output.s0.x.min_unbounded = output.min.0
let output.s0.x.max_1 = 61
let output.s0.x.min_1 = 0
let hw_output.s0.y.max = 61
let hw_output.s0.y.min = 0
let hw_output.s0.x.max = 61
let hw_output.s0.x.min = 0
let conv.s1.r$y.max = 2
let conv.s1.r$y.min = 0
let conv.s1.r$x.max = 2
let conv.s1.r$x.min = 0
let conv.s1.y.max = 61
let conv.s1.y.min = 0
let conv.s1.x.max = 61
let conv.s1.x.min = 0
let conv.s0.y.max = 61
let conv.s0.y.min = 0
let conv.s0.x.max = 61
let conv.s0.x.min = 0
let kernel.s9.y.max = 2
let kernel.s9.y.min = 0
let kernel.s9.x.max = 2
let kernel.s9.x.min = 0
let kernel.s8.y.max = 2
let kernel.s8.y.min = 0
let kernel.s8.x.max = 2
let kernel.s8.x.min = 0
let kernel.s7.y.max = 2
let kernel.s7.y.min = 0
let kernel.s7.x.max = 2
let kernel.s7.x.min = 0
let kernel.s6.y.max = 2
let kernel.s6.y.min = 0
let kernel.s6.x.max = 2
let kernel.s6.x.min = 0
let kernel.s5.y.max = 2
let kernel.s5.y.min = 0
let kernel.s5.x.max = 2
let kernel.s5.x.min = 0
let kernel.s4.y.max = 2
let kernel.s4.y.min = 0
let kernel.s4.x.max = 2
let kernel.s4.x.min = 0
let kernel.s3.y.max = 2
let kernel.s3.y.min = 0
let kernel.s3.x.max = 2
let kernel.s3.x.min = 0
let kernel.s2.y.max = 2
let kernel.s2.y.min = 0
let kernel.s2.x.max = 2
let kernel.s2.x.min = 0
let kernel.s1.y.max = 2
let kernel.s1.y.min = 0
let kernel.s1.x.max = 2
let kernel.s1.x.min = 0
let kernel.s0.y.max = 2
let kernel.s0.y.min = 0
let kernel.s0.x.max = 2
let kernel.s0.x.min = 0
let hw_input.s0.y.max = 63
let hw_input.s0.y.min = 0
let hw_input.s0.x.max = 63
let hw_input.s0.x.min = 0
let input.extent.0.required = 64
let input.min.0.required = 0
let input.stride.0.required = 1
let input.extent.1.required = 64
let input.min.1.required = 0
let input.stride.1.required = 64
let output.extent.0.required = 62
let output.min.0.required = 0
let output.stride.0.required = 1
let output.extent.1.required = 62
let output.min.1.required = 0
let output.stride.1.required = 62
let input.stride.0.constrained = 1
let output.stride.0.constrained = 1
let input.stride.0.proposed = 1
let input.min.0.proposed = 0
let input.extent.0.proposed = 64
let input.stride.1.proposed = 64
let input.min.1.proposed = 0
let input.extent.1.proposed = 64
let output.stride.0.proposed = 1
let output.min.0.proposed = 0
let output.extent.0.proposed = 62
let output.stride.1.proposed = 62
let output.min.1.proposed = 0
let output.extent.1.proposed = 62
assert((!_halide_buffer_is_bounds_query(input.buffer) || ((input.min.0.proposed <= input.min.0.required) && (((input.min.0.proposed + input.extent.0.proposed) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Input buffer input", 0, input.min.0.proposed, ((input.min.0.proposed + input.extent.0.proposed) - 1), input.min.0.required, ((input.min.0.required + input.extent.0.required) - 1)))
assert((!_halide_buffer_is_bounds_query(input.buffer) || ((input.min.1.proposed <= input.min.1.required) && (((input.min.1.proposed + input.extent.1.proposed) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Input buffer input", 1, input.min.1.proposed, ((input.min.1.proposed + input.extent.1.proposed) - 1), input.min.1.required, ((input.min.1.required + input.extent.1.required) - 1)))
assert((!_halide_buffer_is_bounds_query(output.buffer) || ((output.min.0.proposed <= output.min.0.required) && (((output.min.0.proposed + output.extent.0.proposed) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer output", 0, output.min.0.proposed, ((output.min.0.proposed + output.extent.0.proposed) - 1), output.min.0.required, ((output.min.0.required + output.extent.0.required) - 1)))
assert((!_halide_buffer_is_bounds_query(output.buffer) || ((output.min.1.proposed <= output.min.1.required) && (((output.min.1.proposed + output.extent.1.proposed) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer output", 1, output.min.1.proposed, ((output.min.1.proposed + output.extent.1.proposed) - 1), output.min.1.required, ((output.min.1.required + output.extent.1.required) - 1)))
if (_halide_buffer_is_bounds_query(input.buffer)) {
  _halide_buffer_init(input.buffer, _halide_buffer_get_shape(input.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 2, make_struct((halide_dimension_t *), input.min.0.proposed, input.extent.0.proposed, input.stride.0.proposed, 0, input.min.1.proposed, input.extent.1.proposed, input.stride.1.proposed, 0), (uint64)0)
}
if (_halide_buffer_is_bounds_query(output.buffer)) {
  _halide_buffer_init(output.buffer, _halide_buffer_get_shape(output.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 2, make_struct((halide_dimension_t *), output.min.0.proposed, output.extent.0.proposed, output.stride.0.proposed, 0, output.min.1.proposed, output.extent.1.proposed, output.stride.1.proposed, 0), (uint64)0)
}
if (!(((uint1)0 || _halide_buffer_is_bounds_query(input.buffer)) || _halide_buffer_is_bounds_query(output.buffer))) {
  assert((((input.type.code == (uint8)1) && (input.type.bits == (uint8)8)) && (input.type.lanes == (uint16)1)), halide_error_bad_type("Input buffer input", input.type.code, (uint8)1, input.type.bits, (uint8)8, input.type.lanes, (uint16)1))
  assert((input.dimensions == 2), halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
  assert((((output.type.code == (uint8)1) && (output.type.bits == (uint8)8)) && (output.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer output", output.type.code, (uint8)1, output.type.bits, (uint8)8, output.type.lanes, (uint16)1))
  assert((output.dimensions == 2), halide_error_bad_dimensions("Output buffer output", output.dimensions, 2))
  assert(((input.min.0 <= input.min.0.required) && (((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1))), halide_error_access_out_of_bounds("Input buffer input", 0, input.min.0.required, ((input.min.0.required + input.extent.0.required) - 1), input.min.0, ((input.min.0 + input.extent.0) - 1)))
  assert((input.extent.0 >= 0), halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
  assert(((input.min.1 <= input.min.1.required) && (((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1))), halide_error_access_out_of_bounds("Input buffer input", 1, input.min.1.required, ((input.min.1.required + input.extent.1.required) - 1), input.min.1, ((input.min.1 + input.extent.1) - 1)))
  assert((input.extent.1 >= 0), halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
  assert(((output.min.0 <= output.min.0.required) && (((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1))), halide_error_access_out_of_bounds("Output buffer output", 0, output.min.0.required, ((output.min.0.required + output.extent.0.required) - 1), output.min.0, ((output.min.0 + output.extent.0) - 1)))
  assert((output.extent.0 >= 0), halide_error_buffer_extents_negative("Output buffer output", 0, output.extent.0))
  assert(((output.min.1 <= output.min.1.required) && (((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1))), halide_error_access_out_of_bounds("Output buffer output", 1, output.min.1.required, ((output.min.1.required + output.extent.1.required) - 1), output.min.1, ((output.min.1 + output.extent.1) - 1)))
  assert((output.extent.1 >= 0), halide_error_buffer_extents_negative("Output buffer output", 1, output.extent.1))
  assert((input.stride.0 == input.stride.0.constrained), halide_error_constraint_violated("input.stride.0", input.stride.0, "1", input.stride.0.constrained))
  assert((output.stride.0 == output.stride.0.constrained), halide_error_constraint_violated("output.stride.0", output.stride.0, "1", output.stride.0.constrained))
  let input.total_extent.0 = int64(input.extent.0)
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.0 = int64(output.extent.0)
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((abs((int64(input.extent.0)*int64(input.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("input", abs((int64(input.extent.0)*int64(input.stride.0.constrained))), (uint64)2147483647))
  assert((abs((int64(input.extent.1)*int64(input.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("input", abs((int64(input.extent.1)*int64(input.stride.1))), (uint64)2147483647))
  assert((input.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
  assert((abs((int64(output.extent.0)*int64(output.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("output", abs((int64(output.extent.0)*int64(output.stride.0.constrained))), (uint64)2147483647))
  assert((abs((int64(output.extent.1)*int64(output.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("output", abs((int64(output.extent.1)*int64(output.stride.1))), (uint64)2147483647))
  assert((output.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("output", output.total_extent.1, (int64)2147483647))
  assert((input != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Input buffer input"))
  assert((output != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer output"))
  let hw_input.y.max_realized = 63
  let hw_input.y.min_realized = 0
  let hw_input.y.extent_realized = 64
  let hw_input.x.max_realized = 63
  let hw_input.x.min_realized = 0
  let hw_input.x.extent_realized = 64
  realize hw_input([hw_input.x.min_realized, hw_input.x.extent_realized], [hw_input.y.min_realized, hw_input.y.extent_realized]) {
    produce hw_input {
      let hw_input.s0.y.loop_max = 63
      let hw_input.s0.y.loop_min = 0
      let hw_input.s0.y.loop_extent = 64
      let hw_input.s0.x.loop_max = 63
      let hw_input.s0.x.loop_min = 0
      let hw_input.s0.x.loop_extent = 64
      for (hw_input.s0.y, hw_input.s0.y.loop_min, hw_input.s0.y.loop_extent) {
        for (hw_input.s0.x, hw_input.s0.x.loop_min, hw_input.s0.x.loop_extent) {
          hw_input(hw_input.s0.x, hw_input.s0.y) = uint16(input(hw_input.s0.x, hw_input.s0.y))
        }
      }
    }
    consume hw_input {
      let hw_output.y.max_realized = 61
      let hw_output.y.min_realized = 0
      let hw_output.y.extent_realized = 62
      let hw_output.x.max_realized = 61
      let hw_output.x.min_realized = 0
      let hw_output.x.extent_realized = 62
      realize hw_output([hw_output.x.min_realized, hw_output.x.extent_realized], [hw_output.y.min_realized, hw_output.y.extent_realized]) {
        produce hw_output {
          let hw_output.s0.y.loop_max = 61
          let hw_output.s0.y.loop_min = 0
          let hw_output.s0.y.loop_extent = 62
          let hw_output.s0.x.loop_max = 61
          let hw_output.s0.x.loop_min = 0
          let hw_output.s0.x.loop_extent = 62
          let hw_output.s0.x.xo.loop_extent = 1
          let hw_output.s0.x.xo.loop_max = 0
          let hw_output.s0.x.xo.loop_min = 0
          let hw_output.s0.x.xi.loop_extent = 62
          let hw_output.s0.x.xi.loop_max = 61
          let hw_output.s0.x.xi.loop_min = 0
          let hw_output.s0.y.yo.loop_extent = 1
          let hw_output.s0.y.yo.loop_max = 0
          let hw_output.s0.y.yo.loop_min = 0
          let hw_output.s0.y.yi.loop_extent = 62
          let hw_output.s0.y.yi.loop_max = 61
          let hw_output.s0.y.yi.loop_min = 0
          for (hw_output.s0.y.yo, hw_output.s0.y.yo.loop_min, hw_output.s0.y.yo.loop_extent) {
            let hw_output.s0.y.yi.base = min(likely_if_innermost((hw_output.s0.y.yo*62)), 0)
            for (hw_output.s0.x.xo, hw_output.s0.x.xo.loop_min, hw_output.s0.x.xo.loop_extent) {
              let hw_output.s0.x.xi.base = min(likely_if_innermost(((hw_output.s0.x.xo*62) + hw_output.s0.x.loop_min)), (hw_output.s0.x.loop_max + (1 - 62)))
              let hw_output.s0.y.min_1 = (hw_output.s0.y.yi.base + hw_output.s0.y.yi.loop_min)
              let hw_output.s0.y.max_1 = (hw_output.s0.y.yi.base + ((hw_output.s0.y.yi.loop_extent + hw_output.s0.y.yi.loop_min) - 1))
              let hw_output.s0.x.min_1 = (hw_output.s0.x.xi.base + hw_output.s0.x.xi.loop_min)
              let hw_output.s0.x.max_1 = (hw_output.s0.x.xi.base + ((hw_output.s0.x.xi.loop_extent + hw_output.s0.x.xi.loop_min) - 1))
              let conv.s1.r$y.max_1 = ((3 + 0) - 1)
              let conv.s1.r$y.min_1 = 0
              let conv.s1.r$x.max_1 = ((3 + 0) - 1)
              let conv.s1.r$x.min_1 = 0
              let conv.s1.y.max_1 = hw_output.s0.y.max_1
              let conv.s1.y.min_1 = hw_output.s0.y.min_1
              let conv.s1.x.max_1 = hw_output.s0.x.max_1
              let conv.s1.x.min_1 = hw_output.s0.x.min_1
              let conv.s0.y.max_1 = conv.s1.y.max_1
              let conv.s0.y.min_1 = conv.s1.y.min_1
              let conv.s0.x.max_1 = conv.s1.x.max_1
              let conv.s0.x.min_1 = conv.s1.x.min_1
              let kernel.s9.y.max_1 = conv.s1.r$y.max_1
              let kernel.s9.y.min_1 = conv.s1.r$y.min_1
              let kernel.s9.x.max_1 = conv.s1.r$x.max_1
              let kernel.s9.x.min_1 = conv.s1.r$x.min_1
              let kernel.s8.y.max_1 = conv.s1.r$y.max_1
              let kernel.s8.y.min_1 = conv.s1.r$y.min_1
              let kernel.s8.x.max_1 = conv.s1.r$x.max_1
              let kernel.s8.x.min_1 = conv.s1.r$x.min_1
              let kernel.s7.y.max_1 = conv.s1.r$y.max_1
              let kernel.s7.y.min_1 = conv.s1.r$y.min_1
              let kernel.s7.x.max_1 = conv.s1.r$x.max_1
              let kernel.s7.x.min_1 = conv.s1.r$x.min_1
              let kernel.s6.y.max_1 = conv.s1.r$y.max_1
              let kernel.s6.y.min_1 = conv.s1.r$y.min_1
              let kernel.s6.x.max_1 = conv.s1.r$x.max_1
              let kernel.s6.x.min_1 = conv.s1.r$x.min_1
              let kernel.s5.y.max_1 = conv.s1.r$y.max_1
              let kernel.s5.y.min_1 = conv.s1.r$y.min_1
              let kernel.s5.x.max_1 = conv.s1.r$x.max_1
              let kernel.s5.x.min_1 = conv.s1.r$x.min_1
              let kernel.s4.y.max_1 = conv.s1.r$y.max_1
              let kernel.s4.y.min_1 = conv.s1.r$y.min_1
              let kernel.s4.x.max_1 = conv.s1.r$x.max_1
              let kernel.s4.x.min_1 = conv.s1.r$x.min_1
              let kernel.s3.y.max_1 = conv.s1.r$y.max_1
              let kernel.s3.y.min_1 = conv.s1.r$y.min_1
              let kernel.s3.x.max_1 = conv.s1.r$x.max_1
              let kernel.s3.x.min_1 = conv.s1.r$x.min_1
              let kernel.s2.y.max_1 = conv.s1.r$y.max_1
              let kernel.s2.y.min_1 = conv.s1.r$y.min_1
              let kernel.s2.x.max_1 = conv.s1.r$x.max_1
              let kernel.s2.x.min_1 = conv.s1.r$x.min_1
              let kernel.s1.y.max_1 = conv.s1.r$y.max_1
              let kernel.s1.y.min_1 = conv.s1.r$y.min_1
              let kernel.s1.x.max_1 = conv.s1.r$x.max_1
              let kernel.s1.x.min_1 = conv.s1.r$x.min_1
              let kernel.s0.y.max_1 = conv.s1.r$y.max_1
              let kernel.s0.y.min_1 = conv.s1.r$y.min_1
              let kernel.s0.x.max_1 = conv.s1.r$x.max_1
              let kernel.s0.x.min_1 = conv.s1.r$x.min_1
              let kernel.y.max_realized = max(kernel.s0.y.max_1, 2)
              let kernel.y.min_realized = min(kernel.s0.y.min_1, 0)
              let kernel.y.extent_realized = ((max(kernel.s0.y.max_1, 2) - min(kernel.s0.y.min_1, 0)) + 1)
              let kernel.x.max_realized = max(kernel.s0.x.max_1, 2)
              let kernel.x.min_realized = min(kernel.s0.x.min_1, 0)
              let kernel.x.extent_realized = ((max(kernel.s0.x.max_1, 2) - min(kernel.s0.x.min_1, 0)) + 1)
              realize hw_input.stencil_update.stream([0, 1], [0, 1]) {
                stream_subimage("buffer_to_stream", hw_input.buffer, hw_input.stencil_update.stream, _halide_buffer_get_host(hw_input(0, 0)), hw_input.stride.0, 64, hw_input.stride.1, 64)
                realize hw_output.stencil.stream([0, 1], [0, 1]) {
                  stream_subimage("stream_to_buffer", hw_output.buffer, hw_output.stencil.stream, _halide_buffer_get_host(hw_output(0, 0)), hw_output.stride.0, 62, hw_output.stride.1, 62)
                  produce _hls_target.hw_output {
                    realize kernel([kernel.x.min_realized, kernel.x.extent_realized], [kernel.y.min_realized, kernel.y.extent_realized]) {
                      produce kernel {
                        let kernel.s0.y.loop_max = 2
                        let kernel.s0.y.loop_min = 0
                        let kernel.s0.y.loop_extent = 3
                        let kernel.s0.x.loop_max = 2
                        let kernel.s0.x.loop_min = 0
                        let kernel.s0.x.loop_extent = 3
                        let kernel.s1.y.loop_max = 2
                        let kernel.s1.y.loop_min = 0
                        let kernel.s1.y.loop_extent = 3
                        let kernel.s1.x.loop_max = 2
                        let kernel.s1.x.loop_min = 0
                        let kernel.s1.x.loop_extent = 3
                        let kernel.s2.y.loop_max = 2
                        let kernel.s2.y.loop_min = 0
                        let kernel.s2.y.loop_extent = 3
                        let kernel.s2.x.loop_max = 2
                        let kernel.s2.x.loop_min = 0
                        let kernel.s2.x.loop_extent = 3
                        let kernel.s3.y.loop_max = 2
                        let kernel.s3.y.loop_min = 0
                        let kernel.s3.y.loop_extent = 3
                        let kernel.s3.x.loop_max = 2
                        let kernel.s3.x.loop_min = 0
                        let kernel.s3.x.loop_extent = 3
                        let kernel.s4.y.loop_max = 2
                        let kernel.s4.y.loop_min = 0
                        let kernel.s4.y.loop_extent = 3
                        let kernel.s4.x.loop_max = 2
                        let kernel.s4.x.loop_min = 0
                        let kernel.s4.x.loop_extent = 3
                        let kernel.s5.y.loop_max = 2
                        let kernel.s5.y.loop_min = 0
                        let kernel.s5.y.loop_extent = 3
                        let kernel.s5.x.loop_max = 2
                        let kernel.s5.x.loop_min = 0
                        let kernel.s5.x.loop_extent = 3
                        let kernel.s6.y.loop_max = 2
                        let kernel.s6.y.loop_min = 0
                        let kernel.s6.y.loop_extent = 3
                        let kernel.s6.x.loop_max = 2
                        let kernel.s6.x.loop_min = 0
                        let kernel.s6.x.loop_extent = 3
                        let kernel.s7.y.loop_max = 2
                        let kernel.s7.y.loop_min = 0
                        let kernel.s7.y.loop_extent = 3
                        let kernel.s7.x.loop_max = 2
                        let kernel.s7.x.loop_min = 0
                        let kernel.s7.x.loop_extent = 3
                        let kernel.s8.y.loop_max = 2
                        let kernel.s8.y.loop_min = 0
                        let kernel.s8.y.loop_extent = 3
                        let kernel.s8.x.loop_max = 2
                        let kernel.s8.x.loop_min = 0
                        let kernel.s8.x.loop_extent = 3
                        let kernel.s9.y.loop_max = 2
                        let kernel.s9.y.loop_min = 0
                        let kernel.s9.y.loop_extent = 3
                        let kernel.s9.x.loop_max = 2
                        let kernel.s9.x.loop_min = 0
                        let kernel.s9.x.loop_extent = 3
                        for (kernel.s0.y, kernel.s0.y.loop_min, kernel.s0.y.loop_extent) {
                          for (kernel.s0.x, kernel.s0.x.loop_min, kernel.s0.x.loop_extent) {
                            kernel(kernel.s0.x, kernel.s0.y) = 0
                          }
                        }
                        kernel(0, 0) = 1
                        kernel(0, 1) = 0
                        kernel(0, 2) = 0
                        kernel(1, 0) = 0
                        kernel(1, 1) = 0
                        kernel(1, 2) = 0
                        kernel(2, 0) = 0
                        kernel(2, 1) = 0
                        kernel(2, 2) = 0
                      }
                      consume kernel {
                        let conv.y.max_realized = (min(likely_if_innermost((hw_output.s0.y.yo*62)), 0) + 61)
                        let conv.y.min_realized = min(likely_if_innermost((hw_output.s0.y.yo*62)), 0)
                        let conv.y.extent_realized = 62
                        let conv.x.max_realized = (min(likely_if_innermost((hw_output.s0.x.xo*62)), 0) + 61)
                        let conv.x.min_realized = min(likely_if_innermost((hw_output.s0.x.xo*62)), 0)
                        let conv.x.extent_realized = 62
                        let hw_output.s0.y = (min(likely_if_innermost((hw_output.s0.y.yo*62)), 0) + hw_output.s0.y.yi)
                        let hw_output.s0.x = (hw_output.s0.x.xi.base + hw_output.s0.x.xi)
                        let hw_output.s0.y.min_2 = (hw_output.s0.y.yi.base + hw_output.s0.y.yi)
                        let hw_output.s0.y.max_2 = hw_output.s0.y.min_2
                        let hw_output.s0.x.min_2 = (hw_output.s0.x.xi.base + hw_output.s0.x.xi)
                        let hw_output.s0.x.max_2 = hw_output.s0.x.min_2
                        let conv.s1.r$y.max_2 = ((3 + 0) - 1)
                        let conv.s1.r$y.min_2 = 0
                        let conv.s1.r$x.max_2 = ((3 + 0) - 1)
                        let conv.s1.r$x.min_2 = 0
                        let conv.s1.y.max_2 = hw_output.s0.y.max_2
                        let conv.s1.y.min_2 = hw_output.s0.y.min_2
                        let conv.s1.x.max_2 = hw_output.s0.x.max_2
                        let conv.s1.x.min_2 = hw_output.s0.x.min_2
                        let conv.s0.y.max_2 = conv.s1.y.max_2
                        let conv.s0.y.min_2 = conv.s1.y.min_2
                        let conv.s0.x.max_2 = conv.s1.x.max_2
                        let conv.s0.x.min_2 = conv.s1.x.min_2
                        realize hw_input.stencil.stream([0, 3], [0, 3]) {
                          hwbuffer(hw_input.stencil_update.stream, hw_input.stencil.stream, (uint64)2, 64, 64, 1, 1, 1, 1, 3, 3, 3, 3, (uint64)2, 62, 62, 0, 1, 1, 1)
                          dispatch_stream(hw_input.stencil.stream, 2, 3, 1, 64, 3, 1, 64, 1, "conv", 0, 0, 62, 0, 62)
                          realize conv.stencil.stream([0, 1], [0, 1]) {
                            produce conv.stencil.stream {
                              for (conv.y.__scan_dim_1, 0, 62) {
                                let hw_output.s0.x.xi = conv.y.__scan_dim_1
                                for (conv.x.__scan_dim_0, 0, 62) {
                                  let hw_output.s0.y.yi = conv.x.__scan_dim_0
                                  realize hw_input.stencil([0, 3], [0, 3]) {
                                    produce hw_input.stencil {
                                      read_stream(hw_input.stencil.stream, hw_input.stencil, "conv")
                                    }
                                    consume hw_input.stencil {
                                      realize hw_input.stencil([0, 3], [0, 3]) {
                                        produce hw_input.stencil {
                                          read_stream(hw_input.stencil.stream, hw_input.stencil, "conv")
                                        }
                                        consume hw_input.stencil {
                                          realize conv.stencil([0, 1], [0, 1]) {
                                            produce conv.stencil {
                                              read_stream(conv.stencil.stream, conv.stencil)
                                            }
                                            consume conv.stencil {
                                              realize conv.stencil([0, 1], [0, 1]) {
                                                produce conv.stencil {
                                                  read_stream(conv.stencil.stream, conv.stencil)
                                                }
                                                consume conv.stencil {
                                                  realize conv.stencil([0, 1], [0, 1]) {
                                                    produce conv.stencil {
                                                      let conv.s0.y.loop_max = (min(likely_if_innermost((hw_output.s0.y.yo*62)), 0) + hw_output.s0.y.yi)
                                                      let conv.s0.y.loop_min = (min(likely_if_innermost((hw_output.s0.y.yo*62)), 0) + hw_output.s0.y.yi)
                                                      let conv.s0.y.loop_extent = 1
                                                      let conv.s0.x.loop_max = (min(likely_if_innermost((hw_output.s0.x.xo*62)), 0) + hw_output.s0.x.xi)
                                                      let conv.s0.x.loop_min = (min(likely_if_innermost((hw_output.s0.x.xo*62)), 0) + hw_output.s0.x.xi)
                                                      let conv.s0.x.loop_extent = 1
                                                      let conv.s1.r$y.loop_extent = 3
                                                      let conv.s1.r$y.loop_max = 2
                                                      let conv.s1.r$y.loop_min = 0
                                                      let conv.s1.r$x.loop_extent = 3
                                                      let conv.s1.r$x.loop_max = 2
                                                      let conv.s1.r$x.loop_min = 0
                                                      let conv.s1.y.loop_max = (min(likely_if_innermost((hw_output.s0.y.yo*62)), 0) + hw_output.s0.y.yi)
                                                      let conv.s1.y.loop_min = (min(likely_if_innermost((hw_output.s0.y.yo*62)), 0) + hw_output.s0.y.yi)
                                                      let conv.s1.y.loop_extent = 1
                                                      let conv.s1.x.loop_max = (min(likely_if_innermost((hw_output.s0.x.xo*62)), 0) + hw_output.s0.x.xi)
                                                      let conv.s1.x.loop_min = (min(likely_if_innermost((hw_output.s0.x.xo*62)), 0) + hw_output.s0.x.xi)
                                                      let conv.s1.x.loop_extent = 1
                                                      let conv.s1.r$x.r$x.loop_extent = 1
                                                      let conv.s1.r$x.r$x.loop_max = 0
                                                      let conv.s1.r$x.r$x.loop_min = 0
                                                      let conv.s1.r$x.r8.loop_extent = 3
                                                      let conv.s1.r$x.r8.loop_max = 2
                                                      let conv.s1.r$x.r8.loop_min = 0
                                                      let conv.s1.r$y.r$y.loop_extent = 1
                                                      let conv.s1.r$y.r$y.loop_max = 0
                                                      let conv.s1.r$y.r$y.loop_min = 0
                                                      let conv.s1.r$y.r9.loop_extent = 3
                                                      let conv.s1.r$y.r9.loop_max = 2
                                                      let conv.s1.r$y.r9.loop_min = 0
                                                      for (conv.stencil.s0.y, 0, 1) {
                                                        let conv.s0.y = (conv.stencil.s0.y + conv.s0.y.loop_min)
                                                        for (conv.stencil.s0.x, 0, 1) {
                                                          let conv.s0.x = (conv.stencil.s0.x + conv.s0.x.loop_min)
                                                          conv.stencil(0, 0) = 0
                                                        }
                                                      }
                                                      for (conv.stencil.s1.y, 0, 1) {
                                                        let conv.s1.y = (conv.stencil.s1.y + conv.s1.y.loop_min)
                                                        for (conv.stencil.s1.x, 0, 1) {
                                                          let conv.s1.x = (conv.stencil.s1.x + conv.s1.x.loop_min)
                                                          for (conv.s1.r$y.r$y, conv.s1.r$y.r$y.loop_min, conv.s1.r$y.r$y.loop_extent) {
                                                            let conv.s1.r$y.r9.base = (conv.s1.r$y.r$y*3)
                                                            unrolled (conv.s1.r$y.r9, conv.s1.r$y.r9.loop_min, conv.s1.r$y.r9.loop_extent) {
                                                              let conv.s1.r$y = ((conv.s1.r$y.r$y*3) + conv.s1.r$y.r9)
                                                              for (conv.s1.r$x.r$x, conv.s1.r$x.r$x.loop_min, conv.s1.r$x.r$x.loop_extent) {
                                                                let conv.s1.r$x.r8.base = (conv.s1.r$x.r$x*3)
                                                                unrolled (conv.s1.r$x.r8, conv.s1.r$x.r8.loop_min, conv.s1.r$x.r8.loop_extent) {
                                                                  let conv.s1.r$x = ((conv.s1.r$x.r$x*3) + conv.s1.r$x.r8)
                                                                  let conv.s1.r$y.max_3 = ((conv.s1.r$y.r$y*3) + conv.s1.r$y.r9)
                                                                  let conv.s1.r$y.min_3 = ((conv.s1.r$y.r$y*3) + conv.s1.r$y.r9)
                                                                  let conv.s1.r$x.max_3 = ((conv.s1.r$x.r$x*3) + conv.s1.r$x.r8)
                                                                  let conv.s1.r$x.min_3 = ((conv.s1.r$x.r$x*3) + conv.s1.r$x.r8)
                                                                  conv.stencil(0, 0) = (conv.stencil(0, 0) + (kernel((conv.s1.r$x.r8.base + conv.s1.r$x.r8), (conv.s1.r$y.r9.base + conv.s1.r$y.r9))*int32(hw_input.stencil(conv.s1.r$x.r8, conv.s1.r$y.r9))))
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                    produce conv.stencil {
                                                      write_stream(conv.stencil.stream, conv.stencil)
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            consume conv.stencil.stream {
                              dispatch_stream(conv.stencil.stream, 2, 1, 1, 62, 1, 1, 62, 2, "conv", 0, 0, 62, 0, 62, "hw_output", 0, 0, 62, 0, 62)
                              produce hw_output.stencil.stream {
                                for (hw_output.y.__scan_dim_1, 0, 62) {
                                  let hw_output.s0.x.xi = hw_output.y.__scan_dim_1
                                  for (hw_output.x.__scan_dim_0, 0, 62) {
                                    let hw_output.s0.y.yi = hw_output.x.__scan_dim_0
                                    realize conv.stencil([0, 1], [0, 1]) {
                                      produce conv.stencil {
                                        read_stream(conv.stencil.stream, conv.stencil, "hw_output")
                                      }
                                      consume conv.stencil {
                                        realize conv.stencil([0, 1], [0, 1]) {
                                          produce conv.stencil {
                                            read_stream(conv.stencil.stream, conv.stencil, "hw_output")
                                          }
                                          consume conv.stencil {
                                            realize conv.stencil([0, 1], [0, 1]) {
                                              produce conv.stencil {
                                                read_stream(conv.stencil.stream, conv.stencil, "hw_output")
                                              }
                                              consume conv.stencil {
                                                realize conv.stencil([0, 1], [0, 1]) {
                                                  produce conv.stencil {
                                                    read_stream(conv.stencil.stream, conv.stencil, "hw_output")
                                                  }
                                                  consume conv.stencil {
                                                    realize hw_output.stencil([0, 1], [0, 1]) {
                                                      produce hw_output.stencil {
                                                        hw_output.stencil(hw_output.s0.x.xi, hw_output.s0.y.yi) = uint8(conv.stencil(hw_output.s0.x.xi, hw_output.s0.y.yi))
                                                      }
                                                      consume hw_output.stencil {
                                                        write_stream(hw_output.stencil.stream, hw_output.stencil, hw_output.x.__scan_dim_0, 61, hw_output.y.__scan_dim_1, 61)
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              consume hw_output.stencil.stream {
                                0
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  consume _hls_target.hw_output {
                    0
                  }
                }
              }
            }
          }
        }
        consume hw_output {
          assert(((0 <= output.s0.y.min_unbounded) && (((62 + 0) - 1) >= output.s0.y.max_unbounded)), halide_error_explicit_bounds_too_small("y", "output", 0, ((62 + 0) - 1), output.s0.y.min_unbounded, output.s0.y.max_unbounded))
          assert(((0 <= output.s0.x.min_unbounded) && (((62 + 0) - 1) >= output.s0.x.max_unbounded)), halide_error_explicit_bounds_too_small("x", "output", 0, ((62 + 0) - 1), output.s0.x.min_unbounded, output.s0.x.max_unbounded))
          produce output {
            let output.s0.y.loop_max = 61
            let output.s0.y.loop_min = 0
            let output.s0.y.loop_extent = 62
            let output.s0.x.loop_max = 61
            let output.s0.x.loop_min = 0
            let output.s0.x.loop_extent = 62
            for (output.s0.y, output.s0.y.loop_min, output.s0.y.loop_extent) {
              for (output.s0.x, output.s0.x.loop_min, output.s0.x.loop_extent) {
                output(output.s0.x, output.s0.y) = hw_output(output.s0.x, output.s0.y)
              }
            }
          }
        }
      }
    }
  }
}

Not attempting to fold conv.stencil because it is a stream or a stencil.
Not attempting to fold conv.stencil because it is a stream or a stencil.
Not attempting to fold conv.stencil because it is a stream or a stencil.
Not attempting to fold hw_input.stencil because it is a stream or a stencil.
Not attempting to fold hw_input.stencil because it is a stream or a stencil.
Not attempting to fold hw_output.stencil because it is a stream or a stencil.
Not attempting to fold conv.stencil because it is a stream or a stencil.
Not attempting to fold conv.stencil because it is a stream or a stencil.
Not attempting to fold conv.stencil because it is a stream or a stencil.
Not attempting to fold conv.stencil because it is a stream or a stencil.
Not attempting to fold conv.stencil.stream because it is a stream or a stencil.
Not attempting to fold hw_input.stencil.stream because it is a stream or a stencil.
  did not fold kernel
Not attempting to fold hw_output.stencil.stream because it is a stream or a stencil.
Not attempting to fold hw_input.stencil_update.stream because it is a stream or a stencil.
  did not fold hw_output
  did not fold hw_input
Flattening hw_input because it is not a stream nor a stencil.
Flattening hw_output because it is not a stream nor a stencil.
Flattening kernel because it is not a stream nor a stencil.
Not attempting to flatten conv.stencil because it is a stream or a stencil.
Not attempting to flatten conv.stencil because it is a stream or a stencil.
Not attempting to flatten conv.stencil because it is a stream or a stencil.
Not attempting to flatten hw_input.stencil because it is a stream or a stencil.
Not attempting to flatten hw_input.stencil because it is a stream or a stencil.
Not attempting to flatten hw_output.stencil because it is a stream or a stencil.
Not attempting to flatten conv.stencil because it is a stream or a stencil.
Not attempting to flatten conv.stencil because it is a stream or a stencil.
Not attempting to flatten conv.stencil because it is a stream or a stencil.
Not attempting to flatten conv.stencil because it is a stream or a stencil.
Not attempting to flatten conv.stencil.stream because it is a stream or a stencil.
Not attempting to flatten hw_input.stencil.stream because it is a stream or a stencil.
Not attempting to flatten hw_output.stencil.stream because it is a stream or a stencil.
Not attempting to flatten hw_input.stencil_update.stream because it is a stream or a stencil.
Module.compile(): coreir_source_name ./bin/conv_3_3_coreir.cpp with folder=./bin/
creating file from name: conv_3_3
found a pc named hw_input
found a pc for generating coreir
allocate kernel[int32 * 9]
produce kernel {
  for (kernel.s0.y, 0, 3) {
    let t12 = (kernel.s0.y*3)
    for (kernel.s0.x, 0, 3) {
      kernel[(kernel.s0.x + t12)] = 0
    }
  }
  kernel[0] = 1
  kernel[3] = 0
  kernel[6] = 0
  kernel[1] = 0
  kernel[4] = 0
  kernel[7] = 0
  kernel[2] = 0
  kernel[5] = 0
  kernel[8] = 0
}
consume kernel {
  realize hw_input.stencil.stream([0, 3], [0, 3]) {
    hwbuffer(hw_input.stencil_update.stream, hw_input.stencil.stream, (uint64)2, 64, 64, 1, 1, 1, 1, 3, 3, 3, 3, (uint64)2, 62, 62, 0, 1, 1, 1)
    dispatch_stream(hw_input.stencil.stream, 2, 3, 1, 64, 3, 1, 64, 1, "conv", 0, 0, 62, 0, 62)
    realize conv.stencil.stream([0, 1], [0, 1]) {
      produce conv.stencil.stream {
        for (conv.y.__scan_dim_1, 0, 62) {
          for (conv.x.__scan_dim_0, 0, 62) {
            realize hw_input.stencil([0, 3], [0, 3]) {
              produce hw_input.stencil {
                read_stream(hw_input.stencil.stream, hw_input.stencil, "conv")
              }
              consume hw_input.stencil {
                realize hw_input.stencil([0, 3], [0, 3]) {
                  produce hw_input.stencil {
                    read_stream(hw_input.stencil.stream, hw_input.stencil, "conv")
                  }
                  consume hw_input.stencil {
                    realize conv.stencil([0, 1], [0, 1]) {
                      produce conv.stencil {
                        read_stream(conv.stencil.stream, conv.stencil)
                      }
                      consume conv.stencil {
                        realize conv.stencil([0, 1], [0, 1]) {
                          produce conv.stencil {
                            read_stream(conv.stencil.stream, conv.stencil)
                          }
                          consume conv.stencil {
                            realize conv.stencil([0, 1], [0, 1]) {
                              produce conv.stencil {
                                conv.stencil(0, 0) = 0
                                conv.stencil(0, 0) = (conv.stencil(0, 0) + (kernel[0]*int32(hw_input.stencil(0, 0))))
                                conv.stencil(0, 0) = (conv.stencil(0, 0) + (kernel[1]*int32(hw_input.stencil(1, 0))))
                                conv.stencil(0, 0) = (conv.stencil(0, 0) + (kernel[2]*int32(hw_input.stencil(2, 0))))
                                conv.stencil(0, 0) = (conv.stencil(0, 0) + (kernel[3]*int32(hw_input.stencil(0, 1))))
                                conv.stencil(0, 0) = (conv.stencil(0, 0) + (kernel[4]*int32(hw_input.stencil(1, 1))))
                                conv.stencil(0, 0) = (conv.stencil(0, 0) + (kernel[5]*int32(hw_input.stencil(2, 1))))
                                conv.stencil(0, 0) = (conv.stencil(0, 0) + (kernel[6]*int32(hw_input.stencil(0, 2))))
                                conv.stencil(0, 0) = (conv.stencil(0, 0) + (kernel[7]*int32(hw_input.stencil(1, 2))))
                                conv.stencil(0, 0) = (conv.stencil(0, 0) + (kernel[8]*int32(hw_input.stencil(2, 2))))
                              }
                              produce conv.stencil {
                                write_stream(conv.stencil.stream, conv.stencil)
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      free kernel
      consume conv.stencil.stream {
        dispatch_stream(conv.stencil.stream, 2, 1, 1, 62, 1, 1, 62, 2, "conv", 0, 0, 62, 0, 62, "hw_output", 0, 0, 62, 0, 62)
        produce hw_output.stencil.stream {
          for (hw_output.y.__scan_dim_1, 0, 62) {
            for (hw_output.x.__scan_dim_0, 0, 62) {
              realize conv.stencil([0, 1], [0, 1]) {
                produce conv.stencil {
                  read_stream(conv.stencil.stream, conv.stencil, "hw_output")
                }
                consume conv.stencil {
                  realize conv.stencil([0, 1], [0, 1]) {
                    produce conv.stencil {
                      read_stream(conv.stencil.stream, conv.stencil, "hw_output")
                    }
                    consume conv.stencil {
                      realize conv.stencil([0, 1], [0, 1]) {
                        produce conv.stencil {
                          read_stream(conv.stencil.stream, conv.stencil, "hw_output")
                        }
                        consume conv.stencil {
                          realize conv.stencil([0, 1], [0, 1]) {
                            produce conv.stencil {
                              read_stream(conv.stencil.stream, conv.stencil, "hw_output")
                            }
                            consume conv.stencil {
                              realize hw_output.stencil([0, 1], [0, 1]) {
                                produce hw_output.stencil {
                                  hw_output.stencil(hw_output.y.__scan_dim_1, hw_output.x.__scan_dim_0) = uint8(conv.stencil(hw_output.y.__scan_dim_1, hw_output.x.__scan_dim_0))
                                }
                                consume hw_output.stencil {
                                  write_stream(hw_output.stencil.stream, hw_output.stencil, hw_output.x.__scan_dim_0, 61, hw_output.y.__scan_dim_1, 61)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

var: hw_input.stencil_update.stream
var: hw_output.stencil.stream
output with appended width=1
output with appended width=1
creating a design with 1 inputs from 2 args
Module: global.DesignTop
  Type: {'in':{'arg_0':BitIn[16][1][1]}, 'reset':BitIn, 'in_en':BitIn, 'out':Bit[16][1][1], 'valid':Bit}
  Def? No
output with appended width=1
output with appended width=1
creating a design with 1 inputs from 2 args
Module: global.DesignTop
  Type: {'in':{'arg_0':BitIn[16][1][1]}, 'reset':BitIn, 'in_en':BitIn, 'out':Bit[16][1][1], 'valid':Bit}
  Def? No
// rename wire for arg_0 to _hw_input_stencil_update_stream
found alloc#=0
// rename wire for 1 to _kernela0_0
// rename wire for 0 to _kernela0_3
// rename wire for 0 to _kernela0_6
// rename wire for 0 to _kernela0_1
// rename wire for 0 to _kernela0_4
// rename wire for 0 to _kernela0_7
// rename wire for 0 to _kernela0_2
// rename wire for 0 to _kernela0_5
// rename wire for 0 to _kernela0_8
found the hwbuffer call:
hwbuffer(hw_input.stencil_update.stream, hw_input.stencil.stream, (uint64)2, 64, 64, 1, 1, 1, 1, 3, 3, 3, 3, (uint64)2, 62, 62, 0, 1, 1, 1)
hwbuffer has num_dims=2

0x55ada9673ab0
hwbuffer: _hw_input_stencil_update_stream
  input_ports=[1,1]
  output_ports=[3,3]
  capacity=[64,64]
  access: ranges=[62,62]
          dim_refs=[0,1]
          strides=[1,1]
extracting..
num_reduction_iter=1
running..
hwbuffer: _hw_input_stencil_update_stream
  width=16  depth=4096  iter_cnt=3844
  num_dims=2  rate_matched=0  stencil_width=0
  num_ports:  in=1 out=9
  output:  stride0=1 range0=62
           stride1=64 range1=62
  output_start_addr=[0,1,2,64,65,66,128,129,130]
  chain_en=0  chain_idx=0
let's get some wires
got some ub wires
connection time
created that unified buffer! ub_hw_input_stencil_update_stream
// rename wire for _hw_input_stencil_stream to _hw_input_stencil_stream_to_conv
// rename wire for _hw_input_stencil_stream_to_conv to _hw_input_stencil
// rename wire for _hw_input_stencil_stream_to_conv to _hw_input_stencil
// rename wire for _conv_stencil_stream to _conv_stencil
// rename wire for _conv_stencil_stream to _conv_stencil
// rename wire for _conv_stencil to _242
// rename wire for _kernela0_0 to _243
// rename wire for _hw_input_stencil to _244
// rename wire for _244 to _245
// rename wire for _conv_stencil to _248
// rename wire for _kernela0_1 to _249
// rename wire for _hw_input_stencil to _250
// rename wire for _250 to _251
// rename wire for _conv_stencil to _254
// rename wire for _kernela0_2 to _255
// rename wire for _hw_input_stencil to _256
// rename wire for _256 to _257
// rename wire for _conv_stencil to _260
// rename wire for _kernela0_3 to _261
// rename wire for _hw_input_stencil to _262
// rename wire for _262 to _263
// rename wire for _conv_stencil to _266
// rename wire for _kernela0_4 to _267
// rename wire for _hw_input_stencil to _268
// rename wire for _268 to _269
// rename wire for _conv_stencil to _272
// rename wire for _kernela0_5 to _273
// rename wire for _hw_input_stencil to _274
// rename wire for _274 to _275
// rename wire for _conv_stencil to _278
// rename wire for _kernela0_6 to _279
// rename wire for _hw_input_stencil to _280
// rename wire for _280 to _281
// rename wire for _conv_stencil to _284
// rename wire for _kernela0_7 to _285
// rename wire for _hw_input_stencil to _286
// rename wire for _286 to _287
// rename wire for _conv_stencil to _290
// rename wire for _kernela0_8 to _291
// rename wire for _hw_input_stencil to _292
// rename wire for _292 to _293
// rename wire for _conv_stencil to _conv_stencil_stream
// rename wire for _conv_stencil_stream to _conv_stencil_stream_to_conv
// rename wire for _conv_stencil_stream to _conv_stencil_stream_to_hw_output
// rename wire for _conv_stencil_stream_to_hw_output to _conv_stencil
// rename wire for _conv_stencil_stream_to_hw_output to _conv_stencil
// rename wire for _conv_stencil_stream_to_hw_output to _conv_stencil
// rename wire for _conv_stencil_stream_to_hw_output to _conv_stencil
// rename wire for _296 to _297
// rename wire for _hw_output_stencil to _hw_output_stencil_stream
found a pc named hw_output
found a pc named output
found a pc named hw_output
found a pc named hw_input
Module: global.DesignTop
  Type: {'in':{'arg_0':BitIn[16][1][1]}, 'reset':BitIn, 'in_en':BitIn, 'out':Bit[16][1][1], 'valid':Bit}
  Def? Yes
  Def:
    Instances:
      _conv_stencil0_mux1_0 : muxn(N:1, width:16)
      _conv_stencil1_mux1_0 : muxn(N:1, width:16)
      abstract_ub_hw_input_stencil_update_stream : abstract_unified_buffer(capacity:Bit[64][64], dim_ref:Bit[0][1], input_ports:BitIn[16][1][1], output_ports:Bit[16][3][3], range:Bit[62][62], stride:Bit[1][1])
      add_242_246_247 : add(width:16)
      add_248_252_253 : add(width:16)
      add_254_258_259 : add(width:16)
      add_260_264_265 : add(width:16)
      add_266_270_271 : add(width:16)
      add_272_276_277 : add(width:16)
      add_278_282_283 : add(width:16)
      add_284_288_289 : add(width:16)
      add_290_294_295 : add(width:16)
      add_kernel_s0_x_240_241 : add(width:16)
      const0_0 : const(width:16)
      const0_0$1 : const(width:16)
      const0_0$2 : const(width:16)
      const0_0$3 : const(width:16)
      const0_0$4 : const(width:16)
      const0_0$5 : const(width:16)
      const0_0$6 : const(width:16)
      const0_0$7 : const(width:16)
      const0_0$8 : const(width:16)
      const1_1 : const(width:16)
      const3_3 : const(width:16)
      count__hw_output_x___scan_dim_0 : counter(inc:1, max:61, min:0, width:16)
      count__hw_output_x___scan_dim_0_wen : const
      count__hw_output_y___scan_dim_1 : counter(inc:1, max:61, min:0, width:16)
      count__kernel_s0_x : counter(inc:1, max:2, min:0, width:16)
      count__kernel_s0_x_wen : const
      count__kernel_s0_y : counter(inc:1, max:2, min:0, width:16)
      mul_243_245_246 : mul(width:16)
      mul_249_251_252 : mul(width:16)
      mul_255_257_258 : mul(width:16)
      mul_261_263_264 : mul(width:16)
      mul_267_269_270 : mul(width:16)
      mul_273_275_276 : mul(width:16)
      mul_279_281_282 : mul(width:16)
      mul_285_287_288 : mul(width:16)
      mul_291_293_294 : mul(width:16)
      mul_kernel_s0_y3_240 : mul(width:16)
      pt_296_p21 : wire(type:Bit[16])
      pt_conv_stencil_p10 : wire(type:Bit[16][1][1])
      pt_conv_stencil_p11 : wire(type:Bit[16][1][1])
      pt_conv_stencil_p12 : wire(type:Bit[16][1][1])
      pt_conv_stencil_p13 : wire(type:Bit[16][1][1])
      pt_conv_stencil_p14 : wire(type:Bit[16][1][1])
      pt_conv_stencil_p15 : wire(type:Bit[16][1][1])
      pt_conv_stencil_p6 : wire(type:Bit[16][1][1])
      pt_conv_stencil_p7 : wire(type:Bit[16][1][1])
      pt_conv_stencil_p8 : wire(type:Bit[16][1][1])
      pt_conv_stencil_p9 : wire(type:Bit[16][1][1])
      pt_hw_output_stencil_p20 : wire(type:Bit[16][1][1])
      selslice_conv_stencil0_mux1_0 : slice(hi:1, lo:0, width:16)
      selslice_conv_stencil1_mux1_0 : slice(hi:1, lo:0, width:16)
      ub_hw_input_stencil_update_stream : unified_buffer(chain_en:False, chain_idx:0, depth:4096, dimensionality:2, init:null, input_chunk:{"input_chunk":[1]}, input_range_0:1, input_range_1:1, input_range_2:0, input_range_3:0, input_range_4:0, input_range_5:0, input_starting_addrs:{"input_start":[0]}, input_stride_0:1, input_stride_1:1, input_stride_2:0, input_stride_3:0, input_stride_4:0, input_stride_5:0, iter_cnt:3844, logical_size:{"capacity":[64,64]}, num_input_ports:1, num_output_ports:9, num_reduction_iter:1, num_stencil_acc_dim:0, output_starting_addrs:{"output_start":[0,1,2,64,65,66,128,129,130]}, output_stencil:null, range_0:62, range_1:62, range_2:0, range_3:0, range_4:0, range_5:0, rate_matched:False, stencil_width:0, stride_0:1, stride_1:64, stride_2:0, stride_3:0, stride_4:0, stride_5:0, width:16)
      ub_hw_input_stencil_update_stream_in_reshape : reshape(input_type:BitIn[16][1][1], output_type:Bit[16][1])
      ub_hw_input_stencil_update_stream_out_reshape : reshape(input_type:BitIn[16][9], output_type:Bit[16][3][3])
    Connections:
      ub_hw_input_stencil_update_stream.dataout0 <=> ub_hw_input_stencil_update_stream_out_reshape.in[0]
      ub_hw_input_stencil_update_stream.dataout1 <=> ub_hw_input_stencil_update_stream_out_reshape.in[1]
      count__kernel_s0_x.en <=> count__kernel_s0_x_wen.out
      count__kernel_s0_y.out <=> mul_kernel_s0_y3_240.in0
      const3_3.out <=> mul_kernel_s0_y3_240.in1
      add_254_258_259.in1 <=> mul_255_257_258.out
      add_254_258_259.out <=> pt_conv_stencil_p9.in[0][0]
      add_260_264_265.out <=> pt_conv_stencil_p10.in[0][0]
      mul_267_269_270.in1 <=> ub_hw_input_stencil_update_stream_out_reshape.out[1][1]
      const0_0$4.out <=> mul_267_269_270.in0
      add_266_270_271.in1 <=> mul_267_269_270.out
      add_266_270_271.in0 <=> pt_conv_stencil_p10.out[0][0]
      const0_0$7.out <=> mul_285_287_288.in0
      mul_285_287_288.in1 <=> ub_hw_input_stencil_update_stream_out_reshape.out[2][1]
      add_284_288_289.in1 <=> mul_285_287_288.out
      add_284_288_289.in0 <=> pt_conv_stencil_p13.out[0][0]
      add_284_288_289.out <=> pt_conv_stencil_p14.in[0][0]
      ub_hw_input_stencil_update_stream.dataout2 <=> ub_hw_input_stencil_update_stream_out_reshape.in[2]
      ub_hw_input_stencil_update_stream.dataout3 <=> ub_hw_input_stencil_update_stream_out_reshape.in[3]
      ub_hw_input_stencil_update_stream.dataout4 <=> ub_hw_input_stencil_update_stream_out_reshape.in[4]
      ub_hw_input_stencil_update_stream.dataout5 <=> ub_hw_input_stencil_update_stream_out_reshape.in[5]
      ub_hw_input_stencil_update_stream.dataout6 <=> ub_hw_input_stencil_update_stream_out_reshape.in[6]
      ub_hw_input_stencil_update_stream.dataout7 <=> ub_hw_input_stencil_update_stream_out_reshape.in[7]
      mul_261_263_264.in1 <=> ub_hw_input_stencil_update_stream_out_reshape.out[1][0]
      add_260_264_265.in1 <=> mul_261_263_264.out
      add_260_264_265.in0 <=> pt_conv_stencil_p9.out[0][0]
      const0_0$1.out <=> mul_249_251_252.in0
      ub_hw_input_stencil_update_stream.datain0 <=> ub_hw_input_stencil_update_stream_in_reshape.out[0]
      add_kernel_s0_x_240_241.in1 <=> mul_kernel_s0_y3_240.out
      count__kernel_s0_x.overflow <=> count__kernel_s0_y.en
      add_242_246_247.in1 <=> mul_243_245_246.out
      add_242_246_247.out <=> pt_conv_stencil_p7.in[0][0]
      add_248_252_253.in0 <=> pt_conv_stencil_p7.out[0][0]
      const0_0.out <=> pt_conv_stencil_p6.in[0][0]
      add_248_252_253.in1 <=> mul_249_251_252.out
      add_248_252_253.out <=> pt_conv_stencil_p8.in[0][0]
      add_kernel_s0_x_240_241.in0 <=> count__kernel_s0_x.out
      count__kernel_s0_x.reset <=> self.reset
      const1_1.out <=> mul_243_245_246.in0
      mul_243_245_246.in1 <=> ub_hw_input_stencil_update_stream_out_reshape.out[0][0]
      add_242_246_247.in0 <=> pt_conv_stencil_p6.out[0][0]
      ub_hw_input_stencil_update_stream.dataout8 <=> ub_hw_input_stencil_update_stream_out_reshape.in[8]
      add_290_294_295.out <=> pt_conv_stencil_p15.in[0][0]
      self.valid <=> ub_hw_input_stencil_update_stream.valid
      count__hw_output_y___scan_dim_1.out <=> selslice_conv_stencil0_mux1_0.in
      count__hw_output_y___scan_dim_1.reset <=> self.reset
      count__hw_output_x___scan_dim_0.out <=> selslice_conv_stencil1_mux1_0.in
      count__hw_output_x___scan_dim_0.reset <=> self.reset
      count__hw_output_x___scan_dim_0.en <=> count__hw_output_x___scan_dim_0_wen.out
      add_290_294_295.in0 <=> pt_conv_stencil_p14.out[0][0]
      mul_291_293_294.in1 <=> ub_hw_input_stencil_update_stream_out_reshape.out[2][2]
      const0_0$8.out <=> mul_291_293_294.in0
      add_290_294_295.in1 <=> mul_291_293_294.out
      self.in_en <=> ub_hw_input_stencil_update_stream.wen
      count__kernel_s0_y.reset <=> self.reset
      self.reset <=> ub_hw_input_stencil_update_stream.reset
      add_254_258_259.in0 <=> pt_conv_stencil_p8.out[0][0]
      mul_255_257_258.in1 <=> ub_hw_input_stencil_update_stream_out_reshape.out[0][2]
      add_266_270_271.out <=> pt_conv_stencil_p11.in[0][0]
      add_272_276_277.in0 <=> pt_conv_stencil_p11.out[0][0]
      mul_273_275_276.in1 <=> ub_hw_input_stencil_update_stream_out_reshape.out[1][2]
      const0_0$5.out <=> mul_273_275_276.in0
      add_272_276_277.in1 <=> mul_273_275_276.out
      add_272_276_277.out <=> pt_conv_stencil_p12.in[0][0]
      add_278_282_283.in0 <=> pt_conv_stencil_p12.out[0][0]
      add_278_282_283.in1 <=> mul_279_281_282.out
      add_278_282_283.out <=> pt_conv_stencil_p13.in[0][0]
      mul_279_281_282.in1 <=> ub_hw_input_stencil_update_stream_out_reshape.out[2][0]
      const0_0$6.out <=> mul_279_281_282.in0
      self.in.arg_0 <=> ub_hw_input_stencil_update_stream_in_reshape.in
      _conv_stencil1_mux1_0.out <=> pt_296_p21.in
      _conv_stencil1_mux1_0.in.sel <=> selslice_conv_stencil1_mux1_0.out
      _conv_stencil0_mux1_0.out <=> _conv_stencil1_mux1_0.in.data[0]
      _conv_stencil0_mux1_0.in.sel <=> selslice_conv_stencil0_mux1_0.out
      _conv_stencil0_mux1_0.in.data[0] <=> pt_conv_stencil_p15.out[0][0]
      pt_296_p21.out <=> pt_hw_output_stencil_p20.in[0][0]
      pt_hw_output_stencil_p20.out <=> self.out
      count__hw_output_x___scan_dim_0.overflow <=> count__hw_output_y___scan_dim_1.en
      mul_249_251_252.in1 <=> ub_hw_input_stencil_update_stream_out_reshape.out[0][1]
      const0_0$2.out <=> mul_255_257_258.in0
      const0_0$3.out <=> mul_261_263_264.in0

Saving to json
Validating json
Saving json
Loading json
[0;32mCreated CoreIR design!!![0m
// no instances- 
make[1]: Leaving directory '/nobackup/joeyliu/aha/Halide-to-Hardware/apps/hardware_benchmarks/tests/conv_3_3'
./bin/process run coreir input.png
about to run some passes
Starting topological sort
topo_order.size() = 89
numVertices(g)    = 89
start initialization
9
0
Start Initialize the Func Kernel
generated simulated coreir design
reset clock self.clk
reset self.in_arg_0_0_0 with size 16
reset self.in_en with size 1
reset self.reset with size 1
image is using output valid
starting coreir simulation
execomb..
execomb..
execomb..
execomb..
exeseq..
Could not find select with name = ren
../../hw_support/hardware_targets.mk:108: recipe for target 'bin/output_coreir.png' failed
